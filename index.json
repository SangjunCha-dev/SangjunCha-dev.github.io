[{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":["Go","Gui"],"contents":" 1. 개요 Fyne는 사용하기 쉬운 UI 툴킷과 Go로 작성된 앱 API로 데스크탑 및 모바일 환경을 지원합니다.\n fyne git  1.1. 사전 설정 Fyne 사용시 필요한 개발환경\n Go 버전 1.14 이상 C 컴파일러 및 시스템 개발 도구  tdm-gcc download    테스트 시스템 환경\n   분류 버전     OS Windows 10   go 1.17   fyne 2.1.2    1.2. 라이브러리 설치 \u0026gt; go get fyne.io/fyne/v2  2. 간단한 사용법 2.1. 예제 코드 package main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello\u0026#34;) // 윈도우 명칭 지정  \thello := widget.NewLabel(\u0026#34;Hello World!\u0026#34;) \tw.SetContent( \tcontainer.NewVBox( // 컨텐츠 수직 정렬 \thello, \twidget.NewButton( \t\u0026#34;Hi!\u0026#34;, // 버튼 명칭 \tfunc() { hello.SetText(\u0026#34;Welcome :)\u0026#34;) }, // 버튼 이벤트 \t), \t), \t)  \tw.ShowAndRun() // 윈도우 출력 } 실행\n\u0026gt; go run main.go    버튼 클릭 전 버튼 클릭 후          2.2. 실행 파일 생성 윈도우에서 실행할 수 있는 .exe 파일을 생성한다.\n실행 파일 생성이 필요한 라이브러리 설치\n\u0026gt; go get fyne.io/fyne/v2/cmd/fyne 임의의 아이콘 파일 icon.png을 프로젝트 루트 경로에 생성한다.\n실행 파일 생성 명령어\n\u0026gt; fyne install  3. 레이아웃 예시 3.1. dialog 다이얼로그는 팝업 형태의 창으로 정보를 보여주는 기능이다.\n3.1.1. Information 정보확인용 다이얼로그\ndialog.ShowInformation(\u0026#34;title\u0026#34;, \u0026#34;information message\u0026#34;, window) 기본 설정은 영어 버튼이 표시되므로 수정하려면 아래와 같은 방식을 사용한다.\ninformationDialog := dialog.NewInformation(\u0026#34;title\u0026#34;, \u0026#34;information message\u0026#34;, window) informationDialog.SetDismissText(\u0026#34;확인\u0026#34;) informationDialog.Show() 3.1.2. Confirm 확인/취소 버튼있는 다이얼로그\n 확인/취소에 따른 콜백 구현이 필요하다.  confirmDialog := dialog.NewConfirm(\u0026#34;title\u0026#34;, \u0026#34;프로그램을 종료하시겠습니까?\u0026#34;, (func(res bool) { fmt.Println(res) }), w) confirmDialog.SetDismissText(\u0026#34;취소\u0026#34;) confirmDialog.SetConfirmText(\u0026#34;확인\u0026#34;) confirmDialog.Show() 3.1.3. Error 에러 출력용 다이얼로그\nerr := errors.New(\u0026#34;error message\u0026#34;) dialog.ShowError(err, w) 이외에도 다양한 다이얼로그 기능이 있다.\n3.2. Entry(input) / Button input : 문자열을 입력하는 박스\nbutton : 특정 기능을 동작 시키는 버튼\nentry := widget.NewEntry() entry.SetPlaceHolder(\u0026#34;Entry\u0026#34;) 입력한 문자열은 entry.Text 로 사용가능 하다.\nbutton은 아이콘이 없거나 있는 버튼이 있다.\n// input에 입력한 값을 label에 표시하는 버튼 button := widget.NewButton(\u0026#34;Submit Text Button\u0026#34;, \tfunc() { \tlabel.SetText(entry.Text) \t})  // input에 입력한 값을 label에 표시하는 아이콘 버튼 iconButton := widget.NewButtonWithIcon(\u0026#34;Submit Icon Button\u0026#34;, theme.ConfirmIcon(), \tfunc() { \tlabel.SetText(entry.Text) \t})    버튼 클릭 전 임의의 값 입력 후 버튼 클릭          3.3. Check / Radio check : 여러 항목 중 복수개를 선택할 수 있는 체크 버튼\n 체크 박스 선택에 따른 핸들러 설정이 필요하다.  checkButton := widget.NewCheck(\u0026#34;Check Button\u0026#34;, \tfunc(b bool) { \tmsg := fmt.Sprintf(\u0026#34;check = %v\u0026#34;, b) \tlabel.SetText(msg) \t}) radio : 여러 항목 중 1개만 선택할 수 있는 라디오 버튼\n 라디오 버튼 선택에 따른 핸들러 설정이 필요하다.  options := []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;} radioButton := widget.NewRadioGroup(options, \tfunc(s string) { \tmsg := fmt.Sprintf(\u0026#34;radio = %s\u0026#34;, s) \tlabel.SetText(msg) \t}) 3.4. ProgressBar progressbar : 진행률, 진행상황, 진행여부 등 표시하는 기능 - SetValue(0) ~ SetValue(1) 범위로 동작\nprogress := widget.NewProgressBar() infProgress := widget.NewProgressBarInfinite()  go func() { \tfor i := 0.0; i \u0026lt;= 100; i++ { \tprogress.SetValue(i / 100) \ttime.Sleep(time.Millisecond * 100) \t} }()  4. 한글 폰트 설정 fyne 라이브러리 사용시 한글을 사용하면 글자가 깨져서 UI로 표시된다.\n   폰트 설정 전 폰트 설정 후          한글폰트를 지정하지 않아 생긴 문제로 한글 폰트를 별도로 지정하면 문제가 해결된다.\n key : FYNE_FONT value : (폰트파일 이름).ttf  func main() { \t// 한글 폰트 지정(실행 파일과 동일경로에 폰트파일 위치) \tos.Setenv(\u0026#34;FYNE_FONT\u0026#34;, \u0026#34;NanumGothic.ttf\u0026#34;) \t... 위와 같이 golang에서 환경 변수를 지정한다.\n 5. 예시코드 Git golang-fyne\n 참고(Reference)  fyne git fyne examples Can i change font?  ","date":"February 21, 2022","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2022-02-21-golang-fyne/","summary":"1. 개요 Fyne는 사용하기 쉬운 UI 툴킷과 Go로 작성된 앱 API로 데스크탑 및 모바일 환경을 지원합니다.\n fyne git  1.1. 사전 설정 Fyne 사용시 필요한 개발환경\n Go 버전 1.14 이상 C 컴파일러 및 시스템 개발 도구  tdm-gcc download    테스트 시스템 환경\n   분류 버전     OS Windows 10   go 1.17   fyne 2.1.2    1.","tags":["go","gui"],"title":"[golang] gui 라이브러리 fyne"},{"categories":["Python","pytest"],"contents":" 1. 개요 및 설정 pytest는 에러 없는 좋은 코드를 개발만들기 위한 목적으로 개발된 Python 테스트 프레임워크이다.\npytest 특징\n 다른 testing 라이브러리에 비해 사용법이 간단하다. 테스트를 병렬로 실행할 수 있다. 특정 테스트를 스킵할 수 있다. 다양한 서드 파트 라이브러리들이 있다.  설치\npip install -U pytest  2. 기본 사용법 2.1. 기본 테스트 test_sample.py\n# 테스트 대상 기능 def inc(x):  return x + 1  # 테스트 실행 함수 def test_answer1():  assert inc(3) == 5  def test_answer2():  assert inc(3) == 4 pytest 실행 결과\n\u0026gt; pytest test_sample.py ======================= test session starts ======================== platform win32 -- Python 3.8.10, pytest-7.0.0, pluggy-1.0.0 rootdir: D:\\workspace\\blog\\python\\python-pytest collected 2 items  test_sample.py F. [100%]  ============================= FAILURES ============================= ___________________________ test_answer1 ___________________________   def test_answer1(): \u0026gt; assert inc(3) == 5 E assert 4 == 5 E + where 4 = inc(3)  test_sample.py:7: AssertionError ===================== short test summary info ====================== FAILED test_sample.py::test_answer1 - assert 4 == 5 =================== 1 failed, 1 passed in 0.07s ==================== 테스트 코드에서 의도한대로 inc(3) == 5 부분에서 에러가 발생한다.\n2.2. 예외 테스트 test_sample_raises.py\nimport pytest  def f():  raise SystemExit(1)  def test_mytest():  with pytest.raises(SystemExit):  f() \u0026gt; pytest test_sample_raises.py ======================= test session starts ======================== platform win32 -- Python 3.8.10, pytest-7.0.0, pluggy-1.0.0 rootdir: D:\\workspace_go\\blog\\python\\python-pytest collected 1 item test_sample_raises.py . [100%] ======================== 1 passed in 0.01s ========================= 2.2. 명칭 규약  파일 이름  test_*.py 또는 *_test.py 형식으로 지정한다. *_test.py 는 python 3.8 버전 이상부터 적용된다.   클래스 명칭  class Test* 형식으로 지정한다.   클래스 메서드 및 함수 명칭  def test_* 형식으로 지정한다.    2.3. 실행 방법   해당 작업디렉토리 안에 모든 테스트 파일 실행\n\u0026gt; pytest   특정 디렉토리 내 테스트 파일 실행\n\u0026gt; pytest tests/   특정 테스트 파일 실행\n\u0026gt; pytest test_sample.py   2.4. 테스트 실행시 출력되는 정보  플랫폼 정보: python 버전, pytest 라이브러리 버전 테스트 실행 디렉토리 테스트 파일이름 및 진행률 테스트 실패 파일 및 코드 정보 총 테스트 케이스 개수 및 실행시간 정보   3. 테스트 디렉토리 구조 프로젝트의 효율적인 관리를 위해 소스코드, 테스트 코드 파일을 분리하여 저장한다. 테스트 코드는 보통 tests/ 디렉토리에서 관리한다.\nproject/ src/ __init__.py calculator.py tests/ __init__.py test_calculator.py  python 디렉토리안에 __init__.py 파일이 없을 경우\nModuleNotFoundError 에러가 발생할 수 있다.\n  4. pytest fixtures fixtures 란?\n 테스트 프로세스를 초기화하여 시스템의 모든 전제 조건을 충족하도록 시스템을 설정하는 것  데이터 베이스 등   같은 설정의 테스트를 쉽게 반복적으로 수행할 수 있도록 도와주는 것  pytest fixtures는 python decorator형식으로 사용한다.\nsrc/calculator.py\nclass Calculator():  def add(self, x, y):  return x + y   def sub(self, x, y):  return x - y   def mul(self, x, y):  return x * y   def div(self, x, y):  return x / y tests/test_calculator.py\nimport pytest  from src.calculator import Calculator  def test_add():  calculator = Calculator()  assert calculator.add(1, 2) == 3  assert calculator.add(2, 2) == 4  def test_sub():  calculator = Calculator()  assert calculator.sub(5, 1) == 4  assert calculator.sub(3, 2) == 1  def test_mul():  calculator = Calculator()  assert calculator.mul(2, 2) == 4  assert calculator.mul(5, 6) == 30  def test_div():  calculator = Calculator()  assert calculator.div(8, 2) == 4  assert calculator.div(9, 3) == 3 4.1. @pytest.fixture 테스트코드를 작성하다 보면 클래스 호출 등 테스트에 반복 사용되는 코드가 존재한다. 이러한 코드 중복성을 문제를 해결하기 위한 테스트 함수 실행전 실행되는 함수를 @pytest.fixture 데코레이터로 선언한다.\ntests/test_calculator_fixture_v1.py\nimport pytest  from src.calculator import Calculator  @pytest.fixture def calculator():  calculator = Calculator()  return calculator  def test_add(calculator):  assert calculator.add(1, 2) == 3  assert calculator.add(2, 2) == 4  def test_sub(calculator):  assert calculator.sub(5, 1) == 4  assert calculator.sub(3, 2) == 1 ... 사전에 fixture 함수를 정의하고 test_* 함수의 파라미터로 사용하여 클래스 선언등의 초기화를 진행할 수 있다.\n4.2. conftest.py 여러 test 파일에 공통적으로 fixture 함수가 선언하면 중복된 코드를 작성하게 된다. 이러한 문제는 별도의 conftest.py 파일에 fixture 함수를 선언하여 해결할 수 있다.\ntests/conftest.py\nimport pytest  from src.calculator import Calculator  @pytest.fixture def calculator():  calculator = Calculator()  return calculator tests/test_calculator_fixture_v2.py\ndef test_add(calculator):  assert calculator.add(1, 2) == 3  assert calculator.add(2, 2) == 4  def test_sub(calculator):  assert calculator.sub(5, 1) == 4  assert calculator.sub(3, 2) == 1 ...  5. Parameterize 테스트 케이스마다 테스트값을 포함한 테스트 함수를 호출하는 코드도 중복 작성하는 부분이다. 이를 위한 테스트 입력값과 결과값을 @pytest.mark.parametrize(argnames, argvalues) 데코테이터로 작성하여 테스트 코드를 간결하게 만들 수 있다.\ntests/test_calculator_parametrize.py\nimport pytest  @pytest.mark.parametrize(  \u0026#34;a, b, result\u0026#34;,  [(1, 2, 3),  (2, 2, 4)] ) def test_add(calculator, a, b, result):  assert calculator.add(a, b) == result  @pytest.mark.parametrize(  \u0026#34;a, b, expected\u0026#34;,  [(1, 2, 4),  (2, 2, 6)] ) def test_add_fail(calculator, a, b, expected):  assert calculator.add(a, b) != expected 실행 결과\n\u0026gt; pytest tests\\test_calculator_parametrize.py ======================= test session starts ======================== platform win32 -- Python 3.8.10, pytest-7.0.0, pluggy-1.0.0 rootdir: D:\\workspace_go\\blog\\python\\python-pytest collected 4 items tests\\test_calculator_parametrize.py .... [100%] ======================== 4 passed in 0.03s ========================= 기존 테스트와의 차이점은 테스트 함수안에서 여러개의 테스트를 진행한게 아니라 각각의 테스트 케이스들이 별도로 실행된다.\n 6. xfail @pytest.mark.xfail는 테스트 실패가 예상되는 함수에 지정하는 데코레이터이다. reason 파라미터는 작성자가 실패가 예상되는 이유를 작성하는 부분이다.\ntests/test_calculator_xfail_v1.py\nimport pytest  @pytest.mark.parametrize(  \u0026#34;a, b, expected\u0026#34;,  [(1, 2, 4),  (2, 2, 6)] ) def test_add_fail_parametrize(calculator, a, b, expected):  assert calculator.add(a, b) != expected  @pytest.mark.xfail(reason=\u0026#34;wrong result\u0026#34;) @pytest.mark.parametrize(  \u0026#34;a, b, expected\u0026#34;,  [(1, 2, 4),  (2, 2, 6),  (3, 4, 7)] ) def test_add_fail_xfail(calculator, a, b, expected):  assert calculator.add(a, b) == expected 실행결과\n\u0026gt;pytest tests\\test_calculator_xfail_v1.py ======================= test session starts ======================== platform win32 -- Python 3.8.10, pytest-7.0.0, pluggy-1.0.0 rootdir: D:\\workspace_go\\blog\\python\\python-pytest collected 5 items tests\\test_calculator_xfail_v1.py ..xxX [100%] ============= 2 passed, 2 xfailed, 1 xpassed in 0.07s ==============  passed : 에러없이 테스트케이스 통과한 개수 xfailed : xfail로 지정한 테스트케이스 중 정상적으로 실패한 개수 xpassed : xfail로 지정한 테스트케이스 중 의도하지않은 성공한 개수   7. param pytest.param을 사용하여 테스트 케이스별로 옵션을 지정할 수 있다.\ntests/test_calculator_param_v1.py\nimport pytest  @pytest.mark.parametrize(  \u0026#34;a, b, expected\u0026#34;,  [pytest.param(1, 2, 4, marks=pytest.mark.xfail),  pytest.param(2, 2, 6, marks=pytest.mark.xfail)] ) def test_add_fail_xfail(calculator, a, b, expected):  assert calculator.add(a, b) == expected 7.1. 성공/실패 케이스 통합 위에서 학습한 pytest.param xfail을 사용하면 하나의 테스트 함수에서 성공과 실패 케이스 모두 테스트할 수 있다.\ntests/test_calculator_param_v2.py\nimport pytest  @pytest.mark.parametrize(  \u0026#34;a, b, result\u0026#34;,  [(1, 2, 3),  (2, 2, 4),  pytest.param(1, 2, 4, marks=pytest.mark.xfail),  pytest.param(2, 2, 6, marks=pytest.mark.xfail)] ) def test_add(calculator, a, b, result):  assert calculator.add(a, b) == result 7.2. 테스트 케이스 전역변수 가독성 및 재사용성을 위해 테스트케이스를 별도의 변수로 지정하여 사용할 수 있다.\ntests/test_calculator_param_v3.py\nimport pytest  add_test_data = [  (1, 2, 3),  (2, 2, 4),  pytest.param(1, 2, 4, marks=pytest.mark.xfail),  pytest.param(2, 2, 6, marks=pytest.mark.xfail), ]  @pytest.mark.parametrize(\u0026#34;a, b, result\u0026#34;, add_test_data) def test_add(calculator, a, b, result):  assert calculator.add(a, b) == result  8. 설명문 추가 - id 각 테스트 케이스별로 id를 작성하여 해당 케이스의 의미를 작성할 수 있다.\nimport pytest  add_test_data = [  pytest.param(1, 2, 3, id=\u0026#34;1 add 2 is 3\u0026#34;),  pytest.param(2, 2, 4, id=\u0026#34;2 add 2 is 4\u0026#34;),  pytest.param(1, 2, 4, marks=pytest.mark.xfail, id=\u0026#34;1 add 2 is not 4\u0026#34;),  pytest.param(2, 2, 6, marks=pytest.mark.xfail, id=\u0026#34;2 add 2 is not 6\u0026#34;), ]  @pytest.mark.parametrize(\u0026#34;a, b, result\u0026#34;, add_test_data) def test_add(calculator, a, b, result):  assert calculator.add(a, b) == result 9. skip 테스트 함수를 사용하지 않을 때 @pytest.mark.skip 데코레이터를 사용함으로 테스트를 생략할 수 있다.\n다른 사용법으로 테스트가 조건을 만족할 경우 pytest.skip함수로 skip 처리가 가능하다.\ntests/test_skip.py\nimport pytest  @pytest.mark.skip(reason=\u0026#34;no way of currently testing this\u0026#34;) def test_skip_v1():  assert 1 == 1  def test_skip_v2():  if True:  pytest.skip(reason=\u0026#34;no way of currently testing this\u0026#34;)  assert 1 == 1 실행 결과\n\u0026gt; pytest tests\\test_skip.py ======================= test session starts ======================= platform win32 -- Python 3.8.10, pytest-7.0.0, pluggy-1.0.0 rootdir: D:\\workspace_go\\blog\\python\\python-pytest collected 2 items tests\\test_skip.py ss [100%] ======================= 2 skipped in 0.02s ========================  skipped : 생략된 테스트 개수  9.1. skipif 플랫폼이나 라이브러리 설치 유무, 버전등에 따라서 skip이 필요한 경우가 있다.\n@pytest.mark.skipif(조건문) 데코레이터로 조건에 부합될 경우에만 테스트 함수를 생략할 수 있다.\ntests/test_skipif.py\nimport pytest import sys  @pytest.mark.skipif(sys.version_info \u0026lt; (3, 7), reason=\u0026#34;requires python 3.7 or higher\u0026#34;) def test_skipif_v1():  assert 1 == 1  try:  import numpy as np except ImportError:  pass  @pytest.mark.skipif(\u0026#39;numpy\u0026#39; not in sys.modules, reason=\u0026#34;requires the Numpy library\u0026#34;) def test_skipif_v2():  assert 1 == 1 실행 결과\n test_skipif_v1 함수 : 현재 python 버전이 3.8이므로 생략되지 않고 테스트 실행됨 test_skipif_v2 함수 : numpy 라이브러리 설치가 되지 않아 ImportError가 발생하고 테스트 생략됨  \u0026gt; pytest tests\\test_skipif.py ======================= test session starts ======================= platform win32 -- Python 3.8.10, pytest-7.0.0, pluggy-1.0.0 rootdir: D:\\workspace_go\\blog\\python\\python-pytest collected 2 items tests\\test_skipif.py .s [100%] ================== 1 passed, 1 skipped in 0.02s ===================  10. TestClass 테스트 함수를 클래스로 그룹화 할 수 있다.\nclass TestCalcultor:  value = 0   def test_add(self):  self.value += 1  assert self.value == 1   def test_result(self):  assert self.value == 0 실행 결과\n클래스 내에 각 테스트는 각각의 고유한 클래스 인스턴스를 가지고 있어 self 변수값이 공유되지 않는다.\n\u0026gt; pytest tests\\test_class.py ======================= test session starts ======================= platform win32 -- Python 3.8.10, pytest-7.0.0, pluggy-1.0.0 rootdir: D:\\workspace_go\\blog\\python\\python-pytest collected 2 items tests\\test_class.py .. [100%] ======================== 2 passed in 0.03s ========================  11. 예시코드 Git python-pytest\n 참고(Reference)  pytest docs pytest-xdist docs unittest vs pytest PyCon-KR-2019 - pytest How do I disable a test using pytest?  ","date":"February 8, 2022","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2022-02-08-python-pytest-guide/","summary":"1. 개요 및 설정 pytest는 에러 없는 좋은 코드를 개발만들기 위한 목적으로 개발된 Python 테스트 프레임워크이다.\npytest 특징\n 다른 testing 라이브러리에 비해 사용법이 간단하다. 테스트를 병렬로 실행할 수 있다. 특정 테스트를 스킵할 수 있다. 다양한 서드 파트 라이브러리들이 있다.  설치\npip install -U pytest  2. 기본 사용법 2.1. 기본 테스트 test_sample.py\n# 테스트 대상 기능 def inc(x):  return x + 1  # 테스트 실행 함수 def test_answer1():  assert inc(3) == 5  def test_answer2():  assert inc(3) == 4 pytest 실행 결과","tags":["python","pytest"],"title":"[python] 테스트 프레임워크 pytest 사용법"},{"categories":["Django"],"contents":" django에서 구현가능한 파일 다운로드 방법 예시\n로컬파일 다운로드 - Blob 장점\n 브라우저에서 파일다운로드 완료시점을 알 수 있음 임시로 생성된 파일을 다운받을 경우 완료시점에 따른 파일 삭제가 가능함  단점\n 파일 용량만큼 브라우저 메모리 사용 대용량 파일다운로드에 부적합  from django.http import FileResponse from rest_framework.views import APIView import os  class DownloadView(APIView):  def get(self, request):  ...   file_handle = open(filepath, \u0026#39;rb\u0026#39;)  response = FileResponse(file_handle, content_type=\u0026#39;application/zip\u0026#39;)  response[\u0026#39;Content-Length\u0026#39;] = os.path.getsize(filepath)  response[\u0026#39;Content-Disposition\u0026#39;] = \u0026#39;attachment; filename=\u0026#34;%s\u0026#34;\u0026#39; % os.path.basename(filepath)  return response  로컬파일 다운로드 - URL 장점\n 브라우저 메모리 사용없이 다운로드 가능 대용량 파일 다운로드에 적합  단점\n 브라우저에서 파일다운로드 완료시점을 알 수 없음 임시로 생성된 파일을 다운받을 경우 별도의 삭제 알고리즘 적용이 필요함  from rest_framework.views import APIView  class DownloadView(APIView):  def get(self, request):  ...   file_url = self._get_object(object)   response = Response(status=status.HTTP_200_OK)  response.data = {\u0026#39;download_url\u0026#39;: file_url}  return response 삭제 알고리즘\n DB 테이블에 파일 수정상태 여부 저장하여\n파일 정보가 수정되지 않을 경우 전에 생성된 파일의 URL 반환\n파일 정보가 수정되었을 경우 전에 생성된 파일 삭제하고 새로 생성한 파일의 URL 반환\n ","date":"February 5, 2022","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2022-02-05-django-file-download/","summary":"django에서 구현가능한 파일 다운로드 방법 예시\n로컬파일 다운로드 - Blob 장점\n 브라우저에서 파일다운로드 완료시점을 알 수 있음 임시로 생성된 파일을 다운받을 경우 완료시점에 따른 파일 삭제가 가능함  단점\n 파일 용량만큼 브라우저 메모리 사용 대용량 파일다운로드에 부적합  from django.http import FileResponse from rest_framework.views import APIView import os  class DownloadView(APIView):  def get(self, request):  ...   file_handle = open(filepath, \u0026#39;rb\u0026#39;)  response = FileResponse(file_handle, content_type=\u0026#39;application/zip\u0026#39;)  response[\u0026#39;Content-Length\u0026#39;] = os.","tags":["django"],"title":"Django 파일 다운로드"},{"categories":["Python","boto3","AWS"],"contents":" 1. 개요 및 설정 Boto3는 python 애플리케이션과 AWS 서비스를 연결시키기 위해 사용하는 python 라이브러리이다.\nboto3 라이브러리 설치\npip install boto3 라이브러리 import 및 AWS key 설정\nconf.py\nimport os  AWS_ACCESS_KEY_ID = \u0026#34;ACCESS_KEY_ID\u0026#34; AWS_SECRET_ACCESS_KEY = \u0026#34;SECRET_ACCESS_KEY\u0026#34; AWS_REGION = \u0026#34;REGION\u0026#34; AWS_BUCKET_NAME = \u0026#34;BUCKET_NAME\u0026#34;  2. boto3 기본 사용법 2.1. client client\n Low-level 인터페이스 service description에 의해 만들어짐 botocore 수준제어 (botocore는 AWS CLI와 boto3의 기초가 되는 라이브러리) AWS API와 1:1 매핑 메소드가 스네이크 케이스로 정의되어 있음  import boto3 from conf import *  client = boto3.client(  \u0026#39;s3\u0026#39;,  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  # bucket 목록 response = client.list_buckets() print(f\u0026#34;list_buckets = {response}\u0026#34;)  # bucket 모든 파일 정보 조회 response = client.list_objects(Bucket=AWS_STORAGE_BUCKET_NAME) for content in response[\u0026#39;Contents\u0026#39;]:  obj_dict = client.get_object(Bucket=AWS_STORAGE_BUCKET_NAME, Key=content[\u0026#39;Key\u0026#39;])  print(content[\u0026#39;Key\u0026#39;], obj_dict[\u0026#39;LastModified\u0026#39;]) Response Syntax\n{  \u0026#39;ResponseMetadata\u0026#39;\u0026#34; { \u0026#39;RequestId\u0026#39;: \u0026#39;RequestId\u0026#39;, \u0026#39;HostId\u0026#39;: \u0026#39;HostId\u0026#39;, \u0026#39;HTTPStatusCode\u0026#39;: 200, \u0026#39;HTTPHeaders\u0026#39;: { \u0026#39;x-amz-id-2\u0026#39;: \u0026#39;HostId\u0026#39;, \u0026#39;x-amz-request-id\u0026#39;: \u0026#39;RequestId\u0026#39;, \u0026#39;date\u0026#39;: \u0026#39;Mon, 10 Jan 2022 00:45:42 GMT\u0026#39;, \u0026#39;content-type\u0026#39;: \u0026#39;application/xml\u0026#39;, \u0026#39;transfer-encoding\u0026#39;: \u0026#39;chunked\u0026#39;, \u0026#39;server\u0026#39;: \u0026#39;AmazonS3\u0026#39; }, \u0026#39;RetryAttempts\u0026#39;: 0 } \u0026#39;Buckets\u0026#39;: [ { \u0026#39;Name\u0026#39;: \u0026#39;string\u0026#39;, \u0026#39;CreationDate\u0026#39;: datetime(2022, 1, 10) }, ], \u0026#39;Owner\u0026#39;: { \u0026#39;DisplayName\u0026#39;: \u0026#39;string\u0026#39;, \u0026#39;ID\u0026#39;: \u0026#39;string\u0026#39; } } S3 IAM에 적절한 권한이 없을 경우 아래와 같은 에러가 발생한다.\noperation: Access Denied  2.2. Session과 resource Session\n AWS 설정상태를 저장 client \u0026amp; resource 서비스를 생성하기 위한 권한부여  resource\n high-level, 객체지향적 인터페이스 resource description에 의해 만들어짐 식별자(identifier)와 속성(attribute)을 사용 s3, object 같은 자원에 대한 조작 위주  Bucket\n 특정 S3 bucket 사용  import boto3 from conf import *  session = boto3.Session(  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  # s3에 대한 권한 및 상태를 s3변수에 저장 s3 = session.resource(\u0026#39;s3\u0026#39;)  # bucket 목록조회 for bucket in s3.buckets.all():  print(f\u0026#34;bucket.name = {bucket.name}\u0026#34;)  print(\u0026#34;------------------------------\u0026#34;)  # bucket 모든 파일 이름 및 수정시간 조회 bucket = s3.Bucket(AWS_BUCKET_NAME) for obj in bucket.objects.all():  print(obj.key, obj.last_modified) output\nbucket.name = BUCKET_NAME ------------------------------ media/ 2022-01-10 09:35:38+00:00 media/6514A2A9-8CC9-493C-4009-0F313BA8724A.jpeg 2022-01-10 09:50:48+00:00  2.3. Object Object\n bucket에 저장된 객체(파일)에 접근  ObjectSummary\nObjectAcl\nimport boto3 from conf import *  session = boto3.Session(  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  # s3에 대한 권한 및 상태를 s3변수에 저장 s3 = session.resource(\u0026#39;s3\u0026#39;)  object_key = \u0026#34;media/6514A2A9-8CC9-493C-4009-0F313BA8724A.jpeg\u0026#34;  object_ = s3.Object(AWS_BUCKET_NAME, object_key) print(object_)  print(\u0026#34;------------------------------\u0026#34;)  object_ = s3.ObjectSummary(AWS_BUCKET_NAME, object_key) print(object_) print(f\u0026#34;object_.size = {object_.size}\u0026#34;) print(f\u0026#34;object_.last_modified = {object_.last_modified}\u0026#34;) print(f\u0026#34;object_.Acl() = {object_.Acl()}\u0026#34;)  print(\u0026#34;------------------------------\u0026#34;)  object_acl = s3.ObjectAcl(AWS_BUCKET_NAME, object_key) print(object_acl) print(f\u0026#34;object_acl.owner = {object_acl.owner}\u0026#34;) print(f\u0026#34;object_acl.grants = {object_acl.grants}\u0026#34;) ouput\ns3.Object(bucket_name=\u0026#39;BUCKET_NAME\u0026#39;, key=\u0026#39;media/6514A2A9-8CC9-493C-4009-0F313BA8724A.jpeg\u0026#39;) ------------------------------ s3.ObjectSummary(bucket_name=\u0026#39;BUCKET_NAME\u0026#39;, key=\u0026#39;media/6514A2A9-8CC9-493C-4009-0F313BA8724A.jpeg\u0026#39;) object_.size = 64738 object_.last_modified = 2022-01-10 09:50:48+00:00 object_.Acl() = s3.ObjectAcl(bucket_name=\u0026#39;BUCKET_NAME\u0026#39;, object_key=\u0026#39;media/6514A2A9-8CC9-493C-4009-0F313BA8724A.jpeg\u0026#39;) ------------------------------ s3.ObjectAcl(bucket_name=\u0026#39;BUCKET_NAME\u0026#39;, object_key=\u0026#39;media/6514A2A9-8CC9-493C-4009-0F313BA8724A.jpeg\u0026#39;) object_acl.owner = {\u0026#39;ID\u0026#39;: \u0026#39;owner_id\u0026#39;} object_acl.grants = [{\u0026#39;Grantee\u0026#39;: {\u0026#39;ID\u0026#39;: \u0026#39;owner_id\u0026#39;, \u0026#39;Type\u0026#39;: \u0026#39;CanonicalUser\u0026#39;}, \u0026#39;Permission\u0026#39;: \u0026#39;FULL_CONTROL\u0026#39;}]  2.4. delete 버킷에 저장된 객체 삭제\nObject.delete()\nexample 1\nimport boto3 from conf import *  key_name = \u0026#34;copy_cat.jpg\u0026#34;  session = boto3.Session(  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  s3 = boto3.resource(\u0026#39;s3\u0026#39;) buckets = s3.Bucket(name=AWS_BUCKET_NAME) s3.Object(AWS_BUCKET_NAME, key_name).delete() example 2\nimport boto3 from conf import *  key_name = \u0026#34;copy_cat.jpg\u0026#34;  client = boto3.client(  \u0026#39;s3\u0026#39;,  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  client.delete_object(Bucket=AWS_BUCKET_NAME, Key=key_name) output\naws configure 설정되지 않을 경우 error가 발생한다.\nbotocore.exceptions.NoCredentialsError: Unable to locate credentials 2.5. aws configure 로컬 설정 방법1 awscli 라이브러리 설치\npip install awscli \u0026lsquo;aws configure\u0026rsquo; 명령어를 이용하여 계정정보 등록\nAWS Access Key ID [None]: Access Key ID AWS Secret Access Key [None]: Secret Access Key Default region name [None]: region name Default output format [None]: 방법2 awscli를 설치하지 않고 별도로 credentials를 지정할 수 있다.\nAWS 에서 해당 credentials을 ~/.aws/ 디렉토리에 저장한다.\ncredentials\n[default] aws_access_key_id = Access Key ID aws_secret_access_key = Secret Access Key config\noutput 설정은 지정하지 않아도 된다.\n[default] region = region name output = json aws configure 설정 후 다시 delete 테스트하면 실행된다.\n 3. 업로드 및 다운로드 3.1. upload_file upload_file\n 버킷에 파일 업로드 S3Transfer의 upload_file() 메서드와 비슷하게 동작  docs example\nimport boto3 s3 = boto3.resource(\u0026#39;s3\u0026#39;) s3.meta.client.upload_file(\u0026#39;/tmp/hello.txt\u0026#39;, \u0026#39;mybucket\u0026#39;, \u0026#39;hello.txt\u0026#39;) example\nimport boto3 from conf import *  session = boto3.Session(  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  # s3에 대한 권한 및 상태를 s3변수에 저장 s3 = session.resource(\u0026#39;s3\u0026#39;) buckets = s3.Bucket(name=AWS_BUCKET_NAME)  file_name = \u0026#39;cat.jpg\u0026#39; file_path = os.path.join(IMAGE_DIR, file_name) key_name = \u0026#34;copy_cat.jpg\u0026#34;  # 방법1 # upload_file(local_filepath, bucket_filepath) if os.path.exists(file_path):  buckets.upload_file(file_path, key_name)  # 방법2 # with open(file_path, \u0026#39;rb\u0026#39;) as data: # buckets.upload_file(data.name, key_name)  3.2. download_file download_file\n 버킷에 저장된 파일 다운로드  docs example\nimport boto3 s3 = boto3.resource(\u0026#39;s3\u0026#39;) s3.meta.client.download_file(\u0026#39;mybucket\u0026#39;, \u0026#39;hello.txt\u0026#39;, \u0026#39;/tmp/hello.txt\u0026#39;) example\nimport boto3 from conf import *  session = boto3.Session(  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  # s3에 대한 권한 및 상태를 s3변수에 저장 s3 = session.resource(\u0026#39;s3\u0026#39;)  buckets = s3.Bucket(name=AWS_BUCKET_NAME)  file_name = \u0026#39;cat2.jpg\u0026#39; file_path = os.path.join(IMAGE_DIR, file_name) key_name = \u0026#34;copy_cat.jpg\u0026#34;  # buckets.download_file(bucket_filepath, local_filepath) buckets.download_file(key_name, file_path)  3.3. generate_presigned_url generate_presigned_url\n 다운로드 할 수 있는 URL 생성  IAM 설정은 AmazonS3FullAccess 설정이 되있다는 가정하에 진행한다.\nIAM : AWS 리소스에 대한 접근권한 제어할 수 있는 웹 서비스\n익명 접근가능한 버킷 정책\n설정 경로 (AWS - S3 - AWS_BUCKET_NAME - 버킷 정책)\n{  \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,  \u0026#34;Statement\u0026#34;: [  {  \u0026#34;Sid\u0026#34;: \u0026#34;PublicRead\u0026#34;,  \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,  \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;,  \u0026#34;Action\u0026#34;: [  \u0026#34;s3:GetObject\u0026#34;,  \u0026#34;s3:GetObjectVersion\u0026#34;  ],  \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::AWS_BUCKET_NAME/*\u0026#34;  }  ] } example\nimport boto3 from conf import *  s3_client = boto3.client(  \u0026#39;s3\u0026#39;,  aws_access_key_id=AWS_ACCESS_KEY_ID,  aws_secret_access_key=AWS_SECRET_ACCESS_KEY,  region_name=AWS_REGION )  key_name = \u0026#34;copy_cat.jpg\u0026#34;  url = s3_client.generate_presigned_url(  ClientMethod=\u0026#39;get_object\u0026#39;,  Params={  \u0026#39;Bucket\u0026#39;: AWS_BUCKET_NAME,  \u0026#39;Key\u0026#39;: key_name,  },  # url 유효기간 (단위:second)  ExpiresIn=10 )  print(url)  4. 예시코드 Git python-boto3-aws-s3\n 참고(Reference)  Boto3 기본 설정 및 사용법 Boto3 파일 업로드 \u0026amp; 다운로드- upload and download [AWS] 파이썬 - ec2 연동 에러 (botocore.exceptions.NoCredentialsError: Unable to locate credentials)  ","date":"January 10, 2022","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2022-01-10-python-boto3-aws-s3-guide/","summary":"1. 개요 및 설정 Boto3는 python 애플리케이션과 AWS 서비스를 연결시키기 위해 사용하는 python 라이브러리이다.\nboto3 라이브러리 설치\npip install boto3 라이브러리 import 및 AWS key 설정\nconf.py\nimport os  AWS_ACCESS_KEY_ID = \u0026#34;ACCESS_KEY_ID\u0026#34; AWS_SECRET_ACCESS_KEY = \u0026#34;SECRET_ACCESS_KEY\u0026#34; AWS_REGION = \u0026#34;REGION\u0026#34; AWS_BUCKET_NAME = \u0026#34;BUCKET_NAME\u0026#34;  2. boto3 기본 사용법 2.1. client client\n Low-level 인터페이스 service description에 의해 만들어짐 botocore 수준제어 (botocore는 AWS CLI와 boto3의 기초가 되는 라이브러리) AWS API와 1:1 매핑 메소드가 스네이크 케이스로 정의되어 있음  import boto3 from conf import *  client = boto3.","tags":["python","boto3","aws"],"title":"python boto3라이브러리 이용한 AWS s3 사용법"},{"categories":["Django","oauth","facebook"],"contents":"django restframework 기반의 페이스북(facebook) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n페이스북 개발자 사이트에서 사용하는 환경변수들이 등록되어있다는 가정하에 진행한다.\n페이스북의 경우 다른 소셜로그인과는 용어나 흐름이 달라 추가로 설명하고 시작한다.\n 1. 페이스북 auth 용어 및 각 페이지 설명 1.1. Graph API 용어 Graph API는 Facebook 플랫폼에서 데이터를 요청 및 응답받는 기본적인 수단이다. 프로그래밍 방식으로 데이터 쿼리, 새 스토리 게시, 광고 관리, 사진 업로드를 비롯한 다양한 작업을 수행할 수 있는 HTTP 기반 API이다.\nGraph API는 노드, 에지 및 필드로 구성된다.\n 노드 : 특정 개체에 대한 데이터 조회 에지 : 단일 개체에서 개체 컬렉션 조회 필드 : 컬렉션의 단일 개체 또는 각 개체에 대한 데이터 조회  1.1.1. HTTP 모든 데이터 전송은 HTTP/1.1을 따르며 모든 엔드포인트에는 HTTPS가 필요하다.\nGraph API는 HTTP 기반이므로 cURL, urllib 등 HTTP 라이브러리가 있는 모든 언어에서 사용할 수 있다. 즉 브라우저에서 직접 Graph API를 사용할 수 있다.\n1.1.2. 호스트 URL 거의 모든 요청이 graph.facebook.com 호스트 URL에 전달된다.\n한 가지 예외는 graph-video.facebook.com을 사용하는 동영상 업로드이다.\n1.1.3. 노드 노드는 고유 ID를 갖는 개별 개체이다.\n각각 Facebook의 사용자를 나타내는 고유한 ID를 갖는 수많은 사용자 노드 개체가 있고, 페이지, 그룹, 게시물, 사진 및 댓글은 Facebook 소셜 Graph에서 사용하는 노드의 일부이다.\n사용자 노드에 대한 호출\ncurl -i -X GET \\  \u0026#34;https://graph.facebook.com/USER-ID?access_token=ACCESS-TOKEN\u0026#34; {  \u0026#34;name\u0026#34;: \u0026#34;Your Name\u0026#34;,  \u0026#34;id\u0026#34;: \u0026#34;YOUR-USER-ID\u0026#34; } 1.1.4. /me /me 노드는 현재 API 호출을 보내는 데 사용하는 액세스 토큰을 보유한 사용자나 페이지의 개체 ID로 변환하는 특수한 엔드포인트이다. 사용자 액세스 토큰이 있으면 다음을 사용하여 사용자 이름과 ID를 가져올 수 있다.\ncurl -i -X GET \\  \u0026#34;https://graph.facebook.com/me?access_token=ACCESS-TOKEN\u0026#34; 1.1.5. 필드 필드는 노드 속성이다. 노드나 에지를 쿼리하면 기본적으로 필드 세트가 반환된다. 하지만 fields 매개변수에 각 필드를 나열하여 반환할 필드를 지정하면 지정한 필드와 (항상 반환되는)개체의 ID만 반환된다.\ncurl -i -X GET \\  \u0026#34;https://graph.facebook.com/USER-ID?fields=id,name,email\u0026amp;access_token=ACCESS-TOKEN\u0026#34; {  \u0026#34;id\u0026#34;: \u0026#34;USER-ID\u0026#34;,  \u0026#34;name\u0026#34;: \u0026#34;EXAMPLE NAME\u0026#34;,  \u0026#34;email\u0026#34;: \u0026#34;EXAMPLE@EMAIL.COM\u0026#34; } 1.1.6. 버전 Graph API는 분기별로 릴리스되어 여러 버전이 있다. 예를 들어 버전 12.0을 호출하는 방법은 다음과 같다.\n버전 명시 없이 호출할 경우 가장 오래된 버전으로 호출된다.\ncurl -i -X GET \\  \u0026#34;https://graph.facebook.com/v12.0/USER-ID/photos ?access_token=ACCESS-TOKEN\u0026#34; 1.1.7. Graph 테스트 URL Graph Explorer\n 1.2. 로그인 직접 빌드하기 1.2.1. 로그인 대화 상자 호출 및 리디렉션 URL 설정 https://www.facebook.com/v12.0/dialog/oauth? client_id={app-id} \u0026amp;redirect_uri={redirect-uri} \u0026amp;state={state-param} 필수 매개변수\n client_id : 앱 대시보드에서 볼수 있는 앱 ID redirect_uri : 사용자가 다시 로그인하도록 리디렉션할 URL state : 요청과 콜백 사이의 상태를 유지하기 위해 앱에서 생성한 문자열 값, 사이트 간 요청 위조를 방지하는 데 사용  선택적 매개변수\n response_type : 앱으로 다시 리디렉션할 때 포함된 응답 데이터가 URL 매개변수인지 프래그먼트인지 결정  code : 응답 데이터는 URL 매개변수로 포함되어 있으며, code 매개변수(각 로그인 요청에 고유한 암호화된 문자열)를 포함  response query_string 값을 callbackurl/?code= 형식으로 받는다.   token : 응답 데이터는 URL 프래그먼트로 포함되어 있으며, 액세스 토큰을 포함  response query_string 값을 callbackurl/?#access_token= 형식으로 받는다.   code%20token : 응답 데이터는 URL 프래그먼트로 포함되어 있으며, 액세스 토큰과 code 매개변수를 모두 포함  response query_string 값을 callbackurl/?#access_token=\u0026amp;code= 형식으로 받는다.   granted_scopes : 사용자가 로그인 시점에 앱에 부여한 모든 권한의 쉼표로 구분한 리스트를 반환   scope : 앱 사용자에게 요청할 권한의 쉼표 또는 공백으로 구분한 리스트  예시코드에서는 response_type=code 형식을 사용한다.\n1.2.2. ID 확인  code : 수신하면 엔드포인트를 사용하여 액세스 토큰과 교환해야 한다. 호출에는 앱 시크릿 코드가 포함되므로 서버 간 호출이어야 한다. token : 수신한 후 인증해야 한다. 토큰을 생성할 대상 사용자와 대상 앱을 표시하도록 검사 엔드포인트로 API 호출을 보내야 한다. code와 token을 모두 수신했을 때는 두 단계를 모두 실행해야 한다.  1.2.3. 액세스 토큰 발급 액세스 토큰은 앱에서 Graph API 호출에 사용된다.\n  요청\nGET https://graph.facebook.com/v12.0/oauth/access_token? client_id={app-id} \u0026amp;redirect_uri={redirect-uri} \u0026amp;client_secret={app-secret} \u0026amp;code={code-parameter} 필수 매개변수\n client_id : 앱 ID redirect_uri : OAuth 로그인 절차를 시작할 때 사용하는 원본 request_uri와 동일해야 한다. client_secret : 고유한 앱 시크릿 코드이며, 앱 대시보드에 표시된다. code : 위의 로그인 대화 상자 리디렉션에서 수신한 매개변수.    응답\n{  \u0026#34;access_token\u0026#34;: \u0026#34;{access-token}\u0026#34;,  \u0026#34;token_type\u0026#34;: \u0026#34;{type}\u0026#34;,  \u0026#34;expires_in\u0026#34;: \u0026#34;{seconds-til-expiration}\u0026#34; }   1.2.4. 앱 액세스 토큰 발급 서버에서 Facebook API 요청할 떄 사용한다.\n\u0026#34;https://graph.facebook.com/oauth/access_token ?client_id={your-app-id} \u0026amp;client_secret={your-app-secret} \u0026amp;grant_type=client_credentials\u0026#34; 다른 방법으로 앱 액세스 토큰을 사용하지 않아도 되는 다른 방법으로 그래프 API를 호출할 수 있다.\n호출할 때 앱 ID와 앱 시크릿 코드만 access_token 매개변수로 전달할 수 있다.\n\u0026#34;https://graph.facebook.com/{api-endpoint}\u0026amp;access_token={your-app_id}|{your-app_secret}\u0026#34; 1.2.5. 액세스 토큰 검사 response_type 유형으로 사용하는지 여부와 관계없이 액세스 토큰을 처리해야 한다.\n요청\nGET graph.facebook.com/debug_token? input_token={token-to-inspect} \u0026amp;access_token={app-token-or-admin-token} 매개변수\n input_token : 검사해야 할 토큰 access_token : 앱 개발자의 액세스 토큰 또는 앱 액세스 토큰  응답\n{  \u0026#34;data\u0026#34;: {  \u0026#34;app_id\u0026#34;: 138483919580948,  \u0026#34;type\u0026#34;: \u0026#34;USER\u0026#34;,  \u0026#34;application\u0026#34;: \u0026#34;Social Cafe\u0026#34;,  \u0026#34;expires_at\u0026#34;: 1352419328,  \u0026#34;is_valid\u0026#34;: true,  \u0026#34;issued_at\u0026#34;: 1347235328,  \u0026#34;metadata\u0026#34;: {  \u0026#34;sso\u0026#34;: \u0026#34;iphone-safari\u0026#34;  },  \u0026#34;scopes\u0026#34;: [  \u0026#34;email\u0026#34;,  \u0026#34;publish_actions\u0026#34;  ],  \u0026#34;user_id\u0026#34;: \u0026#34;1207059\u0026#34;  } } 서버에서 app_id 값 비교를 통해 유효한 액세스 토큰인지 확인할 수 있다.\n 2. Facebook 로그인 변수 설정 import os  FACEBOOK_CONFIG = {  \u0026#34;FACEBOOK_APP_ID\u0026#34;: APP_ID,  \u0026#34;FACEBOOK_REDIRECT_URI\u0026#34;: REDIRECT_URI,  \u0026#34;FACEBOOK_APP_SECRET_CODE\u0026#34;: APP_SECRET_CODE  \u0026#34;STATE\u0026#34; : 임의의 랜덤코드, }  facebook_graph_url = \u0026#34;https://graph.facebook.com/v12.0\u0026#34; facebook_login_url = \u0026#34;https://www.facebook.com/v12.0/dialog/oauth\u0026#34; facebook_token_url = f\u0026#34;{facebook_graph_url}/oauth/access_token\u0026#34; facebook_debug_token_url = \u0026#34;https://graph.facebook.com/debug_token\u0026#34; facebook_profile_url = f\u0026#34;{facebook_graph_url}/me\u0026#34; # 사용자 정보 요청  FACEBOOK_REDIRECT_URI: https://localhost 리디렉션은 개발 모드에 있는 동안만 기본으로 허용된다.  2.1. Facebook Developers 계정 등록   페이스북 개발자 사이트에서 페이스북 로그인후 개발자 계정에 가입한다.   이메일 인증받을 주소를 입력한다. (기본값 페이스북에 등록된 이메일)   관심사를 선택한다.   2.2. APP 생성   앱을 생성한다.   페이스북 소셜 로그인 연동을 위해 생성할 앱으로 소비자 유형을 선택한다.   표시이름: 사용자가 앱에 로그인할 표시될 앱이름을 설정한다.   2.3. 앱 로그인 설정   앱 대시보드에서 APP ID를 확인할 수 있다.\n  앱에 Facebook 로그인 설정한다.   로그인할 플랫폼 유형 웹을 선택한다.   리다이렉트 URI를 사용하는 사이트 주소를 입력한다.   Facebook 로그인 → 설정 → 유효한 OAuth 리디렉션 URI를 입력한다.\n   리디렉션 URI: 페이스북 로그인 정보를 전송받을 URI URI 리디렉션 유효성 검사기: 실제 웹서버와 통신이 되는지 검증한다.    public_profile 권한 설정에관한 경고문이 나올경우 Get Advanced Access 메뉴로 간다.   public_profile 권한에서 고급 엑세스 이용하기로 이동한다.   고급 엑세스에 대한 개인정보 이용에 동의를 한다.    3. Facebook 로그인 페이지 사용자가 로그인 테스트 서버로 접속시 redirect URI를 반환한다.\nclass FacebookLoginView(APIView):  permission_classes = (AllowAny,)   def get(self, reqeust):  \u0026#39;\u0026#39;\u0026#39; facebook code 요청 \u0026#39;\u0026#39;\u0026#39;  client_id = FACEBOOK_CONFIG[\u0026#39;FACEBOOK_APP_ID\u0026#39;]  redirect_uri = FACEBOOK_CONFIG[\u0026#39;FACEBOOK_REDIRECT_URI\u0026#39;]  state = FACEBOOK_CONFIG[\u0026#39;STATE\u0026#39;]   uri = f\u0026#34;{facebook_login_url}?client_id={client_id}\u0026amp;redirect_uri={redirect_uri}\u0026amp;state={state}\u0026amp;response_type=code\u0026amp;scope=email%20public_profile\u0026#34;   res = redirect(uri)  return res uri 파라미터 설명\n  필수 매개변수\n client_id : 앱 대시보드에서 볼수 있는 앱 ID redirect_uri : 페이스북 로그인 정보를 전송받을 URI state : 요청과 콜백 사이의 상태를 유지하기 위해 앱에서 생성한 문자열 값, 사이트 간 요청 위조를 방지하는 데 사용    선택적 매개변수\n response_type : 앱으로 다시 리디렉션할 때 포함된 응답 데이터가 URL 매개변수인지 프래그먼트인지 결정  code : 응답 데이터는 URL 매개변수로 포함되어 있으며, code 매개변수(각 로그인 요청에 고유한 암호화된 문자열)를 포함   scope : 앱 사용자에게 요청할 권한의 쉼표 또는 공백으로 구분한 리스트     4. Facebook Callback 함수 사용자가 oauth 로그인시 code 검증 및 로그인 처리한다.\nclass FacebookCallbackView(APIView):  permission_classes = (AllowAny,)   @swagger_auto_schema(query_serializer=CallbackUserInfoSerializer)  def get(self, request):  \u0026#39;\u0026#39;\u0026#39; facebook access_token 요청 및 user_info 요청 \u0026#39;\u0026#39;\u0026#39;  data = request.query_params.copy()   code = data.get(\u0026#39;code\u0026#39;)  if not code:  return Response(status=status.HTTP_400_BAD_REQUEST)   query_string = {  \u0026#39;client_id\u0026#39;: FACEBOOK_CONFIG[\u0026#39;FACEBOOK_APP_ID\u0026#39;],  \u0026#39;redirect_uri\u0026#39;: FACEBOOK_CONFIG[\u0026#39;FACEBOOK_REDIRECT_URI\u0026#39;],  \u0026#39;client_secret\u0026#39;: FACEBOOK_CONFIG[\u0026#39;FACEBOOK_APP_SECRET\u0026#39;],  \u0026#39;code\u0026#39;: code,  }  token_res = requests.get(facebook_token_url, params=query_string)   token_json = token_res.json()  access_token = token_json.get(\u0026#39;access_token\u0026#39;)   if not access_token:  return Response(status=status.HTTP_400_BAD_REQUEST)   # 엑세스 토큰 검사 및 계정 정보 조회  query_string = {  \u0026#39;input_token\u0026#39;: access_token,  \u0026#39;access_token\u0026#39;: f\u0026#34;{FACEBOOK_CONFIG[\u0026#39;FACEBOOK_APP_ID\u0026#39;]}|{FACEBOOK_CONFIG[\u0026#39;FACEBOOK_APP_SECRET\u0026#39;]}\u0026#34;,  }  user_info_res = requests.get(facebook_debug_token_url, params=query_string)  user_info_json = user_info_res.json()   facebook_account = user_info_json.get(\u0026#39;data\u0026#39;)  if (not facebook_account) or (not facebook_account.get(\u0026#39;is_valid\u0026#39;)):  return Response(status=status.HTTP_400_BAD_REQUEST)   user_id = facebook_account.get(\u0026#39;user_id\u0026#39;)   query_string = {  \u0026#39;fields\u0026#39;: \u0026#39;email\u0026#39;, # email,name 형식으로 사용가능  \u0026#39;access_token\u0026#39;: access_token,  }  user_profile_res = requests.get(facebook_profile_url, params=query_string)  user_profile_json = user_profile_res.json()   social_type = \u0026#39;facebook\u0026#39;  social_id = f\u0026#34;{social_type}_{user_id}\u0026#34;  user_email = user_profile_json.get(\u0026#39;email\u0026#39;)   \u0026#39;\u0026#39;\u0026#39; # 회원가입 및 로그인 처리 알고리즘 추가필요 \u0026#39;\u0026#39;\u0026#39;   # 테스트 값 확인용  res = {  \u0026#39;social_type\u0026#39;: social_type,  \u0026#39;social_id\u0026#39;: social_id,  \u0026#39;user_email\u0026#39;: user_email,  }  response = Response(status=status.HTTP_200_OK)  response.data = res  return res  5. 데이터 삭제 요청 콜백 사용자 데이터에 액세스하는 앱은 사용자가 데이터 삭제를 요청할 방법을 제공해야 한다.\n데이터 삭제 콜백은 앱 사용자가 앱을 삭제하고 데이터 삭제를 요청할 때마다 호출된다.\n5.1. 콜백 구현 앱의 앱 대시보드에 있는 Facebook 로그인 \u0026gt; 설정 페이지의 데이터 삭제 요청 URL 필드에 등록되어야 한다.\nURL이 포함된 JSON 응답이 반환되며, 이 URL을 통해 사용자가 삭제 요청의 상태와 영숫자 인증 코드를 확인할 수 있다.\n{  \u0026#34;url\u0026#34;: \u0026#34;\u0026lt;url\u0026gt;\u0026#34;,  \u0026#34;confirmation_code\u0026#34;: \u0026#34;\u0026lt;code\u0026gt;\u0026#34; }  6. 로그인 웹서버에서 설정한 apple oauth 로그인 페이지로 접근하면 사전에 설정한 애플 리다이렉트 URI로 접근하는데 설정에 문제가 없다면 로그인 페이지로 접속된다.\n 참고(Reference)  로그인 플로 직접 빌드 액세스 토큰   Graph API 개요 Graph API 시작하기 Graph API User 데이터 삭제 요청 콜백 웹용 Facebook 로그인의 권한 관리  ","date":"January 7, 2022","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-12-29-django-oauth-facebook/","summary":"django restframework 기반의 페이스북(facebook) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n페이스북 개발자 사이트에서 사용하는 환경변수들이 등록되어있다는 가정하에 진행한다.\n페이스북의 경우 다른 소셜로그인과는 용어나 흐름이 달라 추가로 설명하고 시작한다.\n 1. 페이스북 auth 용어 및 각 페이지 설명 1.1. Graph API 용어 Graph API는 Facebook 플랫폼에서 데이터를 요청 및 응답받는 기본적인 수단이다. 프로그래밍 방식으로 데이터 쿼리, 새 스토리 게시, 광고 관리, 사진 업로드를 비롯한 다양한 작업을 수행할 수 있는 HTTP 기반 API이다.","tags":["django","oauth","facebook"],"title":"Django 소셜로그인(oauth) facebook 연동"},{"categories":["Go","logging"],"contents":" 1. 개요 golang 기본 로깅에서는 지원하지 않는 TimeRotate 로깅은 별도의 외부 라이브러리를 사용한다.\ngo get github.com/lestrrat-go/file-rotatelogs 이후에 소켓 통신을 같이 사용한 logging 프로그램까지 구현한다.\n 2. TimeRotateFile logging 해당 file-rotatelogs 라이브러리는 단일 파일 작성만 지원한다. 멀티 파일 작성은 다른 라이브러리를 사용해야 한다.\n2.1. OPTIONS  Patterm   로그저장 경로 및 파일이름 패턴지정(required) 예시: rotatelogs.New(\u0026quot;log/%Y-%m-%d.log\u0026quot;)  Clock (default: rotatelogs.Local)   시간대 시스템 로컬 시간으로 설정 예시: rotatelogs.WithClock(rotatelogs.Local)  RotationTime (default: 86400 sec)   로테이션 반복 주기 지정한 시간간격으로 파일 로테이션 동일파일 존재시 로그 추가작성으로 동작 time.Duration 타입 사용 예시: rotatelogs.WithRotationTime(time.Hour)  MaxAge (default: 7 days)   지정한 기간을 지난 파일 삭제 -1 : 옵션 비활성화 예시: rotatelogs.WithMaxAge(-1)  RotationCount (default: -1)   유지되는 로그파일 개수 지정한 개수보다 많아지면 오래된 로그파일 삭제 -1 : 옵션 비활성화 예시: rotatelogs.WithRotationCount(90)  2.2. 예시코드 SetFlags 옵션은 golang 기본 log 출력형식 옵션이다.\n log.Ldate: 날짜 지정 (2022/01/07) log.Ltime: 시간 지정 (16:16:45) log.Lmicroseconds: 마이크로초 지정 (573193)  SetFlags(0) 옵션은 기본 출력 형식 없이 로그메시지만 출력할 때 사용한다.\n 외부로부터 로그를 전송받아 작성하는 경우 시간 값도 전송받기 때문에 메시지만 작성한다.  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;time\u0026#34;  \trotatelogs \u0026#34;github.com/lestrrat-go/file-rotatelogs\u0026#34; )  // 로그 설정 func setLog() { \trl, _ := rotatelogs.New( \t\u0026#34;log/%Y-%m-%d.log\u0026#34;, \trotatelogs.WithMaxAge(-1), \trotatelogs.WithRotationTime(time.Hour), \trotatelogs.WithClock(rotatelogs.Local), \trotatelogs.WithRotationCount(90), \t) \tlog.SetFlags(log.Ldate | log.Ltime | log.Lmicroseconds) \tlog.SetOutput(rl) }  func main() { \tsetLog()   log.Println(\u0026#34;로그 테스트\u0026#34;) } 로그 출력 예시\n2022/01/07 16:16:45.573193 로그 테스트  3. socket logging 3.1. Server 내장 라이브러리만 사용한 TCP소켓서버로 byte array 형태로 수신받는다.\nlog 설정은 TimeRotateFile logging 예시를 사용한다.\n수신받은 데이터를 문자열 형태로 저장하는 예시이다.\nfunc loggingServer() { \tlisten, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8010\u0026#34;) \tif err != nil { \tlog.Println(err) \t} \tdefer listen.Close()  \tlog.Println(\u0026#34;Logging Server Start Port :\u0026#34;, 8010)  \tfor { \tconn, err := listen.Accept() \tif err != nil { \tlog.Println(err) \tcontinue \t} \tdefer conn.Close() \tgo ConnHandler(conn) \t} }  func ConnHandler(conn net.Conn) { \trecvBuffer := make([]byte, 4096) \tfor { \tn, err := conn.Read(recvBuffer) \tif err != nil { \tif err != io.EOF { \tlog.Println(err) \t} \treturn \t}  \tif 0 \u0026lt; n { \tdata := recvBuffer[:n] \tlog.Println(string(data)) \t} \t} }  func main() { \tsetLog() \tloggingServer() } 3.2. Client 1초마다 메시지를 전송하는 예시용 프로그램이다.\nimport ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;net\u0026#34; \t\u0026#34;strconv\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \tconn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;:8010\u0026#34;) \tif nil != err { \tfmt.Println(err) \t}  \tcnt := 1 \tfor { \tmsg := \u0026#34;hello world \u0026#34; + strconv.Itoa(cnt) \tconn.Write([]byte(msg)) \tfmt.Println(msg) \ttime.Sleep(time.Duration(1) * time.Second) \tcnt += 1 \t} } log 출력\n2022/01/07 17:24:27.901790 Logging Server Start Port : 8010 2022/01/07 17:24:39.485043 hello world 1 2022/01/07 17:24:40.487938 hello world 2 3.3. Json Log Format json형태 로그를 수신받을 경우 구조체로 변환하여 특정 형식으로 작성하도록 활용할 수 있다.\n... type LogData struct { \tActionTime string \tLevel string \tMessage string }  ... func setLog() { \t... \tlog.SetFlags(0) \t... }  ...  data := recvBuf[:n] dataStr := strings.ReplaceAll(string(data), \u0026#34;}{\u0026#34;, \u0026#34;}\\n{\u0026#34;) objects := strings.Split(dataStr, \u0026#34;\\n\u0026#34;) for _, object := range objects { \tlogData := LogData{} \tjson.Unmarshal([]byte(object), \u0026amp;logData) \tlog.Printf(\u0026#34;%s [%8s] %s\\n\u0026#34;, logData.ActionTime, logData.Level, logData.Message) } ... client → Server 전송데이터 예시\n{ \t\u0026#34;ActionTime\u0026#34;: \u0026#34;2022-01-07 17:58:23,999\u0026#34;, \t\u0026#34;Level\u0026#34;: \u0026#34;INFO\u0026#34;, \t\u0026#34;Message\u0026#34;: \u0026#34;info 테스트\u0026#34; } log 출력\n2022-01-07 17:58:23,999 [INFO ] info 테스트 2022-01-07 17:58:24,000 [WARNING ] warning 테스트 2022-01-07 17:58:24,000 [ERROR ] error 테스트  4. 예시코드 Git  golang-socket-logging   참고(Reference)  file-rotatelogs docs Go socket  ","date":"January 7, 2022","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2022-01-07-golang-socket-logging/","summary":"1. 개요 golang 기본 로깅에서는 지원하지 않는 TimeRotate 로깅은 별도의 외부 라이브러리를 사용한다.\ngo get github.com/lestrrat-go/file-rotatelogs 이후에 소켓 통신을 같이 사용한 logging 프로그램까지 구현한다.\n 2. TimeRotateFile logging 해당 file-rotatelogs 라이브러리는 단일 파일 작성만 지원한다. 멀티 파일 작성은 다른 라이브러리를 사용해야 한다.\n2.1. OPTIONS  Patterm   로그저장 경로 및 파일이름 패턴지정(required) 예시: rotatelogs.New(\u0026quot;log/%Y-%m-%d.log\u0026quot;)  Clock (default: rotatelogs.Local)   시간대 시스템 로컬 시간으로 설정 예시: rotatelogs.WithClock(rotatelogs.Local)  RotationTime (default: 86400 sec)   로테이션 반복 주기 지정한 시간간격으로 파일 로테이션 동일파일 존재시 로그 추가작성으로 동작 time.","tags":["go","logging"],"title":"golang Socket, TimeRotateFile logging"},{"categories":["Django","oauth","apple"],"contents":"django restframework 기반의 애플(apple) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n애플 개발자 사이트에서 사용하는 환경변수들이 등록되어있다는 가정하에 진행한다.\n 1. 라이브러리 설치 $ pip install django  # restframework $ pip install djangorestframework $ pip install djangorestframework-simplejwt  # pyjwt[crypto] $ pip install pyjwt[crypto]  2. Apple 로그인 변수 설정 import os  APPLE_CONFIG = {  \u0026#34;APPLE_TEAM_ID\u0026#34;: TEAM_ID,  \u0026#34;APPLE_CLIENT_ID\u0026#34;: 모바일 로그인시 Bundle ID or 웹 로그인시 Service ID,  \u0026#34;APPLE_REDIRECT_URI\u0026#34;: \u0026#34;https://domain/REDIRECT_URI\u0026#34;,  \u0026#34;APPLE_KEY_ID\u0026#34;: KEY_ID,  \u0026#34;APPLE_KEY_PATH\u0026#34;: \u0026#34;./AuthKey_KEY_ID.p8\u0026#34;,  \u0026#34;APPLE_PRIVATE_KEY\u0026#34;: \u0026#34;\u0026#34;, }  apple_key_path = os.path.join(CONFIG_BASE_DIR, f\u0026#34;./{APPLE_CONFIG[\u0026#39;APPLE_KEY_PATH\u0026#39;]}\u0026#34;) with open(apple_key_path, \u0026#39;r\u0026#39;) as apple_key_file:  APPLE_CONFIG[\u0026#39;APPLE_PRIVATE_KEY\u0026#39;] = apple_key_file.read()  apple_base_url = \u0026#34;https://appleid.apple.com\u0026#34; apple_auth_url = f\u0026#34;{apple_base_url}/auth/authorize\u0026#34; apple_token_url = f\u0026#34;{apple_base_url}/auth/token\u0026#34;  APPLE_REDIRECT_URI: https 프로토콜을 사용하는 도메인 주소만 사용가능하다.(localhost 또는 IP주소는 사용할 수 없다.) apple_auth_url: 로그인 페이지 주소 apple_token_url: ID 토큰 발급받기 위한 주소  2.1. APP ID구성 및 편집 APP ID구성 및 편집\n2.1.1. Certificates, Identifiers \u0026amp; Profiles  Description: 사용자가 로그인시 보여줄 사이트 이름등을 작성한다. App Id Prefix: 애플 로그인시 필요한 Team ID Bundle ID: 모바일 애플 로그인시 필요한 값이다.  2.1.2. Server To Server Notification Endpoint  Notification Endpoint: 사용자가 애플의 정보를 업데이트 할때 서버에서 수신받을 path 설정이다.  2.1.3. Edit your Services ID Configuration  Description: 사용자가 로그인시 보여줄 사이트 이름등을 작성한다. Identifier: 웹 로그인 애플 로그인시 필요한 값이다.  2.1.4. View Key Details  Key ID: 애플로그인시 사용할 개인키 값이다.  우측 상단에서 AuthKey_개인키.p8 key 파일을 다운받을 수 있으며 해당 키값을 별도의 설정파일에 넣거나 혹은 불러오는 식으로 사용하면 된다. 현재 위의 예시 코드는 개인키 파일을 불러오는 방법을 사용하였다.     3. Apple 로그인 페이지 사용자가 로그인 테스트 서버로 접속시 redirect URI를 반환한다.\nclass AppleLoginView(APIView):  permission_classes = (AllowAny,)  authentication_classes = ()   def get(self, reqeust):  \u0026#39;\u0026#39;\u0026#39; apple code 요청 \u0026#39;\u0026#39;\u0026#39;  client_id = APPLE_CONFIG[\u0026#39;APPLE_CLIENT_ID\u0026#39;]  redirect_uri = APPLE_CONFIG[\u0026#39;APPLE_REDIRECT_URI\u0026#39;]   uri = f\u0026#34;{apple_auth_url}?client_id={client_id}\u0026amp;\u0026amp;redirect_uri={redirect_uri}\u0026amp;response_type=code\u0026#34;   res = redirect(uri)  return res uri 파라미터 설명\n client_id : 모바일 로그인시 Bundle ID, 웹 로그인시 Service ID를 사용한다. redirect_uri : APPLE 로그인 정보를 전송받을 URI response_type : code, id_token 옵션이 있다.  \u0026ldquo;code\u0026rdquo; or \u0026ldquo;code id_token\u0026rdquo; 2가지 유형만 사용가능하다. 입력값의 구분은 \u0026quot; \u0026quot; 공백으로 한다.   scope : email, name 옵션이 있다.  scope 요청하였을 경우 response_mode는 form_post를 사용해야한다.   response_mode : 응답 형식 지정  form_post  Method : POST Content-Type : application/x-www-form-urlencoded RestAPI 서버로 요청 처리할 경우 415 Unsupported Media Type 에러가 발생한다.   지정하지 않을 경우  Method : GET Content-Type : application/json RestAPI 서버로 요청 처리할 경우 response_mode 지정하지 않고 사용해야 한다.      Content-Type 설명\n html form 태그를 사용하여 post 방식으로 요청하거나, jQuery의 ajax 등의 요청을 할때 default Content-Type은 application/x-www-form-urlencoded 이다. RestAPI의 경우 보통 JSON(application/json)타입으로 요청 처리한다. 415 Unsupported Media Type 에러가 발생한 경우 위와 같이 Content-type이 일치하지 않을때 발생한다.   4. Apple Callback 함수 사용자가 oauth 로그인시 code 검증 및 로그인 처리한다.\nclass AppleCallbackView(APIView):  def get_key_and_secret(self):  \u0026#39;\u0026#39;\u0026#39; CLIENT_SECRET 생성 \u0026#39;\u0026#39;\u0026#39;  headers = {  \u0026#39;alg\u0026#39;: \u0026#39;ES256\u0026#39;,  \u0026#39;kid\u0026#39;: APPLE_CONFIG[\u0026#39;APPLE_KEY_ID\u0026#39;],  }   payload = {  \u0026#39;iss\u0026#39;: APPLE_CONFIG[\u0026#39;APPLE_TEAM_ID\u0026#39;],  \u0026#39;iat\u0026#39;: time.time(),  \u0026#39;exp\u0026#39;: time.time() + 600, # 인증유효기간 10분  \u0026#39;aud\u0026#39;: apple_base_url,  \u0026#39;sub\u0026#39;: APPLE_CONFIG[\u0026#39;APPLE_CLIENT_ID\u0026#39;],  }   client_secret = jwt.encode(  payload=payload,  key=APPLE_CONFIG[\u0026#39;APPLE_PRIVATE_KEY\u0026#39;],  algorithm=\u0026#39;ES256\u0026#39;,  headers=headers  )   return client_secret   def get(self, request):  \u0026#39;\u0026#39;\u0026#39; apple id_token 요청 및 user_info 조회 \u0026#39;\u0026#39;\u0026#39;  data = request.query_params.copy()  code = data.get(\u0026#39;code\u0026#39;)  # id_token 서명을 에러로 인해 검증할 수 없어 자체 발급한 id_token 사용   # CLIENT_SECRET 생성  client_secret = self.get_key_and_secret()   headers = {\u0026#39;Content-type\u0026#39;: \u0026#34;application/x-www-form-urlencoded\u0026#34;}  request_data = {  \u0026#39;client_id\u0026#39;: APPLE_CONFIG[\u0026#39;APPLE_CLIENT_ID\u0026#39;],  \u0026#39;client_secret\u0026#39;: client_secret,  \u0026#39;code\u0026#39;: code,  \u0026#39;grant_type\u0026#39;: \u0026#39;authorization_code\u0026#39;,  \u0026#39;redirect_uri\u0026#39;: APPLE_CONFIG[\u0026#39;APPLE_REDIRECT_URI\u0026#39;],  }   # client_secret 유효성 검사  res = requests.post(apple_token_url, data=request_data, headers=headers)  response_json = res.json()  id_token = response_json.get(\u0026#39;id_token\u0026#39;)  if not id_token:  return Response(status=status.HTTP_400_BAD_REQUEST)   # 백엔드 자체적으로 id_token 발급받은 경우 서명을 검증할 필요 없음  token_decode = jwt.decode(id_token, \u0026#39;\u0026#39;, options={\u0026#34;verify_signature\u0026#34;: False})  # sub : (subject) is the unique user id  # email : is the email address of the user   if (not token_decode.get(\u0026#39;sub\u0026#39;)) or (not token_decode.get(\u0026#39;email\u0026#39;)) or (not token_decode.get(\u0026#39;email_verified\u0026#39;)):  return Response(status=status.HTTP_400_BAD_REQUEST)   # Apple에서 받은 id_token에서 sub, email 조회  social_type = \u0026#39;apple\u0026#39;  social_id = f\u0026#34;{social_type}_{token_decode[\u0026#39;sub\u0026#39;]}\u0026#34;  user_email = token_decode[\u0026#39;email\u0026#39;]   \u0026#39;\u0026#39;\u0026#39; # 회원가입 및 로그인 처리 알고리즘 추가필요 \u0026#39;\u0026#39;\u0026#39;   # 테스트 값 확인용  res = {  \u0026#39;social_type\u0026#39;: social_type,  \u0026#39;social_id\u0026#39;: social_id,  \u0026#39;user_email\u0026#39;: user_email,  }  response = Response(status=status.HTTP_200_OK)  response.data = res  return response  id_token 검증하려고 할 경우 \u0026lsquo;_EllipticCurvePrivateKey\u0026rsquo; object has no attribute \u0026lsquo;verify\u0026rsquo; 에러가 발생한다. token = jwt.decode(id_token, key=APPLE_CONFIG[\u0026#39;APPLE_PRIVATE_KEY\u0026#39;], algorithms=\u0026#39;RS256\u0026#39;)   id_token 복호화시 아래의 값들이 있다.\n iss aud exp iat sub : 사용자 고유식별자 at_hash email : 사용자 email or 임의의코드@privaterelay.appleid.com email_verified : 이메일 인증여부 auth_time   5. 로그인   웹서버에서 설정한 apple oauth 로그인 페이지로 접근하면 사전에 설정한 애플 리다이렉트 URI로 접근하는데 설정에 문제가 없다면 아래와 같은 로그인 페이지로 접속된다.\n 로그인 페이지에서는 어떤 사이트로 로그인할지 같이 안내한다. 애플 개발자 사이트에서 설정한 Description값이 노출된다.    최초 로그인시 아래와 같이 안내되고 이후는 Apple Callback 함수 처리로 넘어간다.\n   참고(Reference)  What the Heck is Sign In with Apple? configuring_your_webpage_for_sign_in_with_apple  Handle the Authorization Response   generate_and_validate_tokens incorporating_sign_in_with_apple_into_other_platforms  Send the Required Query Parameters    ","date":"December 28, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-12-28-django-oauth-apple/","summary":"django restframework 기반의 애플(apple) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n애플 개발자 사이트에서 사용하는 환경변수들이 등록되어있다는 가정하에 진행한다.\n 1. 라이브러리 설치 $ pip install django  # restframework $ pip install djangorestframework $ pip install djangorestframework-simplejwt  # pyjwt[crypto] $ pip install pyjwt[crypto]  2. Apple 로그인 변수 설정 import os  APPLE_CONFIG = {  \u0026#34;APPLE_TEAM_ID\u0026#34;: TEAM_ID,  \u0026#34;APPLE_CLIENT_ID\u0026#34;: 모바일 로그인시 Bundle ID or 웹 로그인시 Service ID,  \u0026#34;APPLE_REDIRECT_URI\u0026#34;: \u0026#34;https://domain/REDIRECT_URI\u0026#34;,  \u0026#34;APPLE_KEY_ID\u0026#34;: KEY_ID,  \u0026#34;APPLE_KEY_PATH\u0026#34;: \u0026#34;.","tags":["django","oauth","apple"],"title":"Django 소셜로그인(oauth) apple 연동"},{"categories":["Python"],"contents":" python 날짜 및 시간 계산은 python 표준 라이브러리 datetime, 확장 라이브러리 dateutil 2개의 라이브러리가 있으며 단위의 차이가 있다.\n datetime : 마이크로초, 밀리초, 초, 분, 시, 일, 주 단위 사용 dateutil : 마이크로초, 초, 분, 시, 일, 주, 월, 년 단위 사용   1. datetime 라이브러리 날짜와 시간을 조작하는 클래스를 제공하는 python 표준 라이브러리\n1.1 사용예시   now : 현재 날짜 및 시간\nimport datetime as dt  now = dt.datetime.now()  print(f\u0026#34;now = {now}\u0026#34;)  now = 2021-12-27 11:24:27.172476\n   microsecond\nprint(f\u0026#34;microsecond before = {now - timedelta(microseconds=1)}\u0026#34;) print(f\u0026#34;microsecond next = {now + timedelta(microseconds=1)}\u0026#34;)  microsecond before = 2021-12-26 22:08:42.685501\nmicrosecond next = 2021-12-26 22:08:42.685503\n   millisecond\nprint(f\u0026#34;millisecond before = {now - timedelta(milliseconds=1)}\u0026#34;) print(f\u0026#34;millisecond next = {now + timedelta(milliseconds=1)}\u0026#34;)  millisecond before = 2021-12-26 22:08:42.684502\nmillisecond next = 2021-12-26 22:08:42.686502\n   second\nprint(f\u0026#34;second before = {now - timedelta(seconds=1)}\u0026#34;) print(f\u0026#34;second next = {now + timedelta(seconds=1)}\u0026#34;)  second before = 2021-12-26 22:08:41.685502\nsecond next = 2021-12-26 22:08:43.685502\n   minute\nprint(f\u0026#34;minute before = {now - timedelta(minutes=1)}\u0026#34;) print(f\u0026#34;minute next = {now + timedelta(minutes=1)}\u0026#34;)  minute before = 2021-12-26 22:07:42.685502\nminute next = 2021-12-26 22:09:42.685502\n   hour\nprint(f\u0026#34;hour before = {now - timedelta(hours=1)}\u0026#34;) print(f\u0026#34;hour next = {now + timedelta(hours=1)}\u0026#34;)  hour before = 2021-12-26 21:08:42.685502\nhour next = 2021-12-26 23:08:42.685502\n   day\nprint(f\u0026#34;day before = {now - timedelta(days=1)}\u0026#34;) print(f\u0026#34;day next = {now + timedelta(days=1)}\u0026#34;)  day before = 2021-12-25 22:08:42.685502\nday next = 2021-12-27 22:08:42.685502\n   week\nprint(f\u0026#34;week before = {now - timedelta(weeks=1)}\u0026#34;) print(f\u0026#34;week next = {now + timedelta(weeks=1)}\u0026#34;)  week before = 2021-12-19 22:08:42.685502\nweek next = 2022-01-02 22:08:42.685502\n   복합사용\nprint(f\u0026#34;week before = {now - timedelta(days=1, hours=1, minutes=1)}\u0026#34;) print(f\u0026#34;week next = {now + timedelta(days=1, hours=1, minutes=1)}\u0026#34;)  week before = 2021-12-25 21:07:42.685502\nweek next = 2021-12-27 23:09:42.685502\n   2. dateutil 라이브러리 datetime 보다 확장된 기능을 가진 라이브러리\n2.1. 라이브러리 설치 \u0026gt; pip install dateutil 2.2. 사용예시   now : 현재 날짜 및 시간\nfrom datetime import datetime from dateutil.relativedelta import relativedelta  now = datetime.now()  print(f\u0026#34;now = {now}\u0026#34;)  now = 2021-12-26 22:23:22.916446\n   microsecond\nprint(f\u0026#34;microsecond before = {now - relativedelta(microseconds=1)}\u0026#34;) print(f\u0026#34;microsecond next = {now + relativedelta(microseconds=1)}\u0026#34;)  microsecond before = 2021-12-26 22:23:22.916445\nmicrosecond next = 2021-12-26 22:23:22.916447\n   second\nprint(f\u0026#34;second before = {now - relativedelta(seconds=1)}\u0026#34;) print(f\u0026#34;second next = {now + relativedelta(seconds=1)}\u0026#34;)  second before = 2021-12-26 22:23:21.916446\nsecond next = 2021-12-26 22:23:23.916446\n   minute\nprint(f\u0026#34;minute before = {now - relativedelta(minutes=1)}\u0026#34;) print(f\u0026#34;minute next = {now + relativedelta(minutes=1)}\u0026#34;)  minute before = 2021-12-26 22:22:22.916446\nminute next = 2021-12-26 22:24:22.916446\n   hour\nprint(f\u0026#34;hour before = {now - relativedelta(hours=1)}\u0026#34;) print(f\u0026#34;hour next = {now + relativedelta(hours=1)}\u0026#34;)  hour before = 2021-12-26 21:23:22.916446\nhour next = 2021-12-26 23:23:22.916446\n   day\nprint(f\u0026#34;day before = {now - relativedelta(days=1)}\u0026#34;) print(f\u0026#34;day next = {now + relativedelta(days=1)}\u0026#34;)  day before = 2021-12-25 22:23:22.916446\nday next = 2021-12-27 22:23:22.916446\n   week\nprint(f\u0026#34;week before = {now - relativedelta(weeks=1)}\u0026#34;) print(f\u0026#34;week next = {now + relativedelta(weeks=1)}\u0026#34;)  week before = 2021-12-19 22:23:22.916446\nweek next = 2022-01-02 22:23:22.916446\n   month\nprint(f\u0026#34;month before = {now - relativedelta(months=1)}\u0026#34;) print(f\u0026#34;month next = {now + relativedelta(months=1)}\u0026#34;)  month before = 2021-11-26 22:23:22.916446\nmonth next = 2022-01-26 22:23:22.916446\n   year\nprint(f\u0026#34;year before = {now - relativedelta(years=1)}\u0026#34;) print(f\u0026#34;year next = {now + relativedelta(years=1)}\u0026#34;)  year before = 2020-12-26 22:23:22.916446\nyear next = 2022-12-26 22:23:22.916446\n    3. 예시코드 Git python-calculate-the-date-and-time\n 참고(Reference)  datetime.timedelta - 날짜의 차이 Python 날짜 계산 방법 dateutil docs  ","date":"December 26, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-12-26-python-calculate-the-date-and-time/","summary":"python 날짜 및 시간 계산은 python 표준 라이브러리 datetime, 확장 라이브러리 dateutil 2개의 라이브러리가 있으며 단위의 차이가 있다.\n datetime : 마이크로초, 밀리초, 초, 분, 시, 일, 주 단위 사용 dateutil : 마이크로초, 초, 분, 시, 일, 주, 월, 년 단위 사용   1. datetime 라이브러리 날짜와 시간을 조작하는 클래스를 제공하는 python 표준 라이브러리\n1.1 사용예시   now : 현재 날짜 및 시간\nimport datetime as dt  now = dt.","tags":["python"],"title":"python 날짜와 시간 계산"},{"categories":["Go","db"],"contents":" golang에서는 타입별로 정해진 zero value가 있는데, DB colume 타입의 zero value와 맞지 않을 때 다음과 에러가 발생한다.\npanic: sql: Scan error on column index : converting NULL to string is unsupported 각 타입별 zero value\n 문자열 타입 string : \u0026quot;\u0026quot; 부울린 타입 boolean : false 정수형, Float등 숫자형 타입 : 0 기타 타입 : nil   1. 사전환경 아래의 글을 진행했다는 가정에서 설명한다.\ngolang postgreDB CURD\n 2. 에러가 발생한 코드 기존에 작성한 코드에서 Update 함수의 name 부분을 nil 값으로 수정하여 실행한다.\nfunc Read(userId int) { \tsqlStatement := `SELECT \u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34; FROM \u0026#34;user_test\u0026#34; WHERE $1 = \u0026#34;id\u0026#34;` \trows, err := db.Query(sqlStatement, userId) \tif err != nil { \tpanic(err) \t} \tdefer rows.Close()  \tvar id int \tvar name string \tvar age int \tfor rows.Next() { \terr := rows.Scan(\u0026amp;id, \u0026amp;name, \u0026amp;age) // name 타입 에러 발생 \tif err != nil { \tpanic(err) \t}  \tfmt.Printf(\u0026#34;[Read] id: %d, name: %v, age: %d\\n\u0026#34;, id, name, age) \t} }  func Update(id int64, user User) { \tsqlStatement := `UPDATE user_test SET name=$2, age=$3 WHERE id=$1`  \tres, err := db.Exec(sqlStatement, id, nil, user.Age) \tif err != nil { \tpanic(err) \t}  \trowsAffected, err := res.RowsAffected() \tif err != nil { \tpanic(err) \t}  \tfmt.Printf(\u0026#34;[Update] Total rows/record affected %v\\n\u0026#34;, rowsAffected) }  func main() { \tInitDB()   Create(\u0026#34;foo\u0026#34;, 10)  Update(1, User{Age: 20}) \tRead(1)  \tdefer db.Close() } 데이터 수정후 해당 데이터를 조회하면 아래와 같은 에러가 발생한다.\ngolang에서는 타입별로 정해진 zero value와, DB colume 타입의 zero value와 맞지 않아서 발생한 에러이다.\n\u0026gt; go run main.go [Update] Total rows/record affected 1 panic: sql: Scan error on column index 1, name \u0026#34;name\u0026#34;: converting NULL to string is unsupported  3. 문제 해결한 코드 database/sql 패키지의 Null*자료형을 사용한다.\nNull* 자료형은 zerovalue가 null값이 아닌 기본 자료형을 지원한다.\n sql.NullString : null 유무가 포함된 문자열 타입 sql.NullString.Valid: null값이면 false, 아니면 true 값을 가진다. sql.NullString.String: 해당 변수의 문자열 값이다.  func Read(userId int) { \tsqlStatement := `SELECT \u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34; FROM \u0026#34;user_test\u0026#34; WHERE $1 = \u0026#34;id\u0026#34;` \trows, err := db.Query(sqlStatement, userId) \tif err != nil { \tpanic(err) \t} \tdefer rows.Close()  \tvar id int \tvar name sql.NullString \tvar age int \tfor rows.Next() { \terr := rows.Scan(\u0026amp;id, \u0026amp;name, \u0026amp;age) \tif err != nil { \tpanic(err) \t}  \tif name.Valid { \tfmt.Printf(\u0026#34;[Read] id: %d, name: %v, age: %d\\n\u0026#34;, id, name.String, age) \t} else { \tfmt.Printf(\u0026#34;[Read] id: %d, name: %v, age: %d\\n\u0026#34;, id, name, age) \t} \t} }  func main() { \tInitDB()  \tRead(1) \tRead(2)  \tdefer db.Close() } .Valid 조건문을 통해 nil값에 대한 필터링을 하거나 별도로 처리할 수 있다.\n\u0026gt; go run main.go [Read] id: 1, name: { false}, age: 20 [Read] id: 2, name: bar, age: 20  4. 예시코드 Git golang-db-nullable-value\n","date":"December 23, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-12-23-golang-db-nullable-value/","summary":"golang에서는 타입별로 정해진 zero value가 있는데, DB colume 타입의 zero value와 맞지 않을 때 다음과 에러가 발생한다.\npanic: sql: Scan error on column index : converting NULL to string is unsupported 각 타입별 zero value\n 문자열 타입 string : \u0026quot;\u0026quot; 부울린 타입 boolean : false 정수형, Float등 숫자형 타입 : 0 기타 타입 : nil   1. 사전환경 아래의 글을 진행했다는 가정에서 설명한다.\ngolang postgreDB CURD\n 2.","tags":["go","db"],"title":"golang db nullable 데이터 처리"},{"categories":["Docker","Go"],"contents":" 간단한 golang 웹 프로그램을 Docker 이미지로 실행방법으로\ngolang 코드보다는 docker 설정 위주로 설명한다.\n 1. 예제 코드 사용예시는 아래의 주소를 git clone 받는다.\n\u0026gt; git clone https://github.com/olliefr/docker-gs-ping  docker-gs-ping   2. 예제 프로그램 실행 git clone 받은 프로젝트 경로에서 터미널을 실행하고 진행한다.\n\u0026gt; go run main.go 설정한 웹주소로 접속 요청시 간단한 response 메세지를 응답한다.\n\u0026gt; curl localhost:8080 Hello, Docker! \u0026lt;3  3. Dockerfile dockerfile 명칭은 Dockerfile.\u0026lt;something\u0026gt; 또는 \u0026lt;something\u0026gt;.Dockerfile 형식으로 생성한다.\n도커 명령어\n FROM : 기본 이미지 지정 WORKDIR : 작업 디렉터리 지정 COPY : 소스코드 복사  https://docs.docker.com/engine/reference/builder/#copy   EXPOSE : 도커 컨테이너의 Port 설정 RUN : 새로운 도커 레이어를 생성하고 명령어를 실행한다. 패키지 설치 등에 사용된다. CMD : default 명령어나 파라미터를 설정한다. docker run 실행 시 실행할 명령어를 지정하지 않으면 default 명령이 실행된다.  Dockerfile\nFROM golang:1.17-alpine WORKDIR /app # Go modules 다운로드 COPY go.mod . COPY go.sum . RUN go mod download COPY *.go ./ # go build RUN go build -o /docker-gs-ping EXPOSE 8080 # go 프로그램 실행 CMD [\u0026#34;/docker-gs-ping\u0026#34;] docker build : 도커 이미지 빌드\n\u0026gt; docker build --tag docker-gs-ping . docker image ls : 도커 로컬이미지 조회\n\u0026gt; docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE docker-gs-ping latest 4f0670869ed5 12 seconds ago 540MB docker image tag : 도커 이미지 태그 지정\n# Usage: docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] \u0026gt; docker image tag docker-gs-ping:latest docker-gs-ping:v1.0 \u0026gt; docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE docker-gs-ping latest 4f0670869ed5 3 minutes ago 540MB docker-gs-ping v1.0 4f0670869ed5 3 minutes ago 540MB  4. Multi-stage builds 도커 이미지 용량 줄이는 방법 중 하나로 프로그램 실행에 필요한 파일들만으로 이미지를 생성하는 방법이다.\n FROM golang:1.16-buster AS build : 해당 이미지 별명을 지정한다. COPY --from=build [src_dir] [dst_dir] : from으로 지정한 이미지의 디렉터리를 현재 이미지 디렉터리로 복사한다. ENTRYPOINT : 컨테이너를 실행 파일로 사용할 때 정의되어야 한다.\n사용법은 CMD와 같다.  CMD와 ENTRYPOINT의 조합 예시\nENTRYPOINT / CMD combinations   gcr.io/distroless/base-debian10 : go에서 공식 지원하는 도커 이미지로 bash와 같은 쉘 , linux 패키지 관리자, 기타 프로그램 등이 없는 경량화된 이미지이다. USER nonroot:nonroot : 컨테이너 권한 설정으로 도커 컨테이너는 기본적으로 root권한으로 실행된다.\n따라서 컨테이너 안에서 실행중인 애플리케이션을 해킹하면 해커들이 도커 호스트에 대한 루트권한을 얻을 수 있기 때문에 별도의 사용자권한으로 제한하는것을 권장한다.\n하지만 컨테이너 내부에서 외부 볼륨 참조에 의한 디렉터리 및 파일 등을 조작이 필요한 경우 적절한 권한으로 설정하거나 해당 USER 옵션을 사용하지 않을 수 있다.  Dockerfile.multistage\n## Build FROM golang:1.16-buster AS build WORKDIR /app COPY go.mod . COPY go.sum . RUN go mod download COPY *.go ./ RUN go build -o /docker-gs-ping ## Deploy FROM gcr.io/distroless/base-debian10 WORKDIR / COPY --from=build /docker-gs-ping /docker-gs-ping EXPOSE 8080 USER nonroot:nonroot ENTRYPOINT [\u0026#34;/docker-gs-ping\u0026#34;] 도커 이미지 빌드\n\u0026gt; docker build -t docker-gs-ping:multistage -f Dockerfile.multistage . \u0026gt;docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE docker-gs-ping multistage 04b0984d8007 5 seconds ago 27.1MB docker-gs-ping latest 4f0670869ed5 13 minutes ago 540MB  5. 도커 컨테이너 실행  --publish or -p: 외부 접속포트와 컨테이너포트를 연동시키는 명령이다.  -p [host_port]:[container_port]   -d : detached mode로 백그라운드에 실행 컨테이너가 실행된다.  \u0026gt; docker run -d -p 8080:8080 docker-gs-ping docker ps : 도커 컨테이너 실행 확인\n\u0026gt; docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4984da23dfa3 docker-gs-ping \u0026#34;/docker-gs-ping\u0026#34; 8 minutes ago Up 8 minutes 0.0.0.0:8080-\u0026gt;8080/tcp stoic_shaw 컨테이너가 정상적으로 실행되었다면 접속시 아래와 같은 응답 값을 받을 수 있다.\n\u0026gt; curl localhost:8080 Hello, Docker! \u0026lt;3  참고(Reference)  Docker docs Build your Go image  ","date":"December 22, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/docker/2021-12-22-docker-golang-image-build/","summary":"간단한 golang 웹 프로그램을 Docker 이미지로 실행방법으로\ngolang 코드보다는 docker 설정 위주로 설명한다.\n 1. 예제 코드 사용예시는 아래의 주소를 git clone 받는다.\n\u0026gt; git clone https://github.com/olliefr/docker-gs-ping  docker-gs-ping   2. 예제 프로그램 실행 git clone 받은 프로젝트 경로에서 터미널을 실행하고 진행한다.\n\u0026gt; go run main.go 설정한 웹주소로 접속 요청시 간단한 response 메세지를 응답한다.\n\u0026gt; curl localhost:8080 Hello, Docker! \u0026lt;3  3. Dockerfile dockerfile 명칭은 Dockerfile.\u0026lt;something\u0026gt; 또는 \u0026lt;something\u0026gt;.Dockerfile 형식으로 생성한다.","tags":["docker","go"],"title":"golang 도커 이미지 만들기"},{"categories":["Docker"],"contents":" Docker Image 경량화의 장점\n 저장공간 절약 이미지 빌드 및 배포시간 단축 클라우드 서비스를 이용한 배포의 경우 비용 절약   1. 가벼운 Base image 사용 Base image에는 사용하지 않은 기능들이 포함되어 있기때문에 Debian계열과 Alpine 계열등 다양한 Base image를 사용하여 용량을 줄일 수 있다.\n 단, 필요한 패키지나 파일이 없어 별도의 설치가 필요할 수 있다.  기본 python 이미지와 slim형 이미지를 각각 빌드한다.\nimage-test1\nFROM python:3.8.10 image-test2\nFROM python:3.8.10-slim-buster 각각 빌드된 이미지 크기는 다음과 같다.\n# docker images REPOSITORY TAG IMAGE ID CREATED SIZE image-test1 latest 3249573f28c9 5 months ago 883MB image-test2 latest 004c04ba9ac3 2 months ago 114MB python:3.8.10-slim-buster\n postgreDB 라이브러리 사용할 경우 psycopg2가 아닌 psycopg2-binary를 사용해야한다. libmagic 라이브러리 사용할 경우 별도로 libmagic1설치가 필요하다. RUN apt-get update \u0026amp;\u0026amp; apt-get install -y --no-install-recommends libmagic1 \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*    2. Dockerfile 명령어 체인방식 사용 Dockerfile에서 RUN명령을 개별로 실행시 실행이 끝날때마다 중간 이미지가 생성된다.\n체인 명령으로 실행하면 중간이미지가 적게 만들어지기 때문에 크기와 실행시간을 줄일 수 있다.\n 현재 Docker 버전에서의 영향은 미미하다.  Dockerfile 개별 실행 명령\nENV APP_HOME=/app RUN mkdir $APP_HOME RUN mkdir $APP_HOME/.static_root RNU mkdir $APP_HOME/media Dockerfile 체인 실행 명령\nENV APP_HOME=/app RUN mkdir $APP_HOME \u0026amp;\u0026amp; mkdir $APP_HOME/.static_root \u0026amp;\u0026amp; mkdir $APP_HOME/media  3. 패키지 관리 Package 매니저로 패키지를 설치할 경우 보통 사용하지않은 패키지가 함께 설치된다.\napt-get 사용하여 패키지 설치시 용량을 최소화 하는 방법\n \u0026ndash;no-install-recommends 최소 설치 옵션을 사용한다. apt-get install -y --no-install-recommends cron  apt-get clean 명령어 사용한다.  /var/cache/apt/archives 디렉터리에 패키지 다운로드한 파일 삭제  apt-get clean  /var/lib/pat/lists 디렉터리의 패키지 리스트 파일 삭제 rm -rf /var/lib/apt/lists/*    4. Docker Layer 관리 Docker Image에는 Layer라는 Stack구조가 있다. 도커 이미지를 효과적으로 관리하기 위해 Stack형태로 이미지가 누적되며, 동일한 Stack이 동일한 Repository에 존재하면 해당 Layer를 사용하도록 구현되어 있다. Docker Image는 Container 용량을 결정하고, 관리측면에서 Local Repository나 Docker Registry의 용량에 영향을 준다.\n Dockerfile 작성 시 라이브러리 설치 등 수정이 적은 명령어를 상단에 프로젝트 코드 등 데이터 수정이 빈번한 명령어는 하단에 작성하면 이미지 중복 생성을 최소화할 수 있다.  image-test1\nFROM debian RUN apt-get update \u0026amp;\u0026amp; apt-get install -y cron RUN rm -rf /var/lib/apt/lists/* image-test2\nFROM debian RUN apt-get update \u0026amp;\u0026amp; apt-get install -y cron \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* 각각 빌드된 이미지 크기는 다음과 같다.\n# docker images REPOSITORY TAG IMAGE ID CREATED SIZE image-test1 latest 211a762c5a58 2 minutes ago 230MB image-test2 latest 297340498b12 1 minutes ago 213MB 동일한 명령을 수행하여도 차이가 나는 이유는 Layer별 참조 관계 때문이다. 따라서 사용하지 않고 삭제가 필요한 경우에는 반드시 같은 Layer에서 처리해야 한다.\nDocker Layer는 Union Mount라는 Linux Mount 기술을 활용하여 여러 Layer를 통합하여 하나의 이미지로 관리한다.\nDocker Layer 별 용량 확인 docker history [IMAGE] : 해당 Docker 이미지의 각 layer마다 사용된 용량을 확인할 수 있다.\n# docker history [IMAGE] ... IMAGE CREATED CREATED BY SIZE COMMENT 148db3ce1bdc 16 minutes ago RUN /bin/sh -c apt-get update \u0026amp;\u0026amp; apt-get ins… 2.24MB buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c #(nop) CMD [\u0026#34;python3\u0026#34;] 0B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c set -ex; wget -O get-pip.py \u0026#34;$P… 8.31MB \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c #(nop) ENV PYTHON_GET_PIP_SHA256… 0B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c #(nop) ENV PYTHON_GET_PIP_URL=ht… 0B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c #(nop) ENV PYTHON_SETUPTOOLS_VER… 0B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c #(nop) ENV PYTHON_PIP_VERSION=21… 0B ... --no-trunc옵션 : CREATED BY 설명의 생략된 부분까지 확인 할 수 있다.\n# docker history --no-trunc [IMAGE]  5. 배포 시 불필요한 빌드 도구를 설치하지 않기 소스코드를 빌드해서 이미지에 포함시키면, 불필요한 빌드 도구가 차지하는 공간을 줄일 수 있다.\n 6. .dockerignore 활용하기 Docker build 시 명령어 COPY 등을 통해서 프로젝트 파일을 컨테이너로 복사할 때 지정한 디렉터리, 파일을 자동으로 제외된다.\n Docker는 Go 언어기반으로 파일 매칭도 Go 언어규칙을 적용한다. 임시파일, Git, Docker 관련, 비공개 정보 파일 등 예외 처리한다. docker volumes 참조와 겹치지 않도록 한다.(volumes 우선적용)   7. multi-stage 빌드 multi-stage 빌드는 Dockerfile 1개에 FROM 구문을 여러 개 두는 방식이다.\n각 FROM 명령문 기준으로 스테이지를 구분하여 특정 스테이지 빌드 과정에서 생성된 것 중 사용되지 않거나 불필요한 것을 무시하고, 필요한 부분만 가져와서 새로운 베이스 이미지에서 빌드할 수 있다.\n COPY --from=builder : 전 단계 스테이지 빌드에서 생성된 특정 결과물을 새로운 베이스 이미지로 복사하는 옵션  image-test1\nFROM python:3.8.10-slim-buster RUN pip install django image-test2\nFROM python:3.8.10-slim-buster AS builder RUN pip install django FROM python:3.8.10-slim-buster COPY --from=builder /usr/local/lib/python3.8/site-packages /usr/local/lib/python3.8/site-packages 각각 빌드된 이미지 크기는 다음과 같다.\n# docker images REPOSITORY TAG IMAGE ID CREATED SIZE image-test1 latest 62fad51305c5 2 minutes ago 155MB image-test2 latest 004c04ba9ac3 1 minutes ago 151MB  사용하는 라이브러리에 따라 용량 차이가 더 많이 나올 수 있다. 외부 설정이 까다로운 경우에는 multi-stage를 사용하지 않을 수 있다.   참고(Reference)  컨테이너 이미지 생성시 고려사항 Docker - image 크기 줄이기 Alpine을 사용하면 Python Docker를 50배 더 느리게 만들 수 있다. 도커 이미지 잘 만드는 방법  ","date":"December 21, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/docker/2021-12-21-docker-reduce-the-volume/","summary":"Docker Image 경량화의 장점\n 저장공간 절약 이미지 빌드 및 배포시간 단축 클라우드 서비스를 이용한 배포의 경우 비용 절약   1. 가벼운 Base image 사용 Base image에는 사용하지 않은 기능들이 포함되어 있기때문에 Debian계열과 Alpine 계열등 다양한 Base image를 사용하여 용량을 줄일 수 있다.\n 단, 필요한 패키지나 파일이 없어 별도의 설치가 필요할 수 있다.  기본 python 이미지와 slim형 이미지를 각각 빌드한다.\nimage-test1\nFROM python:3.8.10 image-test2\nFROM python:3.8.10-slim-buster 각각 빌드된 이미지 크기는 다음과 같다.","tags":["docker"],"title":"도커 경량화 이미지 만들기"},{"categories":["Go","cron"],"contents":" go언어에서 cron 처럼 동작하는 스케줄링 외부 라이브러리 사용법\n cron 함수는 지정한 주기마다 동작시키는 기능으로 별도의 비동기함수로 실행된다. main 함수가 종료되면 go 프로세스가 종료되어 비동기 함수도 종료된다. cron 기능을 사용할려면 main 함수가 종료되지 않도록 적절한 조치를 해야한다.   1. 라이브러리 설치 go version : 1.17\n\u0026gt; go get github.com/robfig/cron/v3@v3.0.0  2. 예제코드  select : 복수 채널이 대기하면서 준비된 (데이터를 전송받은) 채널을 실행하는 기능이다. case 채널들이 준비되지 않으면 계속 대기하게 되고, 가장 먼저 도착한 채널의 case를 실행한다. select {} : 채널을 지정하지 않아 main 함수 종료 방지용으로 사용한다.  기본 예제\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/robfig/cron/v3\u0026#34; )  func main() { \tc := cron.New() \tc.AddFunc(\u0026#34;* * * * *\u0026#34;, func() { \tfmt.Println(\u0026#34;cron 실행\u0026#34;) \t}) \tc.Start()  \t// main 함수 종료 방지 \tselect {} }  3. AddFunc 다양한 사용법 AddFunc에서 지정한 스케줄링은 기본 linux 시스템의 cron문법과 유사하다.\nc.AddFunc(\u0026#34;* * * * *\u0026#34;, func() { fmt.Println(\u0026#34;Every hour on the half hour\u0026#34;) }) // 매분마다 c.AddFunc(\u0026#34;30 * * * *\u0026#34;, func() { fmt.Println(\u0026#34;Every hour on the half hour\u0026#34;) }) // 매시간 30분마다 c.AddFunc(\u0026#34;@hourly\u0026#34;, func() { fmt.Println(\u0026#34;Every hour\u0026#34;) }) // 매시간마다 c.AddFunc(\u0026#34;@daily\u0026#34;, func() { fmt.Println(\u0026#34;Every day\u0026#34;) }) // 매일마다 c.AddFunc(\u0026#34;@every 1h30m\u0026#34;, func() { fmt.Println(\u0026#34;Every hour thirty\u0026#34;) }) // 1시간 30분 경과할때마다  참고(Reference)  cron package  ","date":"December 21, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-12-21-golang-cron/","summary":"go언어에서 cron 처럼 동작하는 스케줄링 외부 라이브러리 사용법\n cron 함수는 지정한 주기마다 동작시키는 기능으로 별도의 비동기함수로 실행된다. main 함수가 종료되면 go 프로세스가 종료되어 비동기 함수도 종료된다. cron 기능을 사용할려면 main 함수가 종료되지 않도록 적절한 조치를 해야한다.   1. 라이브러리 설치 go version : 1.17\n\u0026gt; go get github.com/robfig/cron/v3@v3.0.0  2. 예제코드  select : 복수 채널이 대기하면서 준비된 (데이터를 전송받은) 채널을 실행하는 기능이다. case 채널들이 준비되지 않으면 계속 대기하게 되고, 가장 먼저 도착한 채널의 case를 실행한다.","tags":["go","cron"],"title":"golang cron 스케줄링 라이브러리 사용법"},{"categories":["Algorithm","Programmers"],"contents":" 다단계 칫솔 판매 분류 : 2021 Dev-Matching: 웹 백엔드 개발자(상반기)\n문제 링크\n방법1 def solution(enroll, referral, seller, amount):  answer = []   data = {\u0026#39;center\u0026#39;: {\u0026#39;amount\u0026#39;: 0,\u0026#39;parent\u0026#39;: None}}  for i in range(len(enroll)):  data[enroll[i]] = {  \u0026#39;amount\u0026#39;: 0,  \u0026#39;parent\u0026#39;: referral[i] if referral[i] != \u0026#39;-\u0026#39; else \u0026#39;center\u0026#39;  }   for i in range(len(seller)):  sell = seller[i]  price = amount[i] * 100  data[sell][\u0026#39;amount\u0026#39;] += price-price//10  price = price//10   while data[sell][\u0026#39;parent\u0026#39;] and price:  sell = data[sell][\u0026#39;parent\u0026#39;]  if sell == \u0026#39;center\u0026#39;:  data[sell][\u0026#39;amount\u0026#39;] += price  break  data[sell][\u0026#39;amount\u0026#39;] += price-price//10  price = price//10   del data[\u0026#39;center\u0026#39;]  for value in data.values():  answer.append(value[\u0026#39;amount\u0026#39;])   return answer 2021-12-20\n min TaseCase : 0.08ms, 10.2MB\nmax TaseCase : 167.55ms, 22.2MB\n 방법2  동일한 index에 접근하는 두개의 리스트는 zip함수로 묶어서 동시에 처리한다. 원하는 값을 바로 반환할수 있게 dict자료형을 2개로 분할한다. while문 동작을 do-while문처럼 동작시킨다.  def solution(enroll, referral, seller, amount):  money, parent = {}, {}  for e, r in zip(enroll, referral):  money[e] = 0  parent[e] = r   for s, a in zip(seller, amount):  price = a * 100  while True:  total_price = price  price = total_price//10  money[s] += total_price-price  s = parent[s]  if (s == \u0026#39;-\u0026#39;) or (not price):  break   return list(money.values()) 2021-12-27\n min TaseCase : 0.01ms, 10.3MB\nmax TaseCase : 92.37ms, 21.2MB\n  표 편집 분류 : 2021 카카오 채용연계형 인턴십\n문제 링크\n linked list 방식으로 풀이  def solution(n, k, cmd):  # 초기 설정  answer_dict = dict()  for i in range(n):  answer_dict[i] = [i-1, i+1]  answer_dict[0][0] = None  answer_dict[n-1][1] = None   stack_del = list()   for c in cmd:  if c[0] == \u0026#34;U\u0026#34;: # Up  move = int(c[2:])   while move != 0:  k = answer_dict[k][0]  move -= 1   elif c[0] == \u0026#34;D\u0026#34;: # Down  move = int(c[2:])   while move != 0:  k = answer_dict[k][1]  move -= 1   elif c[0] == \u0026#34;C\u0026#34;: # 삭제  stack_del.append([k, answer_dict[k]])   front = answer_dict[k][0]  back = answer_dict[k][1]   if front != None:  answer_dict[front][1] = back  if back != None:  answer_dict[back][0] = front   k = back if back != None else front   elif c[0] == \u0026#34;Z\u0026#34;: # 복구  recovery = stack_del.pop()  answer_dict[recovery[0]] = recovery[1]   key = recovery[0]  front = recovery[1][0]  back = recovery[1][1]   if front != None:  answer_dict[front][1] = key  if back != None:  answer_dict[back][0] = key   # 정답  answer = [\u0026#39;O\u0026#39; for _ in range(n)]  for key, _ in stack_del:  answer[key] = \u0026#39;X\u0026#39;  answer = \u0026#39;\u0026#39;.join(answer)   return answer 2022-03-26\n 정확성\nmin TaseCase : 0.03ms, 10.4MB\nmax TaseCase : 5.64ms, 10.6MB\n효율성\nmin TaseCase : 235.29ms, 77.6MB\nmax TaseCase : 906.85ms, 232MB\n  네트워크 분류 : 깊이/너비 우선 탐색(DFS/BFS)\n문제 링크\n방법  너비우선탐색(BFS)구조의 재귀함수로 풀이  추가한 테스트\n   n computers return     8 [[1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1]] 3   4 [[1, 1, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [1, 0, 1, 1]] 1    def solution(n, computers):  return find_node(computers)  def find_node(computers):  for i, computer1 in enumerate(computers):  for j in range(i+1, len(computers)):  for k, l in zip(computer1, computers[j]):   # and 연산으로 같은 네트워크 인지 검증  if k and l:  temp_node = []  for val1, val2 in zip(computers[j], computer1):  # 같은 네트워크 이면 or 연산으로 네트워크 확장  temp_node.append(val1 or val2)  computers[i] = temp_node   # 병합된 연결정보 삭제  del computers[j]   # 연결정보가 갱신되었으므로 처음부터 다시 연결정보 탐색  return find_node(computers)  return len(computers) 2022-03-27\n min TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 1.04ms, 10.4MB\n  가장 먼 노드 분류 : 그래프\n문제 링크\n 우선순위 큐를 적용한 다익스트라 최단 거리 알고리즘을 사용한다. 다익스트라 알고리즘은 간선의 방향성을 체크하므로 무방향성을 위해 입력받은 vertex 연결 정보를 양방향으로 만들고 진행한다.  import heapq  def dijkstra(start, distance, graph):  q = []   heapq.heappush(q, (0, start))  distance[start] = 0   while q:  dist, now = heapq.heappop(q)   if distance[now] \u0026lt; dist:  continue   for i in graph[now]:  cost = dist + i[1]   if cost \u0026lt; distance[i[0]]:  distance[i[0]] = cost  heapq.heappush(q, (cost, i[0]))  def solution(n, edge):  answer = 0  start = 1  INF = int(1e9)   graph = [[] for _ in range(n+1)]  distance = [INF for _ in range(n+1)]   for i, j in edge:  graph[i].append((j, 1))  graph[j].append((i, 1))   dijkstra(start, distance, graph)   distance_list = []  for i in range(1, n+1):  if distance[i] == INF: continue  distance_list.append(distance[i])   answer = distance_list.count(max(distance_list))   return answer 2022-03-29\n min TaseCase : 0.03ms, 10.2MB\nmax TaseCase : 120.05ms, 27.2MB\n  정수 삼각형 분류 : 동적계획법(Dynamic Programming)\n문제 링크\n 동적계획법 방식으로 문제 풀이한다.  import copy  def solution(triangle):  n = len(triangle)  dp = [0 for _ in range(len(triangle[-1]))]   for i in range(n):  array = copy.deepcopy(dp)  for j, k in enumerate(triangle[i]):  if j == 0:  dp[j] += k  continue   dp[j] = max(array[j], array[j-1]) + k   return max(dp) 2022-03-29\n 정확성\nmin TaseCase : 0.07ms, 10.2MB\nmax TaseCase : 6.33ms, 10.5MB\n효율성\nmin TaseCase : 76.97ms, 13.3MB\nmax TaseCase : 112.80ms, 14.9MB\n  등굣길 분류 : 동적계획법(Dynamic Programming)\n문제 링크\n방법1  동적계획법 방식으로 문제풀이 아래 풀이는 문제에서 요구한 최단경로의 갯수만 연산하는 최적화가 필요함  def solution(m, n, puddles):  INF = int(1e9)   dp = [[[INF,0] for _ in range(m)] for _ in range(n)]   # puddles 위치 indexr에 맞도록 수정 (입력값 위치(x, y) 주의!)  puddles = [[puddle[0]-1, puddle[1]-1] for puddle in puddles]   for h in range(n):  for w in range(m):   # 침수 지역일 경우 다음 단계로  if [h,w] in puddles:  continue   if 0 \u0026lt;= h-1 \u0026lt; n:  value_y = dp[h-1][w][0]+1  else:  value_y = INF   if 0 \u0026lt;= w-1 \u0026lt; m:  value_x = dp[h][w-1][0]+1  else:  value_x = INF   # 최단 경로의 개수  if value_y \u0026lt; value_x:  value = value_y  count = dp[h-1][w][1]  elif value_x \u0026lt; value_y:  value = value_x  count = dp[h][w-1][1]  else:  value = value_y  count = dp[h-1][w][1] + dp[h][w-1][1]   # 처음위치일 경우  if (value_x is INF) and (value_y is INF):  value = 0  count = 1   dp[h][w] = [value, count]   return dp[n-1][m-1][1] % 1000000007 2022-03-30\n 정확성\nmin TaseCase : 0.01ms, 10.3MB\nmax TaseCase : 0.21ms, 10.2MB\n효율성\nmin TaseCase : 2.56ms, 10.3MB\nmax TaseCase : 7.37ms, 10.9MB\n 방법2  오른쪽, 아래로만 이동가능하므로 무조건 최단경로를 만족하게됨 최단경로 계산이 아닌 갈수 있는 경우의 수 연산으로 수정하면 최적화 가능   이중우선순위큐 분류 : 힙(Heap)\n문제 링크\n 이중 우선순위 큐를 사용해야 하므로 heap 자료구조를 2개 선언하여 풀이한다.  python은 heap 라이브러리가 최소힙으로 동작한다.    추가 테스트 케이스\n   operations result     [\u0026ldquo;I 4\u0026rdquo;, \u0026ldquo;I 3\u0026rdquo;, \u0026ldquo;I 2\u0026rdquo;, \u0026ldquo;I 1\u0026rdquo;, \u0026ldquo;D 1\u0026rdquo;, \u0026ldquo;D 1\u0026rdquo;, \u0026ldquo;D -1\u0026rdquo;, \u0026ldquo;D -1\u0026rdquo;, \u0026ldquo;I 5\u0026rdquo;, \u0026ldquo;I 6\u0026rdquo;] [6,5]    import heapq  def solution(operations):  answer = []  count = 0  values_min, values_max = [], []   for operation in operations:  op, value = operation.split()  value = int(value)   if op == \u0026#39;I\u0026#39;:  # pyhton은 최소힙으로 기본 동작  heapq.heappush(values_min, value)  heapq.heappush(values_max, -value)  count += 1   elif op == \u0026#39;D\u0026#39; and (0 \u0026lt; count):  if value \u0026lt; 0:  heapq.heappop(values_min)  else:  heapq.heappop(values_max)  count -= 1   # 모두 삭제된 경우로 초기화  if count == 0:  values_min, values_max = [], []   if 0 \u0026lt; count:  answer = [-heapq.heappop(values_max), heapq.heappop(values_min)]  else:  answer = [0, 0]   return answer 2022-03-30\n min TaseCase : 0.02ms, 10.4MB\nmax TaseCase : 0.03ms, 10.4MB\n  디스크 컨트롤러 분류 : 힙(Heap)\n문제 링크\n 힙구조를 이용한 풀이 디스크요청의 정렬이 필요하고 요청사이의 idle 시간도 주의한다.  추가 테스트 케이스\n   jobs result     [[0, 1], [1, 1], [5, 7]] 3    import heapq  def solution(jobs):  answer = 0  sequences = {}  heap = []   for job in jobs:  if job[0] in sequences:  sequences[job[0]].append(job[1])  else:  sequences[job[0]] = [job[1]]   now_time, process_time = 0, 0  while sequences or heap:  # 디스크 작업 요청  if now_time in sequences:  for sequence in sequences[now_time]:  heapq.heappush(heap, (sequence, now_time))  del sequences[now_time]   # 처리중인 작업이 없을 경우  if (not process_time) and heap:  process_time, request_time = heapq.heappop(heap)  # 처리된 시간 = 현재시간 - 요청시간 + 소요시간  answer += now_time - request_time + process_time   if 0 \u0026lt; process_time:  process_time -= 1  now_time += 1   answer = answer // len(jobs)  return answer 2022-03-30\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 24.18ms, 10.3MB\n  단어 변환 분류 : 깊이/너비 우선 탐색(DFS/BFS)\n문제 링크\n DFS 문제로 재귀함수를 사용하여 풀이한다.  def word_conversion(begin, target, nodes, stack):  count = 0  stack.append(begin)   # target과 동일한 경우  if target == begin:  return len(stack)-1   path_count = []  for i in range(len(target)):  w = f\u0026#34;{begin[:i]}{begin[i+1:]}\u0026#34;   if w in nodes[i]:  for word in nodes[i][w]:  if word not in stack:  conversion_result = word_conversion(word, target, nodes, stack)  if conversion_result != 0:  path_count.append(conversion_result)  stack.pop()   if path_count:  count = min(path_count)   return count  def solution(begin, target, words):  answer = 0  length = len(target)  nodes = {i: {} for i in range(length)}   # 연결관계 정립  for word in words:  for i in range(length):  w = f\u0026#34;{word[:i]}{word[i+1:]}\u0026#34;  if w in nodes[i]:  nodes[i][w].append(word)  else:  nodes[i][w] = [word]   # DFS -\u0026gt; 재귀  stack = []  answer = word_conversion(begin, target, nodes, stack)   return answer 2022-03-30\n min TaseCase : 0.02ms, 10.2MB\nmax TaseCase : 0.23ms, 10.3MB\n  단속카메라 분류 : 탐욕법(Greedy)\n문제 링크\n routes를 진입지점 \u0026lt;= 진출지점 되도록 정렬한다. 저장된 진출지점보다 현재 진입지점이 뒤에 위치할 경우 새로운 단속 카메라 설치한다. 이때 현재 진출지점이 저장된 진출지점보다 앞에 위치할 경우 저장된 진출지점을 재설정한다.  추가한 테스트\n   routes return      [[10,50],[15,20],[40,60]] 2     def solution(routes):  # 진입 지점과 진출 위치 정렬   sort_routes = sorted(routes, key=lambda x: x[1])   # 나갈 지점 설정  exit_point = sort_routes[0][1]  answer = 1   for route in sort_routes[1:]:  # 저장된 진출지점보다 현재 진입지점이 뒤에 위치할 경우 새로운 단속 카메라 설치  if exit_point \u0026lt; route[0]:  answer += 1  exit_point = route[1]  # 현재 진출지점이 저장된 진출지점보다 앞에 위치할 경우 저장된 진출지점을 재설정  elif route[1] \u0026lt; exit_point:  exit_point = route[1]   return answer 2022-04-03\n 정확성\nmin TaseCase : 0.01ms, 10.3MB\nmax TaseCase : 0.03ms, 10.1MB\n효율성\nmin TaseCase : 0.48ms, 10.2MB\nmax TaseCase : 1.07ms, 10.6MB\n  베스트앨범 분류 : 해시\n문제 링크\n 해시테이블 구조인 dict형 변수에 key: 장르, value: [장르내 모든 재생횟수, [곡 재생횟수, 곡 고유번호]...] 형태로 변환한다. 각 장르별 앨범에서 2곡을 최대힙에서 얻는다.  장르에 곡이 1개인 경우도 고려한다.   장르별 총 재생횟수와 장르내에서 많이 재생된 순, 재생횟수 동일한 경우 고유번호가 낮은 순으로 sort_album에 저장한다. 장르별 가장 많이 재생된 횟수 내림차순 정렬한 뒤 문제에서 요구한 형식으로 반환한다.  추가한 테스트\n   genres plays return     [\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;, \u0026ldquo;d\u0026rdquo;] [1, 2, 3, 4] [3, 2, 1, 0]   [\u0026ldquo;classic\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;classic\u0026rdquo;, \u0026ldquo;classic\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;] [500, 600, 501, 800, 900] [3, 2, 4, 1]    import heapq  def solution(genres, plays):  answer = []   album = {}  for i, genre, play in zip(range(len(genres)), genres, plays):  if genre not in album:  album[genre] = [-play, []]  else:  # 장르별 재생횟수 합산  album[genre][0] -= play  # 곡 고유번호 최대힙에 저장  heapq.heappush(album[genre][1], [-play, i])   sort_album = []  for genre in album:  # 가장 많이 재생된 첫번째 곡 선별  play1 = heapq.heappop(album[genre][1])   # 1곡만 수록된 경우  if not album[genre][1]:  sort_album.append(play1)  continue   # 가장 많이 재생된 두번째 곡 선별  play2 = heapq.heappop(album[genre][1])   # 장르별 재생횟수 및 곡 고유번호 합산  sort_album.append([album[genre][0], play1[1], play2[1]])   # 장르별 가장 많이 재생된 횟수 내림차순 정렬  sort_album.sort(key=lambda x: x[0])   for genre_album in sort_album:  answer.extend(genre_album[1:])   return answer 문제풀이: 62분\n2022-04-10\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.08ms, 10.3MB\n  ","date":"December 20, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/algorithm/programmers/2021-12-20-algorithm-programmers-python-level3/","summary":"다단계 칫솔 판매 분류 : 2021 Dev-Matching: 웹 백엔드 개발자(상반기)\n문제 링크\n방법1 def solution(enroll, referral, seller, amount):  answer = []   data = {\u0026#39;center\u0026#39;: {\u0026#39;amount\u0026#39;: 0,\u0026#39;parent\u0026#39;: None}}  for i in range(len(enroll)):  data[enroll[i]] = {  \u0026#39;amount\u0026#39;: 0,  \u0026#39;parent\u0026#39;: referral[i] if referral[i] != \u0026#39;-\u0026#39; else \u0026#39;center\u0026#39;  }   for i in range(len(seller)):  sell = seller[i]  price = amount[i] * 100  data[sell][\u0026#39;amount\u0026#39;] += price-price//10  price = price//10   while data[sell][\u0026#39;parent\u0026#39;] and price:  sell = data[sell][\u0026#39;parent\u0026#39;]  if sell == \u0026#39;center\u0026#39;:  data[sell][\u0026#39;amount\u0026#39;] += price  break  data[sell][\u0026#39;amount\u0026#39;] += price-price//10  price = price//10   del data[\u0026#39;center\u0026#39;]  for value in data.","tags":["algorithm","programmers","python"],"title":"Programmers Python (level 3)"},{"categories":["Go","fcm"],"contents":" Firebase Cloud Messaging(FCM)은 firebase에서 무료로 메시지 전송할 수 있는 교차 플랫폼 메시징 솔루션이다.\n최대 4,000바이트의 페이로드를 클라이언트 앱에 전송할 수 있다.\n아래의 예제는 Go언어 기반의 백엔드 서버 예시이며 fcm token이 이미 발급받았다는 가정하에 진행된다.\n 1. 라이브러리 설치 \u0026gt; go get firebase.google.com/go/v4 \u0026gt; go get google.golang.org/api  2. Firebase APP 초기화 사용자 인증 정보 제공의 안내에 따라 서비스 계정의 비공개 키 파일을 다운받는다.\n해당 파일에는 다음과 같은 정보가 있다.\n파일명은 serviceAccountKey.json라고 가정한다.\n{  \u0026#34;type\u0026#34;: \u0026#34;service_account\u0026#34;,  \u0026#34;project_id\u0026#34;: \u0026#34;[project_id]\u0026#34;,  \u0026#34;private_key_id\u0026#34;: \u0026#34;[private_key_id]\u0026#34;,  \u0026#34;private_key\u0026#34;: \u0026#34;[private_key]\u0026#34;,  \u0026#34;client_email\u0026#34;: \u0026#34;[client_email]\u0026#34;,  \u0026#34;client_id\u0026#34;: \u0026#34;[client_id]\u0026#34;,  \u0026#34;auth_uri\u0026#34;: \u0026#34;https://accounts.google.com/o/oauth2/auth\u0026#34;,  \u0026#34;token_uri\u0026#34;: \u0026#34;https://oauth2.googleapis.com/token\u0026#34;,  \u0026#34;auth_provider_x509_cert_url\u0026#34;: \u0026#34;https://www.googleapis.com/oauth2/v1/certs\u0026#34;,  \u0026#34;client_x509_cert_url\u0026#34;: \u0026#34;[client_x509_cert_url]\u0026#34; } Firebase APP 초기화\nvar ( \tclient *messaging.Client \tctx context.Context = context.Background() )  func initApp() { \tvar err error  \ttype AccountKey struct { \tProjectID string `json:\u0026#34;project_id\u0026#34;` \t} \taccountkey := AccountKey{}  \tserviceAccountKeyPath := \u0026#34;./serviceAccountKey.json\u0026#34;  \tkeyFile, err := ioutil.ReadFile(serviceAccountKeyPath) \tif err != nil { \tlog.Print(\u0026#34;[initApp] setConfig error :\u0026#34;, err) \t} \tif err := json.Unmarshal(keyFile, \u0026amp;accountkey); err != nil { \tlog.Print(\u0026#34;[initApp] getConfig error :\u0026#34;, err) \t}  \topt := option.WithCredentialsFile(serviceAccountKeyPath) \tconfig := \u0026amp;firebase.Config{ProjectID: accountkey.ProjectID}  \tapp, err := firebase.NewApp(ctx, config, opt) \tif err != nil { \tlog.Fatalln(\u0026#34;[initApp] initializing app error :\u0026#34;, err) \t}  \t// Obtain a messaging.Client from the App. \tclient, err = app.Messaging(ctx) \tif err != nil { \tlog.Fatalln(\u0026#34;[initApp] getting Messaging client error :\u0026#34;, err) \t} }  3. 특정 기기에 메시지 전송 func sendNotification(title string, body string, fcmToken string) {  \t// This registration token comes from the client FCM SDKs. \tregistrationToken := fcmToken  \tnotification := \u0026amp;messaging.Notification{ \tTitle: title, \tBody: body, \t}  \t// See documentation on defining a message payload. \tmessage := \u0026amp;messaging.Message{ \tData: map[string]string{ \t\u0026#34;Type\u0026#34;: title, \t\u0026#34;Content\u0026#34;: body, \t}, \tToken: registrationToken, \tNotification: notification, \t}  \tresponse, err := client.Send(ctx, message) \tif err != nil { \tfmt.Println(\u0026#34;[sendNotification] client.Send error :\u0026#34;, err, registrationToken) \t} \t_ = response }  4. 여러 기기에 메시지 전송 호출당 최대 500개의 기기 등록 토큰을 지정할 수 있다.\nfunc sendNotifications(title string, body string, fcmTokens []string) { \t// fcm tokens \tregistrationTokens := fcmTokens  \tnotification := \u0026amp;messaging.Notification{ \tTitle: title, \tBody: body, \t}  \tmessage := \u0026amp;messaging.MulticastMessage{ \tData: map[string]string{ \t\u0026#34;Type\u0026#34;: title, \t\u0026#34;Content\u0026#34;: body, \t}, \tTokens: registrationTokens, \tNotification: notification, \t}  \tbr, err := client.SendMulticast(ctx, message) \tif err != nil { \tpanic(err) \t}  \tfmt.Println(\u0026#34;[sendNotifications] \u0026#34;, br.SuccessCount, \u0026#34; messages were sent successfully, \u0026#34;, br.FailureCount, \u0026#34; messages fail count\u0026#34;)  \tif br.FailureCount \u0026gt; 0 { \tvar failedTokens []string \tfor idx, resp := range br.Responses { \tif !resp.Success { \t// The order of responses corresponds to the order of the registration tokens. \tfailedTokens = append(failedTokens, registrationTokens[idx]) \t} \t}  \tfmt.Printf(\u0026#34;[sendNotifications] List of tokens that caused failures: %v\\n\u0026#34;, failedTokens) \t} } firebase 서버 상황에 따라 Push 알림 수신까지 수초~수분 걸릴 수 있다.\n 5. 예시코드 Git golang-fcm-push\n 참고(Reference)  Firebase 클라우드 메시징 특정 기기에 메시지 전송 여러 기기에 메시지 전송  ","date":"December 18, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-12-18-golang-fcm-backend/","summary":"Firebase Cloud Messaging(FCM)은 firebase에서 무료로 메시지 전송할 수 있는 교차 플랫폼 메시징 솔루션이다.\n최대 4,000바이트의 페이로드를 클라이언트 앱에 전송할 수 있다.\n아래의 예제는 Go언어 기반의 백엔드 서버 예시이며 fcm token이 이미 발급받았다는 가정하에 진행된다.\n 1. 라이브러리 설치 \u0026gt; go get firebase.google.com/go/v4 \u0026gt; go get google.golang.org/api  2. Firebase APP 초기화 사용자 인증 정보 제공의 안내에 따라 서비스 계정의 비공개 키 파일을 다운받는다.\n해당 파일에는 다음과 같은 정보가 있다.","tags":["go","fcm"],"title":"golang fcm(firebase cloud messaging) push 메세지 사용법"},{"categories":["Go","PostgreDB"],"contents":" golang에서 postgre데이터 베이스의 SQL 생성, 수정, 읽기, 삭제 기능의 간단한 사용법이다.\npostgreDB가 이미 설치되어 있다는 전제하에 진행한다.\n 로컬 설정 : PostgreDB 설치 도커 이미지 : PostgreDB, pgadmin4 도커 설치 방법   1. 라이브러리 설치 go version : 1.17\n\u0026gt; go get github.com/lib/pq  2. 테이블 구조 postgreDB에 아래와 같은 구조의 User 테이블이 선언된 상태로 진행한다.\nCREATE TABLE user (  id SERIAL PRIMARY KEY,  name VARCHAR(20),  age INT );  3. DB 설정 초기화 package main  import ( \t\u0026#34;database/sql\u0026#34; \t\u0026#34;fmt\u0026#34;  \t_ \u0026#34;github.com/lib/pq\u0026#34; )  // User 스키마 또는 User 테이블구조 type User struct { \tId int \tName string \tAge int }  var ( \tdb *sql.DB )  // DB 설정 func InitDB() { \thost := \u0026#34;localhost\u0026#34; \tport := 5432 \tname := \u0026#34;TEST\u0026#34; \tuser := \u0026#34;test_onwer\u0026#34; \tpassword := \u0026#34;1234\u0026#34;  \tpsqlconn := fmt.Sprintf(\u0026#34;host=%s port=%d dbname=%s user=%s password=%s sslmode=disable\u0026#34;, \thost, port, name, user, password)  \tvar err error \tdb, err = sql.Open(\u0026#34;postgres\u0026#34;, psqlconn) \tif err != nil { \tpanic(err) \t} }  // DB 연결테스트 func ConnectTest() { \terr := db.Ping() \tif err != nil { \tpanic(err) \t} }  func main() { \tInitDB()  \tConnectTest()  \tdefer db.Close() }  4. create 데이터 생성\n Prepare : 다중쿼리나 실행을 위한 구문을 생성 QueryRow : 준비된 쿼리 구문을 입력받은 인자로 실행 Scan : 데이터베이스로 반환받은 columns 읽기  func Create(name string, age int) { \tsqlStatement := `INSERT INTO user_test (name, age) VALUES ($1, $2) returning id` \tstmt, err := db.Prepare(sqlStatement)  \tvar id int64 \terr = stmt.QueryRow(name, age).Scan(\u0026amp;id) \tif err != nil { \tpanic(err) \t} \tfmt.Println(\u0026#34;create id :\u0026#34;, id) }  func main() { \tInitDB()  \tCreate(\u0026#34;foo\u0026#34;, 10) \tCreate(\u0026#34;bar\u0026#34;, 20)  \tdefer db.Close() } create 결과\ncreate id : 1 create id : 2  5. read 데이터 조회\nfunc Read(userId int) { \tsqlStatement := `SELECT \u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34; FROM \u0026#34;user_test\u0026#34; WHERE $1 = \u0026#34;id\u0026#34;` \trows, err := db.Query(sqlStatement, userId) \tif err != nil { \tpanic(err) \t} \tdefer rows.Close()  \tvar id int \tvar name string \tvar age int \tfor rows.Next() { \terr := rows.Scan(\u0026amp;id, \u0026amp;name, \u0026amp;age) \tif err != nil { \tpanic(err) \t}  \tfmt.Printf(\u0026#34;id: %d, name: %v, age: %d\\n\u0026#34;, id, name, age) \t} }  func main() { \tInitDB()  \tRead(1)  \tdefer db.Close() } read 결과\nid: 1, name: foo, age: 10  6. update 데이터 수정\nfunc Update(id int64, user User) { \tsqlStatement := `UPDATE user SET name=$2, age=$3 WHERE id=$1`  \tres, err := db.Exec(sqlStatement, id, user.Name, user.Age) \tif err != nil { \tpanic(err) \t}  \trowsAffected, err := res.RowsAffected() \tif err != nil { \tpanic(err) \t}  \tfmt.Printf(\u0026#34;Total rows/record affected %v\\n\u0026#34;, rowsAffected) }  func main() { \tInitDB()  \tUpdate(1, User{Name: \u0026#34;foo1\u0026#34;, Age: 21}) \tRead(1)  \tdefer db.Close() } update 결과\nTotal rows/record affected 1 id: 1, name: foo1, age: 21  7. delete 데이터 삭제\nfunc Delete(id int64) { \tsqlStatement := `DELETE FROM user WHERE id=$1`  \tres, err := db.Exec(sqlStatement, id) \tif err != nil { \tpanic(err) \t}  \trowsAffected, err := res.RowsAffected() \tif err != nil { \tfmt.Println(\u0026#34;Error while checking the affected rows.\u0026#34;, err) \t} else { \tfmt.Println(\u0026#34;Total rows/record affected\u0026#34;, rowsAffected) \t} }  func main() { \tInitDB()  \tDelete(2)  \tdefer db.Close() } delete 결과\nTotal rows/record affected 1  8. 예시코드 Git golang-postgredb-crud\n 참고(Reference)  GoLang PostgreSQL Example  ","date":"December 16, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-12-16-golang-postgredb-crud/","summary":"golang에서 postgre데이터 베이스의 SQL 생성, 수정, 읽기, 삭제 기능의 간단한 사용법이다.\npostgreDB가 이미 설치되어 있다는 전제하에 진행한다.\n 로컬 설정 : PostgreDB 설치 도커 이미지 : PostgreDB, pgadmin4 도커 설치 방법   1. 라이브러리 설치 go version : 1.17\n\u0026gt; go get github.com/lib/pq  2. 테이블 구조 postgreDB에 아래와 같은 구조의 User 테이블이 선언된 상태로 진행한다.\nCREATE TABLE user (  id SERIAL PRIMARY KEY,  name VARCHAR(20),  age INT );  3.","tags":["go","postgredb"],"title":"golang postgreDB CURD"},{"categories":["Django","crontab"],"contents":" django-crontab 라이브러리는 OS의 cron/crontab 서비스를 사용하는것으로 해당 서비스 설치가 되지 않았다면 별도로 설치를 해야함.\n windows 환경에서는 docker를 설치하여 진행   1. 라이브러리 설치 $ pip install django-crontab  2. django 설정   임의의 app 디렉터리내 cron.py 생성 아래의 함수를 작성한다.\n 반복 실행할 임의의 함수 선언 def hello_every_minute():  print(\u0026#34;hello world\u0026#34;)     settings.py\n django_crontab 앱 추가 INSTALLED_APPS = [  \u0026#39;django_crontab\u0026#39;,  ... ]  CRONJOBS 변수 선언  첫번째 매개변수 : 실행주기 설정으로 기존 cron 사용법(분,시,일,월,요일)과 동일하다.  * * * * * : 매분마다 실행 */10 * * * * : 10분마다 실행 0 * * * * : 매시간마다 실행 0 0 * * * : 자정마다 실행   두번째 매개변수 : 반복 실행할 함수 세번째 매개변수 : cron 실행로그 저장 경로 (선택사항)  ... CRONJOBS = [  (\u0026#39;* * * * *\u0026#39;, \u0026#39;app.cron.hello_every_minute\u0026#39;, \u0026#39;\u0026gt;\u0026gt; /app/log/cron.log\u0026#39;), ]  crontab 프로젝트의 settings 파일 경로 지정 ... CRONTAB_DJANGO_SETTINGS_MODULE = \u0026#39;project.settings\u0026#39;      3. crontab 명령어   cron 작업스케줄 추가\n$ python manage.py crontab add  Starting periodic command scheduler: cron. adding cronjob: (2d7f1e3059afc75b51927955cb7ccb92) -\u0026gt; (\u0026rsquo;* * * * *\u0026rsquo;, \u0026lsquo;app.cron.hello_every_minute\u0026rsquo;, \u0026lsquo;\u0026raquo; /app/log/cron.log\u0026rsquo;)\n   cron 작업스케줄 조회\n$ python manage.py crontab show  Currently active jobs in crontab:\n2d7f1e3059afc75b51927955cb7ccb92 -\u0026gt; (\u0026rsquo;* * * * *\u0026rsquo;, \u0026lsquo;app.cron.hello_every_minute\u0026rsquo;, \u0026lsquo;\u0026raquo; /app/log/cron.log\u0026rsquo;)\n   cron 작업스케줄 삭제\n$ python manage.py crontab remove  removing cronjob: (2d7f1e3059afc75b51927955cb7ccb92) -\u0026gt; (\u0026rsquo;* * * * *\u0026rsquo;, \u0026lsquo;app.cron.hello_every_minute\u0026rsquo;, \u0026lsquo;\u0026raquo; /app/log/cron.log\u0026rsquo;)\n    4. 실행 결과   crontab 실행 후 해당 경로의 log 파일 확인\n$ cat cron.log  hello\n    5. Docker-compose 사용시 설정   dockerfile 설정\n... RUN apt-get update \u0026amp;\u0026amp; apt-get -y install --no-install-recommends cron ...   docker-compose 설정\nservices: django: ... command: bash -c \u0026#34; service cron start \u0026amp;\u0026amp; python3 manage.py crontab add\u0026#34;    6. Docker-compose 실행   이미지 빌드 및 컨테이너 백그라운드 실행\n$ docker-compose -f docker-compose.yml up -d --build    7. 예시코드 Git django-crontab\n참고(Reference)  Docs Django-Crontab 활용방법  ","date":"December 9, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-12-09-django-corntab-guide/","summary":"django-crontab 라이브러리는 OS의 cron/crontab 서비스를 사용하는것으로 해당 서비스 설치가 되지 않았다면 별도로 설치를 해야함.\n windows 환경에서는 docker를 설치하여 진행   1. 라이브러리 설치 $ pip install django-crontab  2. django 설정   임의의 app 디렉터리내 cron.py 생성 아래의 함수를 작성한다.\n 반복 실행할 임의의 함수 선언 def hello_every_minute():  print(\u0026#34;hello world\u0026#34;)     settings.py\n django_crontab 앱 추가 INSTALLED_APPS = [  \u0026#39;django_crontab\u0026#39;,  .","tags":["django","crontab"],"title":"Django crontab 라이브러리 사용법"},{"categories":["Python"],"contents":" python 언어에서 대용량 json 읽기/쓰기 성능은 사용방법과 라이브러리에 따라서 성능 차이가 있다.\n테스트 기준은 동일한 json 파일을 100번씩 반복 실행하였다.\njson 라이브러리의 파일 읽기/쓰기 모두 byte 모드가 상대적으로 빠르다.\n 라이브러리 버전\n python : 3.8.10 ujson : 5.1.0 orjson : 3.6.5   1. json ========================= json_r = 0.045 sec json_w_dump = 0.186 sec json_w_dumps = 0.065 sec ========================= json_rb = 0.034 sec json_wb_dumps = 0.055 sec 1.1. read with open(\u0026#39;github.json\u0026#39;, \u0026#34;r\u0026#34;) as json_file:  data = json.load(json_file) 1.2. write_dump json.dump 함수는 ASCII 모드에서만 동작한다.\nwith open(\u0026#39;github_w_dump.json\u0026#39;, \u0026#34;w\u0026#34;) as json_file:  json.dump(data, json_file) 1.3. write_dumps with open(\u0026#39;github_w_dumps.json\u0026#39;, \u0026#34;w\u0026#34;) as json_file:  data = json.dumps(data)  json_file.write(data) 1.4. read byte with open(\u0026#39;github.json\u0026#39;, \u0026#34;rb\u0026#34;) as json_file:  data = json.load(json_file) 1.5. write byte dumps with open(\u0026#39;github_wb_dumps.json\u0026#39;, \u0026#34;wb\u0026#34;) as json_file:  data = json.dumps(data).encode(\u0026#39;utf-8\u0026#39;)  json_file.write(data)  2. ujson UltraJSON은 파이썬 3.7버전이상을 지원하는 순수 C언어로 작성된 고속 JSON 인코더 및 디코더이다.\n========================== ujson_r = 0.052 sec ujson_w_dumps = 0.060 sec ========================== ujson_rb = 0.037 sec ujson_wb_dumps = 0.049 sec 2.1. read with open(\u0026#39;github.json\u0026#39;, \u0026#34;r\u0026#34;) as json_file:  data = ujson.loads(json_file.read()) 2.2. write dumps with open(\u0026#39;github_w_dumps.json\u0026#39;, \u0026#34;w\u0026#34;) as json_file:  data = ujson.dumps(data)  json_file.write(data) 2.3. read byte with open(\u0026#39;github.json\u0026#39;, \u0026#34;rb\u0026#34;) as json_file:  data = ujson.load(json_file) 2.4. write byte dumps with open(\u0026#39;github_wb_dumps.json\u0026#39;, \u0026#34;wb\u0026#34;) as json_file:  data = ujson.dumps(data).encode(\u0026#39;utf-8\u0026#39;)  json_file.write(data)  3. orjson orjson은 파이썬 3.7버전이상을 지원하는 가장 빠르고 정확한 파이썬 JSON 라이브러리이다.\n=========================== orjson_r = 0.038 sec orjson_w_dumps = 0.049 sec =========================== orjson_rb = 0.024 sec orjson_wb_dumps = 0.035 sec 3.1. read with open(\u0026#39;github.json\u0026#39;, \u0026#34;r\u0026#34;) as json_file:  data = orjson.loads(json_file.read()) 3.2. write dumps with open(\u0026#39;github_w_dumps.json\u0026#39;, \u0026#34;w\u0026#34;) as json_file:  data = orjson.dumps(data).decode(\u0026#39;utf-8\u0026#39;)  json_file.write(data) 3.3. read byte with open(\u0026#39;github.json\u0026#39;, \u0026#34;rb\u0026#34;) as json_file:  data = orjson.loads(json_file.read()) 3.4. write byte dumps with open(\u0026#39;github_wb_dumps.json\u0026#39;, \u0026#34;wb\u0026#34;) as json_file:  data = orjson.dumps(data)  json_file.write(data)  4. banchmark 성능은 orjson \u0026gt; ujson \u0026gt; json 순으로 빠르다.\n   Library read (ms) write (ms) vs. orjson     orjson 0.024 0.035 1.00   ujson 0.037 0.049 1.45   json 0.034 0.055 1.50    아래 결과는 orjson 라이브러리에서 안내하는 banchmark로 데이터 형식에 따른 성능 차이가 있다.\nThis measures serializing the github.json fixture as compact (52KiB) or pretty (64KiB):\n   Library compact (ms) pretty (ms) vs. orjson     orjson 0.06 0.07 1.0   ujson 0.18 0.19 2.8   rapidjson 0.22     simplejson 0.35 1.49 21.4   json 0.36 1.19 17.2     5. 예시코드 Git python-json-read-write-performance\n 참고(Reference)  Benchmark of Python JSON libraries orjson  ","date":"December 6, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-12-06-python-json-read-write-performance/","summary":"python 언어에서 대용량 json 읽기/쓰기 성능은 사용방법과 라이브러리에 따라서 성능 차이가 있다.\n테스트 기준은 동일한 json 파일을 100번씩 반복 실행하였다.\njson 라이브러리의 파일 읽기/쓰기 모두 byte 모드가 상대적으로 빠르다.\n 라이브러리 버전\n python : 3.8.10 ujson : 5.1.0 orjson : 3.6.5   1. json ========================= json_r = 0.045 sec json_w_dump = 0.186 sec json_w_dumps = 0.065 sec ========================= json_rb = 0.034 sec json_wb_dumps = 0.055 sec 1.1. read with open(\u0026#39;github.","tags":["python"],"title":"python json 파일 읽기/쓰기 성능"},{"categories":["Django","oauth","google"],"contents":"django restframework 기반의 구글(google) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\nGoogle Cloud Platform에서 로그인에 사용하는 환경변수를 설정하고 진행한다.\n 1. 로그인 환경변수 설정 1.1. 프로젝트 생성   Google Cloud Platform에서 [프로젝트 만들기] 메뉴로 간다.   프로젝트 이름을 지정하고 [만들기] 클릭한다.\n  1.2. 사용자 인증 정보 설정   [사용자 인증 정보] → [사용자 인증 정보 만들기] → [OAuth 클라이언트 ID] 선택\n  애플리케이션 유형: 웹 애플리케이션 선택 후 앱 이름 지정\n  승인된 자바스크립트 원본: 로그인 테스트 서버 주소입력\n  승인된 리디렉션 URI: 로그인시 콜백주소 입력\n  생성된 클라이언트ID, 보안 비밀번호를 확인한다.\n  1.3. oauth 동의화면 구성   [OAuth 동의 화면] → [외부] → [만들기] 클릭\n  앱 이름: 사용자에게 노출된 앱 이름 지정\n  사용자 지원 이메일, 애플리케이션 홈페이지, 개발자 연락처 정보 입력 후 [저장 후 계속] 클릭한다.\n  사용자 최초 접속시 정보제공 동의항목 지정을 위해 [범위 추가 또는 삭제] 클릭한다.\n  이메일 주소를 받기위해 userinfo.email 항목을 체크하고 업데이트 클릭한다.\n  설정된 정보 제공항목을 확인하고 [저장 후 계속] 클릭한다.\n  테스트 사용자를 추가하고 [저장 후 계속] 클릭한다.\n   2. google 로그인 변수 설정 import os  GOOGLE_CONFIG = {  \u0026#34;GOOGLE_CLIENT_ID\u0026#34; : 클라이언트ID,  \u0026#34;GOOGLE_REDIRECT_URI\u0026#34;: \u0026#34;http://localhost:8000/oauth/google/login/callback/\u0026#34;,  \u0026#34;GOOGLE_SECRET\u0026#34; : 클라이언트 보안 비밀번호, }   google_login_url = \u0026#34;https://accounts.google.com/o/oauth2/v2/auth\u0026#34; google_scope = \u0026#34;https://www.googleapis.com/auth/userinfo.email\u0026#34; google_token_url = \u0026#34;https://oauth2.googleapis.com/token\u0026#34; google_profile_url = \u0026#34;https://www.googleapis.com/oauth2/v2/tokeninfo\u0026#34;  google_login_url: 로그인 페이지 주소 google_scope: 사용자에게 제공받을 정보항목 google_token_url: 엑세스 토큰 발급받기 위한 주소 google_profile_url: 프로필 정보 조회를 위한 주소  3. google 로그인 페이지 사용자가 로그인 테스트 서버로 접속시 redirect URI를 반환한다.\nclass GoogleLoginView(APIView):  permission_classes = (AllowAny,)   def get(self, request):  \u0026#39;\u0026#39;\u0026#39; google code 요청 \u0026#39;\u0026#39;\u0026#39;  client_id = GOOGLE_CONFIG[\u0026#39;GOOGLE_CLIENT_ID\u0026#39;]  redirect_uri = GOOGLE_CONFIG[\u0026#39;GOOGLE_REDIRECT_URI\u0026#39;]  uri = f\u0026#34;{google_login_url}?client_id={client_id}\u0026amp;redirect_uri={redirect_uri}\u0026amp;scope={google_scope}\u0026amp;response_type=code\u0026#34;   res = redirect(uri)  return res 4. google Callback 함수 사용자가 oauth 로그인시 code 검증 및 로그인 처리한다.\nclass GoogleCallbackView(APIView):  permission_classes = (AllowAny,)   @swagger_auto_schema(query_serializer=CallbackUserInfoSerializer)  def get(self, request):  \u0026#39;\u0026#39;\u0026#39; google access_token 요청 및 user_info 요청 \u0026#39;\u0026#39;\u0026#39;  data = request.query_params.copy()   # access_token 발급 요청  code = data.get(\u0026#39;code\u0026#39;)  if not code:  return Response(status=status.HTTP_400_BAD_REQUEST)   request_data = {  \u0026#39;client_id\u0026#39;: GOOGLE_CONFIG[\u0026#39;GOOGLE_CLIENT_ID\u0026#39;],  \u0026#39;client_secret\u0026#39;: GOOGLE_CONFIG[\u0026#39;GOOGLE_SECRET\u0026#39;],  \u0026#39;code\u0026#39;: code,  \u0026#39;grant_type\u0026#39;: \u0026#39;authorization_code\u0026#39;,  \u0026#39;redirect_uri\u0026#39;: GOOGLE_CONFIG[\u0026#39;GOOGLE_REDIRECT_URI\u0026#39;],  }  token_res = requests.post(google_token_url, data=request_data)   token_json = token_res.json()  access_token = token_json[\u0026#39;access_token\u0026#39;]   if not access_token:  return Response(status=status.HTTP_400_BAD_REQUEST)   # google 회원정보 요청  query_string = {  \u0026#39;access_token\u0026#39;: access_token  }  user_info_res = requests.get(google_profile_url, params=query_string)  user_info_json = user_info_res.json()  if (user_info_res.status_code != 200) or (not user_info_json):  return Response(status=status.HTTP_400_BAD_REQUEST)   social_type = \u0026#39;google\u0026#39;  social_id = f\u0026#34;{social_type}_{user_info_json.get(\u0026#39;user_id\u0026#39;)}\u0026#34;  user_email = user_info_json.get(\u0026#39;email\u0026#39;)   \u0026#39;\u0026#39;\u0026#39; # 회원가입 및 로그인 처리 알고리즘 추가필요 \u0026#39;\u0026#39;\u0026#39;   # 테스트 값 확인용  res = {  \u0026#39;social_type\u0026#39;: social_type,  \u0026#39;social_id\u0026#39;: social_id,  \u0026#39;user_email\u0026#39;: user_email,  }  response = Response(status=status.HTTP_200_OK)  response.data = res  return res  5. 로그인  웹서버에서 설정한 google oauth 로그인 페이지로 접근하면 사전에 설정한 리다이렉트 URI로 접근하는데 설정에 문제가 없다면 google 로그인 페이지로 접속된다.   참고(Reference)  OAuth 2.0을 사용하여 Google API에 액세스 웹 서버 애플리케이션에 OAuth 2.0 사용  ","date":"November 22, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-11-22-django-oauth-google/","summary":"django restframework 기반의 구글(google) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\nGoogle Cloud Platform에서 로그인에 사용하는 환경변수를 설정하고 진행한다.\n 1. 로그인 환경변수 설정 1.1. 프로젝트 생성   Google Cloud Platform에서 [프로젝트 만들기] 메뉴로 간다.   프로젝트 이름을 지정하고 [만들기] 클릭한다.\n  1.2. 사용자 인증 정보 설정   [사용자 인증 정보] → [사용자 인증 정보 만들기] → [OAuth 클라이언트 ID] 선택\n  애플리케이션 유형: 웹 애플리케이션 선택 후 앱 이름 지정","tags":["django","oauth","google"],"title":"Django 소셜로그인(oauth) google 연동"},{"categories":["Django","oauth","naver"],"contents":"django restframework 기반의 네이버(naver) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n네이버 개발자 사이트에서 로그인에 사용하는 환경변수를 설정하고 진행한다.\n 1. 로그인 환경변수 설정 1.1. 애플리케이션 생성 및 웹 로그인 설정 네이버 개발자 사이트 가입하고 아래의 과정을 진행한다.\n  [Application] → [애플리케이션 등록] → 애플리케이션 이름 지정 → [사용 API] 네이버 로그인 선택한다.\n  사용자 제공 정보 선택에서 [이메일 주소]를 필수로 선택한다.(회원가입 확인 용도로 사용예정)\n  서비스 환경의 PC 웹을 선택한다.\n  서비스 URL 과 로그인 Callback URL을 작성하고 [등록하기]를 클릭한다.\n  생성된 앱을 확인할 수 있고, 해당 앱을 클릭하여 정보를 확인한다.\n  네이버 로그인연동에 사용할 Client ID, Client Secret를 확인한다.\n  테스트 계정을 추가하고 싶다면 해당 앱 메뉴의 멤버관리에서 추가할 수 있다.\n   2. naver 로그인 변수 설정 import os  NAVER_CONFIG = {  \u0026#34;NAVER_CLIENT_ID\u0026#34;: Client ID,  \u0026#34;NAVER_REDIRECT_URI\u0026#34;: \u0026#34;http://localhost:8000/oauth/naver/login/callback/\u0026#34;,  \u0026#34;NAVER_CLIENT_SECRET\u0026#34;: Client Secret,  \u0026#34;STATE\u0026#34; : 임의의 랜덤코드, }  naver_login_url = \u0026#34;https://nid.naver.com/oauth2.0/authorize\u0026#34; naver_token_url = \u0026#34;https://nid.naver.com/oauth2.0/token\u0026#34; naver_profile_url = \u0026#34;https://openapi.naver.com/v1/nid/me\u0026#34;  naver_login_url: 로그인 페이지 주소 naver_token_url: 엑세스 토큰 발급받기 위한 주소 naver_profile_url: 프로필 정보 조회를 위한 주소   3. naver 로그인 페이지 사용자가 로그인 테스트 서버로 접속시 redirect URI를 반환한다.\nclass NaverLoginView(APIView):  permission_classes = (AllowAny,)   def get(self, request):  \u0026#39;\u0026#39;\u0026#39; naver code 요청 \u0026#39;\u0026#39;\u0026#39;  client_id = NAVER_CONFIG[\u0026#39;NAVER_CLIENT_ID\u0026#39;]  redirect_uri = NAVER_CONFIG[\u0026#39;NAVER_REDIRECT_URI\u0026#39;]  state = NAVER_CONFIG[\u0026#39;STATE\u0026#39;]   uri = f\u0026#34;{naver_login_url}?client_id={client_id}\u0026amp;redirect_uri={redirect_uri}\u0026amp;state={state}\u0026amp;response_type=code\u0026#34;  res = redirect(uri)  return res uri 파라미터 설명\n response_type: 인증 과정에 대한 내부 구분값으로 \u0026lsquo;code\u0026rsquo;로 전송해야 함 client_id: 애플리케이션 등록 시 발급받은 Client ID 값 redirect_uri: 애플리케이션을 등록 시 입력한 Callback URL 값으로 URL 인코딩을 적용한 값 state: 사이트 간 요청 위조(cross-site request forgery) 공격을 방지하기 위해 애플리케이션에서 생성한 상태 토큰값으로 URL 인코딩을 적용한 값을 사용   4. naver Callback 함수 사용자가 oauth 로그인시 code 검증 및 로그인 처리한다.\nclass NaverCallbackView(APIView):  permission_classes = (AllowAny,)   @swagger_auto_schema(query_serializer=CallbackUserCSRFInfoSerializer)  def get(self, request):  \u0026#39;\u0026#39;\u0026#39; naver access_token 요청 및 user_info 요청 \u0026#39;\u0026#39;\u0026#39;  data = request.query_params.copy()   # access_token 발급 요청  code = data.get(\u0026#39;code\u0026#39;)  user_state = data.get(\u0026#39;state\u0026#39;)  if (not code) or (user_state != NAVER_CONFIG[\u0026#39;STATE)\u0026#39;]:  return Response(status=status.HTTP_400_BAD_REQUEST)   request_data = {  \u0026#39;grant_type\u0026#39;: \u0026#39;authorization_code\u0026#39;,  \u0026#39;client_id\u0026#39;: NAVER_CONFIG[\u0026#39;NAVER_CLIENT_ID\u0026#39;],  \u0026#39;client_secret\u0026#39;: NAVER_CONFIG[\u0026#39;NAVER_CLIENT_SECRET\u0026#39;],  \u0026#39;code\u0026#39;: code,  \u0026#39;state\u0026#39;: user_state,  }  token_headers = {  \u0026#39;Content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded;charset=utf-8\u0026#39;  }  token_res = requests.post(naver_token_url, data=request_data, headers=token_headers)   token_json = token_res.json()  access_token = token_json.get(\u0026#39;access_token\u0026#39;)   if not access_token:  return Response(status=status.HTTP_400_BAD_REQUEST)  access_token = f\u0026#34;Bearer {access_token}\u0026#34; # \u0026#39;Bearer \u0026#39; 마지막 띄어쓰기 필수   # naver 회원정보 요청  auth_headers = {  \u0026#34;X-Naver-Client-Id\u0026#34;: NAVER_CONFIG[\u0026#39;NAVER_CLIENT_ID\u0026#39;],  \u0026#34;X-Naver-Client-Secret\u0026#34;: NAVER_CONFIG[\u0026#39;NAVER_CLIENT_SECRET\u0026#39;],  \u0026#34;Authorization\u0026#34;: access_token,  \u0026#34;Content-type\u0026#34;: \u0026#34;application/x-www-form-urlencoded;charset=utf-8\u0026#34;,  }  user_info_res = requests.get(naver_profile_url, headers=auth_headers)  user_info_json = user_info_res.json()  user_info = user_info_json.get(\u0026#39;response\u0026#39;)  if not user_info:  return Response(status=status.HTTP_400_BAD_REQUEST)   social_type = \u0026#39;naver\u0026#39;  social_id = f\u0026#34;{social_type}_{user_info.get(\u0026#39;id\u0026#39;)}\u0026#34;  user_email = user_info.get(\u0026#39;email\u0026#39;)   \u0026#39;\u0026#39;\u0026#39; # 회원가입 및 로그인 처리 알고리즘 추가필요 \u0026#39;\u0026#39;\u0026#39;   # 테스트 값 확인용  res = {  \u0026#39;social_type\u0026#39;: social_type,  \u0026#39;social_id\u0026#39;: social_id,  \u0026#39;user_email\u0026#39;: user_email,  }  response = Response(status=status.HTTP_200_OK)  response.data = res  return res  5. 로그인   웹서버에서 설정한 naver oauth 로그인 페이지로 접근하면 사전에 설정한 리다이렉트 URI로 접근하는데 설정에 문제가 없다면 naver 로그인 페이지로 접속된다.\n  해당 로그인 테스트 서버에서 개인정보 제공에 대한 동의화면이 나오며 동의시 Callback 함수로 넘어가 회원가입 및 로그인 과정을 거치게 된다.\n   참고(Reference)  네이버 로그인 API 명세 네이버 회원 프로필 조회 API 명세  ","date":"November 12, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-11-12-django-oauth-naver/","summary":"django restframework 기반의 네이버(naver) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n네이버 개발자 사이트에서 로그인에 사용하는 환경변수를 설정하고 진행한다.\n 1. 로그인 환경변수 설정 1.1. 애플리케이션 생성 및 웹 로그인 설정 네이버 개발자 사이트 가입하고 아래의 과정을 진행한다.\n  [Application] → [애플리케이션 등록] → 애플리케이션 이름 지정 → [사용 API] 네이버 로그인 선택한다.\n  사용자 제공 정보 선택에서 [이메일 주소]를 필수로 선택한다.(회원가입 확인 용도로 사용예정)\n  서비스 환경의 PC 웹을 선택한다.","tags":["django","oauth","naver"],"title":"Django 소셜로그인(oauth) naver 연동"},{"categories":["Django","oauth","kakao"],"contents":"django restframework 기반의 카카오(kakao) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n카카오 개발자 사이트에서 로그인에 사용하는 환경변수를 설정하고 진행한다.\n 1. 로그인 환경변수 설정 1.1. 애플리케이션 생성   카카오 개발자 사이트에 가입후 [내 애플리케이션] → [애플리케이션 추가하기] 클릭한다.\n  앱 아이콘(선택), 앱 이름, 사업자명을 등록한다.\n  정상적으로 등록되어 애플리케이션 목록에서 확인할 수 있다.\n  1.2. 웹 로그인 설정   생성한 앱을 클릭하면 키 정보를 확인하고 [플랫폼 설정하기] 클릭한다.\n   예시코드 kakao login 기능에서는 REST API 키, Admin 키를 사용한다.  네이티브 앱 키: Android, iOS SDK에서 API를 호출할 때 사용한다. JavaScript 키: JavaScript SDK에서 API를 호출할 때 사용한다. REST API 키: REST API를 호출할 때 사용한다. Admin 키: 모든 권한을 갖고 있는 키다. 노출이 되지 않도록 주의가 필요하다.     웹 로그인기능을 테스트하기 때문에 [Web 플랫폼 등록] 메뉴로 간다.\n  로그인 테스트에 사용할 사이트 도메인 주소를 등록한다.\n http://localhost 주소 사용이 가능하다.    저장하면 위와 같이 사이트 도메인 주소가 등록된다. [등록하러 가기] 메뉴로 간다.\n  카카오 로그인 API를 사용하기 위해서는 활성화 설정 ON 상태로 수정한다. 그 다음 로그인 [Redirect URI 등록] 메뉴로 이동한다.\n  로그인 테스트 서버에서 받을 Redirect URI를 등록한다.\n  위의 그림처럼 Redirect URI가 등록되면 kakao 개발자 사이트에서 로그인하기 위한 모든 준비가 끝났다.\n   2. Kakao 로그인 변수 설정 import os  KAKAO_CONFIG = {  \u0026#34;KAKAO_REST_API_KEY\u0026#34;: REST API 키,  \u0026#34;KAKAO_REDIRECT_URI\u0026#34;: \u0026#34;http://localhost:8000/oauth/kakao/login/callback/\u0026#34;,  \u0026#34;KAKAO_CLIENT_SECRET_KEY\u0026#34;: Admin 키, }  kakao_login_uri = \u0026#34;https://kauth.kakao.com/oauth/authorize\u0026#34; kakao_token_uri = \u0026#34;https://kauth.kakao.com/oauth/token\u0026#34; kakao_profile_uri = \u0026#34;https://kapi.kakao.com/v2/user/me\u0026#34;  REST API 키: REST API를 호출할 때 사용한다. Admin 키: 모든 권한을 갖고 있는 키다. 노출이 되지 않도록 주의가 필요하다. kakao_login_uri: 로그인 페이지 주소 kakao_token_uri: 엑세스 토큰 발급받기 위한 주소 kakao_profile_uri: 프로필 정보 조회를 위한 주소   3. Kakao 로그인 페이지 사용자가 로그인 테스트 서버로 접속시 redirect URI를 반환한다.\nclass KakaoLoginView(APIView):  permission_classes = (AllowAny,)   def get(self, request):  \u0026#39;\u0026#39;\u0026#39; kakao code 요청 \u0026#39;\u0026#39;\u0026#39;  client_id = KAKAO_CONFIG[\u0026#39;KAKAO_REST_API_KEY\u0026#39;]  redirect_uri = KAKAO_CONFIG[\u0026#39;KAKAO_REDIRECT_URI\u0026#39;]   uri = f\u0026#34;{kakao_login_uri}?client_id={client_id}\u0026amp;redirect_uri={redirect_uri}\u0026amp;response_type=code\u0026#34;   res = redirect(uri)  return res uri 파라미터 설명\n client_id: 앱 REST API 키 redirect_uri: 인가 코드가 리다이렉트될 URI response_type: code로 고정   4. Kakao Callback 함수 사용자가 oauth 로그인시 code 검증 및 로그인 처리한다.\nclass KakaoCallbackView(APIView):  permission_classes = (AllowAny,)   def get(self, request):  \u0026#39;\u0026#39;\u0026#39; kakao access_token 요청 및 user_info 요청 \u0026#39;\u0026#39;\u0026#39;  data = request.query_params.copy()   # access_token 발급 요청  code = data.get(\u0026#39;code\u0026#39;)  if not code:  return Response(status=status.HTTP_400_BAD_REQUEST)   request_data = {  \u0026#39;grant_type\u0026#39;: \u0026#39;authorization_code\u0026#39;,  \u0026#39;client_id\u0026#39;: KAKAO_CONFIG[\u0026#39;KAKAO_REST_API_KEY\u0026#39;],  \u0026#39;redirect_uri\u0026#39;: KAKAO_CONFIG[\u0026#39;KAKAO_REDIRECT_URI\u0026#39;],  \u0026#39;client_secret\u0026#39;: KAKAO_CONFIG[\u0026#39;KAKAO_CLIENT_SECRET_KEY\u0026#39;],  \u0026#39;code\u0026#39;: code,  }  token_headers = {  \u0026#39;Content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded;charset=utf-8\u0026#39;  }  token_res = requests.post(kakao_token_uri, data=request_data, headers=token_headers)   token_json = token_res.json()  access_token = token_json.get(\u0026#39;access_token\u0026#39;)   if not access_token:  return Response(status=status.HTTP_400_BAD_REQUEST)  access_token = f\u0026#34;Bearer {access_token}\u0026#34; # \u0026#39;Bearer \u0026#39; 마지막 띄어쓰기 필수   # kakao 회원정보 요청  auth_headers = {  \u0026#34;Authorization\u0026#34;: access_token,  \u0026#34;Content-type\u0026#34;: \u0026#34;application/x-www-form-urlencoded;charset=utf-8\u0026#34;,  }  user_info_res = requests.get(kakao_profile_uri, headers=auth_headers)  user_info_json = user_info_res.json()   social_type = \u0026#39;kakao\u0026#39;  social_id = f\u0026#34;{social_type}_{user_info_json.get(\u0026#39;id\u0026#39;)}\u0026#34;   kakao_account = user_info_json.get(\u0026#39;kakao_account\u0026#39;)  if not kakao_account:  return Response(status=status.HTTP_400_BAD_REQUEST)  user_email = kakao_account.get(\u0026#39;email\u0026#39;)   \u0026#39;\u0026#39;\u0026#39; # 회원가입 및 로그인 처리 알고리즘 추가필요 \u0026#39;\u0026#39;\u0026#39;   # 테스트 값 확인용  res = {  \u0026#39;social_type\u0026#39;: social_type,  \u0026#39;social_id\u0026#39;: social_id,  \u0026#39;user_email\u0026#39;: user_email,  }  response = Response(status=status.HTTP_200_OK)  response.data = res  return res  5. 로그인   웹서버에서 설정한 kakao oauth 로그인 페이지로 접근하면 사전에 설정한 리다이렉트 URI로 접근하는데 설정에 문제가 없다면 kakao 로그인 페이지로 접속된다.\n   참고(Reference) 카카오 로그인 REST API\n","date":"October 11, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-10-11-django-oauth-kakao/","summary":"django restframework 기반의 카카오(kakao) 인증 로그인 백엔드서버로 별도의 auth관련 라이브러리는 설치하지 않고 구현한다.\n카카오 개발자 사이트에서 로그인에 사용하는 환경변수를 설정하고 진행한다.\n 1. 로그인 환경변수 설정 1.1. 애플리케이션 생성   카카오 개발자 사이트에 가입후 [내 애플리케이션] → [애플리케이션 추가하기] 클릭한다.\n  앱 아이콘(선택), 앱 이름, 사업자명을 등록한다.\n  정상적으로 등록되어 애플리케이션 목록에서 확인할 수 있다.\n  1.2. 웹 로그인 설정   생성한 앱을 클릭하면 키 정보를 확인하고 [플랫폼 설정하기] 클릭한다.","tags":["django","oauth","kakao"],"title":"Django 소셜로그인(oauth) kakao 연동"},{"categories":["Django","Swagger"],"contents":" drf_yasg : REST 프레임워크용 swagger/openAPI 문서 자동화 라이브러리 swagger : 개발자가 REST 웹 서비스를 설계, 빌드, 문서화, 테스트를 도와주는 오픈소스 소프트웨어 프레임워크\ndrf_yasg : 1.20.0 호환버전\n Django Rest Framework : 3.10, 3.11, 3.12 Django : 2.2, 3.0, 3.1 Python : 3.6, 3.7, 3.8, 3.9  라이브러리 설치\npip install -U drf-yasg  1. 프로젝트 생성 환경 : windwos 10\n# 가상환경 생성 및 접속 \u0026gt; python -m venv venv \u0026gt; venv\\Scripts\\activate  # 라이브러리 설치 (venv)\u0026gt; pip install django (venv)\u0026gt; pip install djangorestframework (venv)\u0026gt; pip install drf-yasg  # 프로젝트 및 앱 생성 (venv)\u0026gt; django-admin startproject config . (venv)\u0026gt; django-admin startapp api  2. django 설정 config/settings.py\nstaticfiles앱은 swagger UI css/js 파일 배포용\nINSTALLED_APPS = [  ...  \u0026#39;django.contrib.staticfiles\u0026#39;,  \u0026#39;drf_yasg\u0026#39;,  ... ] config/urls.py\n... from rest_framework.permissions import AllowAny from drf_yasg.views import get_schema_view from drf_yasg import openapi from config import settings ...  schema_view = get_schema_view(  openapi.Info(  title=\u0026#34;Snippets API\u0026#34;,  default_version=\u0026#39;v1\u0026#39;,  description=\u0026#34;Test description\u0026#34;,  terms_of_service=\u0026#34;https://www.google.com/policies/terms/\u0026#34;,  contact=openapi.Contact(name=\u0026#34;tester\u0026#34;, email=\u0026#34;test@test.com\u0026#34;),  license=openapi.License(name=\u0026#34;BSD License\u0026#34;),  ),  public=True,  permission_classes=(AllowAny,), ) ...  # debug 모드일때 swagger api 실행 if settings.DEBUG:  urlpatterns += [  re_path(r\u0026#39;^swagger(?P\u0026lt;format\u0026gt;\\.json|\\.yaml)$\u0026#39;, schema_view.without_ui(cache_timeout=0), name=\u0026#34;schema-json\u0026#34;),  re_path(r\u0026#39;^swagger/$\u0026#39;, schema_view.with_ui(\u0026#39;swagger\u0026#39;, cache_timeout=0), name=\u0026#39;schema-swagger-ui\u0026#39;),  re_path(r\u0026#39;^redoc/$\u0026#39;, schema_view.with_ui(\u0026#39;redoc\u0026#39;, cache_timeout=0), name=\u0026#39;schema-redoc\u0026#39;),  ...  ]  3. 예시코드 3.1. models api/models.py\nfrom django.db import models  # Create your models here.  class Musics(models.Model):  ONE_STAR = 1  TWO_STAR = 2  THREE_STAR = 3  STARS = (  (ONE_STAR, \u0026#39;보통\u0026#39;),  (TWO_STAR, \u0026#39;좋음\u0026#39;),  (THREE_STAR, \u0026#39;매우 좋음\u0026#39;),  )   CATEGORY = (  (\u0026#39;KPOP\u0026#39;, \u0026#39;케이팝\u0026#39;),  (\u0026#39;POP\u0026#39;, \u0026#39;팝송\u0026#39;),  (\u0026#39;CLASSIC\u0026#39;, \u0026#39;클래식\u0026#39;),  (\u0026#39;ETC\u0026#39;, \u0026#39;기타 등등\u0026#39;),  )   id = models.BigAutoField(primary_key=True, verbose_name=\u0026#39;music_id\u0026#39;)  created_at = models.DateTimeField(auto_now_add=True, verbose_name=\u0026#39;생성 날짜\u0026#39;)  updated_at = models.DateTimeField(auto_now=True, verbose_name=\u0026#39;수정 날짜\u0026#39;)  deleted_at = models.DateTimeField(blank=True, null=True, verbose_name=\u0026#39;삭제 날짜\u0026#39;)  singer = models.CharField(null=False, max_length=128, verbose_name=\u0026#39;가수명\u0026#39;)  title = models.CharField(null=False, max_length=128, verbose_name=\u0026#39;곡명\u0026#39;)  category = models.CharField(blank=True, null=True, max_length=32, choices=CATEGORY, verbose_name=\u0026#39;범주\u0026#39;)  star_rating = models.PositiveSmallIntegerField(blank=True, null=True, choices=STARS, default=ONE_STAR, verbose_name=\u0026#39;곡 선호도\u0026#39;)   class Meta:  # abstract = True # sqlite3 사용 시 주석  managed = True  db_table = \u0026#39;musics\u0026#39;  app_label = \u0026#39;api\u0026#39;  ordering = [\u0026#39;star_rating\u0026#39;, ]  verbose_name_plural = \u0026#39;음악\u0026#39; DB 마이그레이션\n(venv)\u0026gt; py manage.py makemigrations (venv)\u0026gt; py manage.py migrate 생성된 sqlite3 파일을 확인할려면 아래 링크에서 프로그램을 다운받아 설치한다. 개인적으로 no installer(portable) 버전을 추천한다.\n DB Browser for SQLite  db.sqlite3\nmusics 테이블 생성된 것을 확인할 수 있다.\n3.2. seializers api/serializers.py\nfrom rest_framework import serializers  from .models import Musics   class MusicSerializer(serializers.ModelSerializer):  def validate(self, data: dict):  return data   class Meta:  model = Musics  fields = \u0026#39;__all__\u0026#39; # 모든 필드 사용  # fields = (\u0026#39;id\u0026#39;, \u0026#39;created_at\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;category\u0026#39;, \u0026#39;star_rating\u0026#39;,) # 특정 필드 지정  class MusicBodySerializer(serializers.Serializer):  singer = serializers.CharField(help_text=\u0026#34;가수명\u0026#34;)  title = serializers.CharField(help_text=\u0026#34;곡 제목\u0026#34;)  category = serializers.ChoiceField(help_text=\u0026#34;곡 범주\u0026#34;, choices=(\u0026#39;KPOP\u0026#39;, \u0026#39;POP\u0026#39;, \u0026#39;CLASSIC\u0026#39;, \u0026#39;ETC\u0026#39;))  star_rating = serializers.ChoiceField(help_text=\u0026#34;1~3 이내 지정 가능. 숫자가 클수록 좋아하는 곡\u0026#34;, choices=(1, 2, 3), required=False)  class MusicQuerySerializer(serializers.Serializer):  title = serializers.CharField(help_text=\u0026#34;곡 제목으로 검색\u0026#34;, required=False)  star_rating = serializers.ChoiceField(help_text=\u0026#34;곡 선호도로 검색\u0026#34;, choices=(1, 2, 3), required=False)  singer = serializers.CharField(help_text=\u0026#34;가수명으로 검색\u0026#34;, required=True)  category = serializers.ChoiceField(help_text=\u0026#34;카테고리로 검색\u0026#34;, choices=(\u0026#39;KPOP\u0026#39;, \u0026#39;POP\u0026#39;, \u0026#39;CLASSIC\u0026#39;, \u0026#39;ETC\u0026#39;), required=False)  created_at = serializers.DateTimeField(help_text=\u0026#34;입력한 날짜를 기준으로 그 이전에 추가된 곡들을 검색\u0026#34;, required=False) 3.3. class views api/views.py\nfrom django.shortcuts import get_object_or_404  from rest_framework import status from rest_framework.views import APIView from rest_framework.response import Response from drf_yasg import openapi from drf_yasg.utils import swagger_auto_schema  from .serializers import *  class MusicListView(APIView):  def get(self, request):  serializer = MusicSerializer(Musics.objects.all(), many=True)   response = Response(data=serializer.data)  return response   @swagger_auto_schema(request_body=MusicBodySerializer) # Request Serializer 지정  def post(self, request):  # 중복 검사 없이 추가  # serializer = MusicSerializer(data=request.data)   # if not serializer.is_valid(raise_exception=False):  # return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)    # serializer.save()  # response = Response(data=serializer.validated_data, status=status.HTTP_201_CREATED)  # return response   # 중복 검사 후 추가  musics = Musics.objects.filter(**request.data)  if musics.exists():  return Response(status=status.HTTP_406_NOT_ACCEPTABLE)   serializer = MusicSerializer(data=request.data, partial=True)  if not serializer.is_valid():  return Response(status=status.HTTP_406_NOT_ACCEPTABLE)   music = serializer.save()   response = Response(data=MusicSerializer(music).data, status=status.HTTP_201_CREATED)  return response   class SearchMusicListView(APIView):  @swagger_auto_schema(query_serializer=MusicQuerySerializer)  def get(self, request):  # filter 조건문 생성  conditions = {  \u0026#39;title__contains\u0026#39;: request.GET.get(\u0026#39;title\u0026#39;, None),  \u0026#39;star_rating\u0026#39;: request.GET.get(\u0026#39;star_rating\u0026#39;, None),  \u0026#39;singer__contains\u0026#39;: request.GET.get(\u0026#39;singer\u0026#39;, None),  \u0026#39;category\u0026#39;: request.GET.get(\u0026#39;category\u0026#39;, None),  \u0026#39;created_at__lte\u0026#39;: request.GET.get(\u0026#39;created_at\u0026#39;, None),  }  conditions = {  key: val for key, val in conditions.items() if val is not None  }   musics = Musics.objects.filter(**conditions)  serializer = MusicSerializer(musics, many=True)  response = Response(data=serializer.data, status=status.HTTP_200_OK)  return response   class MusicView(APIView):  def get_object(self, pk):  return get_object_or_404(Musics, pk=pk)   def get(self, request, pk):  serializer = MusicSerializer(Musics.objects.filter(id=pk), many=True)   response = Response(data=serializer.data, status=status.HTTP_200_OK)  return response   @swagger_auto_schema(  request_body=MusicBodySerializer, # Request Serializer 지정  manual_parameters=[openapi.Parameter(  name=\u0026#39;header_test\u0026#39;, # api 파라미터 이름  in_=openapi.IN_HEADER, # 파라미터 종류 (header = openapi.IN_HEADER)  description=\u0026#34;a header for test\u0026#34;, # 파라미터 설명  type=openapi.TYPE_STRING # header 지정시 필수 선언  )],  )  def put(self, request, pk):  object = self.get_object(pk=pk)  serializer = MusicSerializer(object, data=request.data)   if not serializer.is_valid(raise_exception=False):  return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)   serializer.save()  response = Response(data=serializer.validated_data, status=status.HTTP_200_OK)  return response   def delete(self, request, pk):  object = self.get_object(pk=pk)  object.delete()   response = Response(status=status.HTTP_204_NO_CONTENT)  return response 3.4. urls 관리의 편의성을 위해 각 앱별로 urls.py 설정한다. 앱 내부에서 urls 설정한 경우 프로젝트 urls 설정도 같이 해줘야 한다.\napi/urls.py\nfrom django.urls import path from .views import MusicListView, SearchMusicListView, MusicView, PlayListView, SearchPlayListView urlpatterns = [ path(\u0026#34;music/\u0026#34;, MusicListView.as_view(), name=\u0026#34;musics\u0026#34;), path(\u0026#34;music/search/\u0026#34;, SearchMusicListView.as_view(), name=\u0026#34;music_search\u0026#34;), path(\u0026#34;music/\u0026lt;int:pk\u0026gt;/\u0026#34;, MusicView.as_view(), name=\u0026#34;music\u0026#34;), ] config/urls.py\n... urlpatterns = [  ...  path(\u0026#34;api/\u0026#34;, include(\u0026#34;api.urls\u0026#34;)), ] ... swagger 실행후 웹브라우저에서 localhost:8000/swagger/ 주소로 접속한다.\n(venv)\u0026gt; py manage.py runserver 각 url class view에서 지정한 메서드들이 표시된다.\n 4. Swagger API request 지정 swagger api 메소드에서 특정 입력값을 받기 위해서는 @swagger_auto_schema 데코레이터를 지정해야한다.\n4.1. query_serializer  query string 지정 GET, DELETE Method 용도 메소드 입력값을 request.query_params, request.GET로 받는다. request 데이터를 변경하거나 추가할 경우 copy() 함수로 복사해서 사용해야 한다.  # api/views.py 코드 @swagger_auto_schema(query_serializer=MusicQuerySerializer) def get(self, request):  data = request.query_params.copy()  ...  Serializer는 변수 선언을 통해서 다양한 타입의 변수를 선언할 수 있다. required 설정을 통해 필수입력, 선택입력을 지정한다.(기본값 True)  # api/serializers.py 코드 class MusicQuerySerializer(serializers.Serializer):  title = serializers.CharField(help_text=\u0026#34;곡 제목으로 검색\u0026#34;, required=False)  star_rating = serializers.ChoiceField(help_text=\u0026#34;곡 선호도로 검색\u0026#34;, choices=(1, 2, 3), required=False)  singer = serializers.CharField(help_text=\u0026#34;가수명으로 검색\u0026#34;, required=True)  category = serializers.ChoiceField(help_text=\u0026#34;카테고리로 검색\u0026#34;, choices=(\u0026#39;KPOP\u0026#39;, \u0026#39;POP\u0026#39;, \u0026#39;CLASSIC\u0026#39;, \u0026#39;ETC\u0026#39;), required=False)  created_at = serializers.DateTimeField(help_text=\u0026#34;입력한 날짜를 기준으로 그 이전에 추가된 곡들을 검색\u0026#34;, required=False)  swagger GET 메소드 예시  4.2. request_body  body 지정 POST, PUT Method 용도 메소드 입력값을 request.data, request.POST로 받는다.  # api/views.py 코드 @swagger_auto_schema(request_body=MusicBodySerializer) def post(self, request):  data = request.data.copy()  ...  ModelSerializer는 models.py 에서 지정한 모델의 column을 그대로 사용할 수 있다. Meta 클래스의 fields 설정에 따라 모든 column을 사용하거나 특정 column만 사용할 수 있다.  # api/serializers.py 코드 class MusicSerializer(serializers.ModelSerializer):  class Meta:  model = Musics  fields = \u0026#39;__all__\u0026#39; # 모든 필드 사용  Model 기본키인 id는 id serializer 변수를 직접 지정해야만 사용 가능하다.  # api/serializers.py 코드 class MusicSerializer(serializers.ModelSerializer):  id = serializers.IntegerField(min_value=1, help_text=\u0026#34;ID\u0026#34;)   class Meta:  model = Musics  fields = (\u0026#39;id\u0026#39;, \u0026#39;created_at\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;category\u0026#39;, \u0026#39;star_rating\u0026#39;,) # 응답 필드 지정  swagger POST 메소드 예시  4.3. path value  path value 지정 모든 메소드에서 사용가능하다. urls에서 지정한 변수명으로 입력값을 받는다.  # api/urls.py urlpatterns = [  ...  path(\u0026#34;music/\u0026lt;int:pk\u0026gt;/\u0026#34;, MusicView.as_view(), name=\u0026#34;music\u0026#34;),  class MusicView(APIView):  def delete(self, request, pk):  ...  swagger DELETE 메소드 예시   5. Swagger API response 지정 swagger api 메소드에서 특정 입력값 및 반환형식 지정은 @swagger_auto_schema 데코레이터를 사용한다.\n5.1. responses  swagger 에서 자동으로 HTTP 응답코드에 따른 response 형식을 생성한다. 하지만 상황에 따라 데이터 처리에 사용한 시리얼라이저와 반환값의 형식이 맞지 않는 경우가 생긴다. 이럴때 해당 클래스 메서드에 responses 를 지정하여 HTTP 응답코드에 따른 response 형식을 직접 지정 할 수 있다.  from drf_yasg import openapi ... music_list_response = openapi.Response(\u0026#39;\u0026#39;, MusicSerializer(many=True)) class MusicListView(APIView): @swagger_auto_schema(responses={200: music_list_response}) def get(self, request): serializer = MusicSerializer(Musics.objects.all(), many=True) response = Response(data=serializer.data) return response ... responses 적용 전\nresponses 적용 후\n지정한 MusicSerializer 형식의 list 형태로 Swagger Response 형식이 지정된다.\nTIP\n Swagger Serializer와 데이터 처리 Serializer를 구분하여 작성하는것이 나중에 유지관리를 위해서 편리하다.\n 6. 예시 코드 Git  django-swagger   참고(Reference)  drf-yasg - Yet another Swagger generator drf-yasg-demo drf-yasg를 이용한 Swagger 문서 자동화  ","date":"September 24, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-09-24-django-swagger/","summary":"drf_yasg : REST 프레임워크용 swagger/openAPI 문서 자동화 라이브러리 swagger : 개발자가 REST 웹 서비스를 설계, 빌드, 문서화, 테스트를 도와주는 오픈소스 소프트웨어 프레임워크\ndrf_yasg : 1.20.0 호환버전\n Django Rest Framework : 3.10, 3.11, 3.12 Django : 2.2, 3.0, 3.1 Python : 3.6, 3.7, 3.8, 3.9  라이브러리 설치\npip install -U drf-yasg  1. 프로젝트 생성 환경 : windwos 10\n# 가상환경 생성 및 접속 \u0026gt; python -m venv venv \u0026gt; venv\\Scripts\\activate  # 라이브러리 설치 (venv)\u0026gt; pip install django (venv)\u0026gt; pip install djangorestframework (venv)\u0026gt; pip install drf-yasg  # 프로젝트 및 앱 생성 (venv)\u0026gt; django-admin startproject config .","tags":["django","swagger"],"title":"Django drf_yasg Swagger 기본 사용법"},{"categories":["Go","Learning"],"contents":" 사이트 주소 원본 링크\n한글 번역 링크\n 5. struct, method \u0026amp; interface struct 구조체의 변수 첫글자는 대문자여야한다. (외부에서 사용 가능하도록)\ntype Rectangle struct { \tWidth float64 \tHeight float64 } 구조체 필드이름을 선택적으로 지정할 수 있다.\n{shape: Rectangle{Width: 12, Height: 6}, want: 72.0}, {shape: Circle{Radius: 10}, want: 314.1592653589793}, methods func (receiverName ReceiverType) MethodName(args) r Rectangle 수신자 변수를 유형의 첫 번째 문자로 지정하는 것이 Go의 관례이다.\nfunc (r Rectangle) Area() float64 { \treturn 0 } interface Go에서 인터페이스 자료형은 암시적 이다. 전달하는 유형이 인터페이스가 요청하는 유형과 일치하면 컴파일 된다.\ntype Shape interface { \tArea() float64 } 익명구조 익명구조 예시로 shape와 want라는 두 개의 필드가 있는 []struct를 사용하여 구조체를 선언한다.\nareaTests := []struct { \tshape Shape \twant float64 }{ \t{Rectangle{12, 6}, 72.0}, \t{Circle{10}, 314.1592653589793}, } 예제 코드 struct_method_interface_test.go\npackage main  import ( \t\u0026#34;math\u0026#34; \t\u0026#34;testing\u0026#34; )  type Rectangle struct { \tWidth float64 \tHeight float64 }  func (r Rectangle) Area() float64 { \treturn r.Width * r.Height }  type Circle struct { \tRadius float64 }  func (c Circle) Area() float64 { \treturn math.Pi * c.Radius * c.Radius }  type Triangle struct { \tBase float64 \tHeight float64 }  func (t Triangle) Area() float64 { \treturn (t.Base * t.Height) * 0.5 }  type Shape interface { \tArea() float64 }  func TestArea(t *testing.T) { \tareaTests := []struct { \tname string \tshape Shape \thasArea float64 \t}{ \t{shape: Rectangle{Width: 12, Height: 6}, hasArea: 72.0}, \t{shape: Circle{Radius: 10}, hasArea: 314.1592653589793}, \t{shape: Triangle{Base: 12, Height: 6}, hasArea: 36.0}, \t}  \tfor _, tt := range areaTests { \tgot := tt.shape.Area() \tif got != tt.hasArea { \tt.Errorf(\u0026#34;%#v got %g want %g\u0026#34;, tt.shape, got, tt.hasArea) \t} \t} }  6. pointer \u0026amp; error Pointer 구조체에 대한 포인터는 구조체 포인터 라고 불리고 특별한 역참조에 대한 명시 없이도 자동 역참조가 된다. (*w).balance 와 w.balance 는 같은 의미로 사용된다.\nError 반환되는 에러를 확인하지 않은 코드라인을 확인할 수 있는 라이브러리 설치 go get -u github.com/kisielk/errcheck 실행 명령 : errcheck .\n예제 코드 pointer_error_test.go\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;testing\u0026#34; )  type Bitcoin int  func (b Bitcoin) String() string { \treturn fmt.Sprintf(\u0026#34;%d BTC\u0026#34;, b) }  type Stringer interface { \tString() string }  type Wallet struct { \tbalance Bitcoin }  func (w *Wallet) Deposit(amount Bitcoin) { \tfmt.Printf(\u0026#34;address of balance in Deposit is %v \\n\u0026#34;, \u0026amp;w.balance) \tw.balance += amount }  func (w *Wallet) Balance() Bitcoin { \treturn w.balance }  var ErrInsufficientFunds = errors.New(\u0026#34;cannot withdraw, insufficient funds\u0026#34;)  func (w *Wallet) Withdraw(amount Bitcoin) error { \tif w.balance \u0026lt; amount { \treturn ErrInsufficientFunds \t}  \tw.balance -= amount \treturn nil }  func TestWallet(t *testing.T) { \tt.Run(\u0026#34;Deposit\u0026#34;, func(t *testing.T) { \twallet := Wallet{} \twallet.Deposit(Bitcoin(10)) \tassertBalance(t, wallet, Bitcoin(10)) \t})  \tt.Run(\u0026#34;Withdraw\u0026#34;, func(t *testing.T) { \twallet := Wallet{balance: Bitcoin(20)} \terr := wallet.Withdraw(Bitcoin(10))  \tassertBalance(t, wallet, Bitcoin(10)) \tassertNoError(t, err) \t})  \tt.Run(\u0026#34;Withdraw insufficient funds\u0026#34;, func(t *testing.T) { \tstartingBalance := Bitcoin(20) \twallet := Wallet{startingBalance} \terr := wallet.Withdraw(Bitcoin(100))  \tassertBalance(t, wallet, startingBalance) \tassertError(t, err, ErrInsufficientFunds) \t}) }  func assertBalance(t testing.TB, wallet Wallet, want Bitcoin) { \tt.Helper() \tgot := wallet.Balance()  \tif got != want { \tt.Errorf(\u0026#34;got %q want %q\u0026#34;, got, want) \t} }  func assertNoError(t testing.TB, got error) { \tt.Helper() \tif got != nil { \tt.Fatal(\u0026#34;got an error but didn\u0026#39;t want one\u0026#34;) \t} }  func assertError(t testing.TB, got error, want error) { \tt.Helper() \tif got == nil { \tt.Fatal(\u0026#34;want on error but didn\u0026#39;t get one\u0026#34;) \t}  \tif got != want { \tt.Errorf(\u0026#34;got %q, want %q\u0026#34;, got, want) \t} }  7. map map 맵을 선언하려면 map이라는 키워드로 시작하고 두 개의 타입이 있어야한다.\n첫번째 타입 : key 타입으로 비교 가능한 타입만 사용 가능하다.\n두번째 타입 : value 타입으로 어떤타입이든 사용 가능하다.\nmap은 두 개의 값을 반환하며 두번째 값은 키를 찾는데 성공 여부를 boolean으로 반환한다.\ndefinition, ok := d[word] error Error는 .Error() 메소드를 통해 문자열로 변환될 수 있다.\npointer map의 주소를 전달(\u0026amp;myMap)하지 않고서도 수정할 수 있다\nmap 초기화 방법 var dictionary = map[string]string{}  // OR  var dictionary = make(map[string]string) 예제 코드 dictionary_test.go\n package main  import ( \t\u0026#34;testing\u0026#34; )  const ( \tErrNotFound = DictionaryErr(\u0026#34;could not find the word you were looking for\u0026#34;) \tErrWordExists = DictionaryErr(\u0026#34;cannot add word because it already exists\u0026#34;) \tErrWordDoesNotExist = DictionaryErr(\u0026#34;cannot update word because it does not exist\u0026#34;) )  type DictionaryErr string  func (e DictionaryErr) Error() string { \treturn string(e) }  type Dictionary map[string]string  func (d Dictionary) Search(word string) (string, error) { \tdefinition, ok := d[word] \tif !ok { \treturn \u0026#34;\u0026#34;, ErrNotFound \t} \treturn definition, nil }  func (d Dictionary) Add(word, definition string) error { \t_, err := d.Search(word)  \tswitch err { \tcase ErrNotFound: \td[word] = definition \tcase nil: \treturn ErrWordExists \tdefault: \treturn err \t}  \treturn nil }  func (d Dictionary) Update(word, definition string) error { \t_, err := d.Search(word)  \tswitch err { \tcase ErrNotFound: \treturn ErrWordDoesNotExist \tcase nil: \td[word] = definition \tdefault: \treturn err \t}  \treturn nil }  func (d Dictionary) Delete(word string) { \tdelete(d, word) }  func TestSearch(t *testing.T) { \tdictionary := Dictionary{\u0026#34;test\u0026#34;: \u0026#34;this is just a test\u0026#34;}  \tt.Run(\u0026#34;known word\u0026#34;, func(t *testing.T) { \tgot, _ := dictionary.Search(\u0026#34;test\u0026#34;) \twant := \u0026#34;this is just a test\u0026#34;  \tassertStrings(t, got, want) \t})  \tt.Run(\u0026#34;unknown word\u0026#34;, func(t *testing.T) { \t_, got := dictionary.Search(\u0026#34;unknown\u0026#34;)  \tassertError(t, got, ErrNotFound) \t}) }  func TestAdd(t *testing.T) { \tt.Run(\u0026#34;new word\u0026#34;, func(t *testing.T) { \tdictionary := Dictionary{} \tword := \u0026#34;test\u0026#34; \tdefinition := \u0026#34;this is just a test\u0026#34;  \terr := dictionary.Add(word, definition)  \tassertError(t, err, nil) \tassertDefinition(t, dictionary, word, definition) \t})  \tt.Run(\u0026#34;existing word\u0026#34;, func(t *testing.T) { \tword := \u0026#34;test\u0026#34; \tdefinition := \u0026#34;this is just a test\u0026#34; \tdictionary := Dictionary{word: definition} \terr := dictionary.Add(word, \u0026#34;new test\u0026#34;)  \tassertError(t, err, ErrWordExists) \tassertDefinition(t, dictionary, word, definition) \t}) }  func TestUpdate(t *testing.T) { \tt.Run(\u0026#34;existing word\u0026#34;, func(t *testing.T) { \tword := \u0026#34;test\u0026#34; \tdefinition := \u0026#34;this is just a test\u0026#34; \tnewDefinition := \u0026#34;new definition\u0026#34; \tdictionary := Dictionary{word: definition}  \terr := dictionary.Update(word, newDefinition)  \tassertError(t, err, nil) \tassertDefinition(t, dictionary, word, newDefinition) \t})  \tt.Run(\u0026#34;new word\u0026#34;, func(t *testing.T) { \tword := \u0026#34;test\u0026#34; \tdefinition := \u0026#34;this is just a test\u0026#34; \tdictionary := Dictionary{}  \terr := dictionary.Update(word, definition)  \tassertError(t, err, ErrWordExists) \t}) }  func TestDelete(t *testing.T) { \tword := \u0026#34;test\u0026#34; \tdictionary := Dictionary{word: \u0026#34;test definition\u0026#34;}  \tdictionary.Delete(word)  \t_, err := dictionary.Search(word) \tif err != ErrNotFound { \tt.Errorf(\u0026#34;Expected %q to be deleted\u0026#34;, word) \t} }  func assertStrings(t testing.TB, got, want string) { \tt.Helper()  \tif got != want { \tt.Errorf(\u0026#34;got %q want %q\u0026#34;, got, want) \t} }  func assertError(t testing.TB, got, want error) { \tt.Helper()  \tif got != want { \tt.Errorf(\u0026#34;got %q want %q\u0026#34;, got, want) \t} }  func assertDefinition(t testing.TB, dictionary Dictionary, word, definition string) { \tt.Helper()  \tgot, err := dictionary.Search(word) \tif err != nil { \tt.Fatal(\u0026#34;should find added word :\u0026#34;, err) \t}  \tif definition != got { \tt.Errorf(\u0026#34;got %q want %q\u0026#34;, got, definition) \t} }  8. dependency injection fmt.Printf : 기본적으로 stdout을 사용한다.\nfmt.Fprintf : fmt.Printf와 비슷하지만, 문자열을 보낼 곳 Writer를 가진다.\n특징  프레임워크가 필요하지 않다. 디자인을 지나치게 복잡하게 하지 않는다. 테스트를 용이하게 한다. 범용 함수를 작성할 수 있다.  예제코드 di_test.go\npackage main  import ( \t\u0026#34;bytes\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;io\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;testing\u0026#34; )  func Greet(writer io.Writer, name string) { \tfmt.Fprintf(writer, \u0026#34;Hello, %s\u0026#34;, name) }  func MyGreeterHandler(w http.ResponseWriter, r *http.Request) { \tGreet(w, \u0026#34;world\u0026#34;) }  func TestGreat(t *testing.T) { \tbuffer := bytes.Buffer{} \tGreet(\u0026amp;buffer, \u0026#34;Chris\u0026#34;)  \tgot := buffer.String() \twant := \u0026#34;Hello, Chris\u0026#34;  \tif got != want { \tt.Errorf(\u0026#34;got %q want %q\u0026#34;, got, want) \t} }  func main() { \thttp.ListenAndServe(\u0026#34;:5000\u0026#34;, http.HandlerFunc(MyGreeterHandler)) } 9. mocking 유닛 테스트 용도로 사용한다.\n예제 코드 countdown_test.go\npackage main  import ( \t\u0026#34;bytes\u0026#34; \t\u0026#34;reflect\u0026#34; \t\u0026#34;testing\u0026#34; \t\u0026#34;time\u0026#34; )  const ( \twrite = \u0026#34;write\u0026#34; \tsleep = \u0026#34;sleep\u0026#34; )  type CountdownOperationSpy struct { \tCalls []string }  func (s *CountdownOperationSpy) Sleep() { \ts.Calls = append(s.Calls, sleep) }  func (s *CountdownOperationSpy) Write(p []byte) (n int, err error) { \ts.Calls = append(s.Calls, write) \treturn }  type SpyTime struct { \tdurationSlept time.Duration }  func (s *SpyTime) Sleep(duration time.Duration) { \ts.durationSlept = duration }  func TestCountdown(t *testing.T) { \tt.Run(\u0026#34;prints 3 to Go!\u0026#34;, func(t *testing.T) { \tbuffer := \u0026amp;bytes.Buffer{} \tCountdown(buffer, \u0026amp;CountdownOperationSpy{})  \tgot := buffer.String() \twant := \u0026#34;3\\n2\\n1\\nGo!\u0026#34;  \tif got != want { \tt.Errorf(\u0026#34;got %q want %q\u0026#34;, got, want) \t} \t})  \tt.Run(\u0026#34;sleep before every print\u0026#34;, func(t *testing.T) { \tspySleepPrinter := \u0026amp;CountdownOperationSpy{} \tCountdown(spySleepPrinter, spySleepPrinter)  \twant := []string{ \tsleep, write, \tsleep, write, \tsleep, write, \tsleep, write, \t}  \tif !reflect.DeepEqual(want, spySleepPrinter) { \tt.Errorf(\u0026#34;wanted calls %v got %v\u0026#34;, want, spySleepPrinter.Calls) \t} \t}) }  func TestConfigurableSleeper(t *testing.T) { \tsleepTime := 5 * time.Second  \tspyTime := \u0026amp;SpyTime{} \tsleeper := ConfigurableSleeper{sleepTime, spyTime.Sleep} \tsleeper.Sleep()  \tif spyTime.durationSlept != sleepTime { \tt.Errorf(\u0026#34;should have slept for %v but slept for %v\u0026#34;, sleepTime, spyTime.durationSlept) \t} } main.go\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;io\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;time\u0026#34; )  const ( \tfinalWord = \u0026#34;Go!\u0026#34; \tcountdownStart = 3 )  // Sleeper allows you to put delays. type Sleeper interface { \tSleep() }  // ConfigurableSleeper is an implementation of Sleeper with a defined delay. type ConfigurableSleeper struct { \tduration time.Duration \tsleep func(time.Duration) }  // Sleep will pause execution for the defined Duration. func (c *ConfigurableSleeper) Sleep() { \tc.sleep(c.duration) }  // Countdown prints a countdown from 3 to out with a delay between count provided by Sleeper. func Countdown(out io.Writer, sleeper Sleeper) {  \tfor i := countdownStart; i \u0026gt; 0; i-- { \tsleeper.Sleep() \tfmt.Fprintln(out, i) \t}  \tsleeper.Sleep() \tfmt.Fprint(out, finalWord) }  func main() { \tsleeper := \u0026amp;ConfigurableSleeper{1 * time.Second, time.Sleep} \tCountdown(os.Stdout, sleeper) } ","date":"August 2, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-08-02-golang-learn-go-with-tests/","summary":"사이트 주소 원본 링크\n한글 번역 링크\n 5. struct, method \u0026amp; interface struct 구조체의 변수 첫글자는 대문자여야한다. (외부에서 사용 가능하도록)\ntype Rectangle struct { \tWidth float64 \tHeight float64 } 구조체 필드이름을 선택적으로 지정할 수 있다.\n{shape: Rectangle{Width: 12, Height: 6}, want: 72.0}, {shape: Circle{Radius: 10}, want: 314.1592653589793}, methods func (receiverName ReceiverType) MethodName(args) r Rectangle 수신자 변수를 유형의 첫 번째 문자로 지정하는 것이 Go의 관례이다.\nfunc (r Rectangle) Area() float64 { \treturn 0 } interface Go에서 인터페이스 자료형은 암시적 이다.","tags":["go","learning"],"title":"golang learn-go-with-tests GitBook 정리"},{"categories":["Go","Gopacket"],"contents":" gopacket : 이더넷 어댑터 설명(dev.Description)명칭으로 ethernet 통신하는 라이브러리이다.\n예제 코드 package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net\u0026#34; \t\u0026#34;strings\u0026#34; \t\u0026#34;time\u0026#34;  \t\u0026#34;github.com/google/gopacket\u0026#34; \t\u0026#34;github.com/google/gopacket/layers\u0026#34; \t\u0026#34;github.com/google/gopacket/pcap\u0026#34; )  var ( \tdevice string = \u0026#34;Realtek PCIe GbE Family Controller\u0026#34; \teth_name string \tcurrentIP string \tsnapshot_len int32 = 1522 \tpromiscuous bool = false \terr error \ttimeout time.Duration = 30 * time.Second \thandle *pcap.Handle \tbuffer gopacket.SerializeBuffer \toptions gopacket.SerializeOptions )  func main() { \tdevices, err := pcap.FindAllDevs() \tif err != nil { \tlog.Fatalln(\u0026#34;pcap.FindAllDevs Error :\u0026#34;, err) \t} \tfor _, dev := range devices { \tif device == dev.Description { \tdevice = dev.Name \tcurrentIP = dev.Addresses[1].IP.String() \t// fmt.Println(\u0026#34;dev.Name =\u0026#34;, dev.Name) \t// fmt.Println(\u0026#34;dev.Description =\u0026#34;, dev.Description) \t// fmt.Println(\u0026#34;dev.Addresses =\u0026#34;, currentIP) \t} \t}  \tsrc_mac := get_mac(currentIP)  \t// sender \t// Open device \thandle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout) \tif err != nil { \tlog.Fatal(\u0026#34;pcap.OpenLive Error :\u0026#34;, err) \t} \tdefer handle.Close()  \t// Send raw bytes over wire \trawBytes := []byte{0x33, 0x22, 0x11, 0x00}  \tethernetLayer := \u0026amp;layers.Ethernet{ \tEthernetType: 0x888E, \tSrcMAC: src_mac, \tDstMAC: net.HardwareAddr{0x11, 0x22, 0x33, 0x44, 0x55, 0x66}, \t}  \toptions := gopacket.SerializeOptions{ \tComputeChecksums: true, \tFixLengths: true, \t}  \t// And create the packet with the layers \tbuffer = gopacket.NewSerializeBuffer() \tgopacket.SerializeLayers(buffer, options, \tethernetLayer, \tgopacket.Payload(rawBytes), \t) \toutgoingPacket := buffer.Bytes()  \t// Send our packet \terr = handle.WritePacketData(outgoingPacket) \tif err != nil { \tlog.Fatal(\u0026#34;handle.WritePacketData Error :\u0026#34;, err) \t} \tfmt.Println(outgoingPacket)  \t// receiver \t// 패킷 스니핑 설정 Open device \tpromiscuous := true \thandle, err := pcap.OpenLive(deviceName, snapshotLength, promiscuous, timeout) \tif err != nil { \tfmt.Println(err) \t} \tdefer handle.Close()  \t// BPF Filter 문법에 맞는 필터구문 \tfilter := \u0026#34;ether src host \u0026#34; + systemConfig.BoardMacAddress \tif err := handle.SetBPFFilter(filter); err != nil { \tfmt.Println(err) \t}  \tpacketSource := gopacket.NewPacketSource(handle, handle.LinkType())  \tfor packet := range packetSource.Packets() { \tfmt.Printf(packet.Data()) \t} }  func get_mac(currentIP string) net.HardwareAddr { \tvar currentNetworkHardwareName string  \tinterfaces, _ := net.Interfaces() \tfor _, interf := range interfaces { \tif addrs, err := interf.Addrs(); err == nil { \tfor _, addr := range addrs { \t// only interested in the name with current IP address \tif strings.Contains(addr.String(), currentIP) { \tcurrentNetworkHardwareName = interf.Name \tbreak \t} \t} \t} \t}  \t// fmt.Println(\u0026#34;currentNetworkHardwareName =\u0026#34;, currentNetworkHardwareName)  \t// extract the hardware information base on the interface name \tnetInterface, err := net.InterfaceByName(currentNetworkHardwareName) \tif err != nil { \tlog.Fatal(\u0026#34;net.InterfaceByName Error :\u0026#34;, err) \t}  \tmacAddress := netInterface.HardwareAddr  \t// fmt.Println(\u0026#34;Hardware name : \u0026#34;, netInterface.Name) \t// fmt.Println(\u0026#34;MAC address : \u0026#34;, macAddress)  \treturn macAddress } ","date":"July 29, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-07-29-golang-gopacket/","summary":"gopacket : 이더넷 어댑터 설명(dev.Description)명칭으로 ethernet 통신하는 라이브러리이다.\n예제 코드 package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net\u0026#34; \t\u0026#34;strings\u0026#34; \t\u0026#34;time\u0026#34;  \t\u0026#34;github.com/google/gopacket\u0026#34; \t\u0026#34;github.com/google/gopacket/layers\u0026#34; \t\u0026#34;github.com/google/gopacket/pcap\u0026#34; )  var ( \tdevice string = \u0026#34;Realtek PCIe GbE Family Controller\u0026#34; \teth_name string \tcurrentIP string \tsnapshot_len int32 = 1522 \tpromiscuous bool = false \terr error \ttimeout time.Duration = 30 * time.","tags":["go","gopacket"],"title":"golang gopacket 라이브러리를 이용한 통신"},{"categories":["Python","Windows"],"contents":" 운영체제 : windows 10\n설치환경 : python 3.8.8, powershell 7.1\n 1. WMI WMI(Windows Management Instrumentation)는 Windows 시스템 관리를 위한 다양한 정보를 일관되게 표시하는 기술이다. WMI가 표시하는 정보의 양이 제한되어 있기 때문에 WMI 개체에 액세스하기 위한 PowerShell cmdlet인 Get-CimInstance 개체 가져오기 도구를 사용한다.\n해당 WMI 개체 정보 조회\nGet-CimInstance -ClassName (WMI 개체이름) | select *    WMI 개체이름 정보     Win32_OperatingSystem 운영체제 및 메모리 정보   Win32_Processor CPU 정보   Win32_PhysicalMemory 물리 메모리 정보   Win32_DiskDrive 물리 디스크 정보   Win32_LogicalDisk 논리 디스크 정보   Win32_VideoController 그래픽카드 정보    Get-CimInstance 옵션 매개변수로 Select-Object사용하면 WMI 클래스 인스턴스에서 반환되는 속성을 선택할 수 있다. Get-CimInstance의 -Property 매개 변수는 PowerShell로 반환되는 개체가 아니라 WMI 클래스 인스턴스에서 반환되는 속성을 제한하기 때문에 추가 데이터가 반환된다.\nGet-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property Caption WMI 클래스 인스턴스에서 반환되는 모든 옵션 조회\nGet-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property *  2. python에서 powershell 명령 실행 방법 2.1 콘솔 명령 실행 import subprocess import json cmd = \u0026#34;Get-CimInstance -Class Win32_OperatingSystem\u0026#34; subprocess.Popen(f\u0026#39;powershell.exe {cmd}\u0026#39;) 2.2. 실행결과 반환 디코딩을 하지 않으면 바이트 문자열로 나열되서 반환된다.\ncmd = \u0026#34;Get-CimInstance -Class Win32_OperatingSystem\u0026#34; result = subprocess.Popen(f\u0026#39;powershell.exe {cmd}\u0026#39;, stdout=subprocess.PIPE) print(result)  result = result.stdout.read() print(result) 결과\n\u0026lt;subprocess.Popen object at 0x0000025175617B50\u0026gt;  b\u0026#39;\\r\\nSystemDirectory Organization BuildNumber RegisteredUser SerialNumber Version \\r\\n--------------- ------------ ----------- -------------- ------------ ------- \\r\\nC:\\\\Windows\\\\system32 19000 UserName 00000-00000 10.0\\r\\n\\r\\n\\r\\n\u0026#39; 2.3.실행결과 디코딩 cmd = \u0026#34;Get-CimInstance -Class Win32_OperatingSystem\u0026#34; result = subprocess.Popen(f\u0026#39;powershell.exe {cmd}\u0026#39;, stdout=subprocess.PIPE) result = result.stdout.read().decode(\u0026#39;cp949\u0026#39;)  print(result) 결과\nSystemDirectory Organization BuildNumber RegisteredUser SerialNumber Version --------------- ------------ ----------- -------------- ------------ ------- C:\\Windows\\system32 19000 UserName 00000-00000 10.0 2.4. json 형식의 문자열 형태로 반환 cmd = \u0026#34;Get-CimInstance -Class Win32_OperatingSystem | Select-Object -Property Caption, OSArchitecture, Version\u0026#34; result = subprocess.Popen(f\u0026#39;powershell.exe {cmd}| ConvertTo-JSON\u0026#39;, stdout=subprocess.PIPE) result = result.stdout.read().decode(\u0026#39;cp949\u0026#39;)  print(result) print(type(result)) 결과\n{  \u0026#34;Caption\u0026#34;: \u0026#34;Microsoft Windows 10 Pro\u0026#34;,  \u0026#34;OSArchitecture\u0026#34;: \u0026#34;64비트\u0026#34;,  \u0026#34;Version\u0026#34;: \u0026#34;10.0\u0026#34; } \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 2.5. dict 형태로 반환 cmd = \u0026#34;Get-CimInstance -Class Win32_OperatingSystem | Select-Object -Property Caption, OSArchitecture, Version\u0026#34; result = subprocess.Popen(f\u0026#39;powershell.exe {cmd}| ConvertTo-JSON\u0026#39;, stdout=subprocess.PIPE) result = ast.literal_eval(result.stdout.read().decode(\u0026#39;cp949\u0026#39;))  print(result) print(type(result)) 결과\n{\u0026#39;Caption\u0026#39;: \u0026#39;Microsoft Windows 10 Pro\u0026#39;, \u0026#39;OSArchitecture\u0026#39;: \u0026#39;64비트\u0026#39;, \u0026#39;Version\u0026#39;: \u0026#39;10.0.19042\u0026#39;} \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; 2.6. int형으로 반환 cmd = \u0026#34;(Get-CimInstance -ClassName Win32_Processor).LoadPercentage\u0026#34; result = subprocess.Popen(f\u0026#39;powershell.exe {cmd}\u0026#39;, stdout=subprocess.PIPE) result = result.stdout.read().decode(\u0026#39;cp949\u0026#39;).strip() result = int(result)  # 공백 or 에러를 반환하는 경우 예외처리 if result.isnumeric():  result = int(result) else:  result = None  print(result) print(type(result)) 결과\n23 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;  3. power shell 명령어 예시 3.1. 운영체제 및 메모리 사용량 정보 조회 Get-CimInstance -Class Win32_OperatingSystem | Select-Object -Property Caption, OSArchitecture, Version, TotalVisibleMemorySize, FreePhysicalMemory 3.2. CPU 정보 및 사용량 조회 Get-CimInstance -ClassName Win32_Processor | Select-Object -Property Name, MaxClockSpeed, LoadPercentage 3.2.1. CPU 사용량 조회 (Get-CimInstance -ClassName Win32_Processor).LoadPercentage 3.3. GPU 정보 조회  AdapterRAM 필드의 자료형이 dword(uint32)형으로 최대 4GB 까지 표현한다.  Get-CimInstance -ClassName Win32_VideoController | Select-Object -Property Name, AdapterRAM  qwMemorySize 필드 자료형은 qword(uint64)형으로 최대 약 16 EB(엑사바이트) 까지 표현한다.  (Get-ItemProperty -Path \u0026#34;HKLM:\\SYSTEM\\ControlSet001\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\0*\u0026#34; -Name HardwareInformation.qwMemorySize -ErrorAction SilentlyContinue).\u0026#34;HardwareInformation.qwMemorySize\u0026#34; 3.3.1. GPU 메모리 사용량 조회 (((Get-Counter \u0026#39;\\GPU Process Memory(*)\\Local Usage\u0026#39;).CounterSamples | where CookedValue).CookedValue | measure -sum).sum 3.4. 메모리 정보 조회 Get-CimInstance -ClassName Win32_PhysicalMemory | Select-Object -Property Manufacturer, PartNumber, Speed, Capacity 3.5. 디스크 정보 조회 Get-CimInstance -ClassName Win32_DiskDrive | Select-Object -Property Index, Model, Size 3.6. 볼륨 정보 조회  DriveType 3 (WMI에서 고정 하드 디스크에 사용하는 값)  Get-CimInstance -ClassName Win32_LogicalDisk -Filter \u0026#39;DriveType=3\u0026#39; | Select-Object -Property Name, FileSystem, Size, FreeSpace  4. 예시코드 Git monitoring_windows\n 참고(Reference)  컴퓨터에 대한 정보 수집 WMI 개체 가져오기(Get-CimInstance)  powershell 명령어 사용법   개체의 일부 선택(Select-Object)  ","date":"June 16, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-06-16-python-windows10-monitoring/","summary":"운영체제 : windows 10\n설치환경 : python 3.8.8, powershell 7.1\n 1. WMI WMI(Windows Management Instrumentation)는 Windows 시스템 관리를 위한 다양한 정보를 일관되게 표시하는 기술이다. WMI가 표시하는 정보의 양이 제한되어 있기 때문에 WMI 개체에 액세스하기 위한 PowerShell cmdlet인 Get-CimInstance 개체 가져오기 도구를 사용한다.\n해당 WMI 개체 정보 조회\nGet-CimInstance -ClassName (WMI 개체이름) | select *    WMI 개체이름 정보     Win32_OperatingSystem 운영체제 및 메모리 정보   Win32_Processor CPU 정보   Win32_PhysicalMemory 물리 메모리 정보   Win32_DiskDrive 물리 디스크 정보   Win32_LogicalDisk 논리 디스크 정보   Win32_VideoController 그래픽카드 정보    Get-CimInstance 옵션 매개변수로 Select-Object사용하면 WMI 클래스 인스턴스에서 반환되는 속성을 선택할 수 있다.","tags":["python","windows"],"title":"python을 이용한 windows10 시스템 정보 및 사용량 모니터링"},{"categories":["Django"],"contents":" 1. 라이브러리 설치 1.1. server 라이브러리 설치 pip install python-socketio 1.2. client 라이브러리 설치 pip install \u0026#34;python-socketio[client]\u0026#34;  2. Server django settings projectname/wsgi.py\n...  import socketio from appname.views import sio # sio code path ... # application = get_wsgi_application()  sio.register_namespace(TransferNamespace(\u0026#39;/transfer\u0026#39;)) django_app = get_wsgi_application() application = socketio.WSGIApp(sio, django_app) appname/views.py\nimport socketio  sio = socketio.Server(async_mode=\u0026#39;threading\u0026#39;, async_handlers=True, ping_interval=60)  class TransferNamespace(socketio.Namespace):  def on_connect(self, sid: str, environ: dict):  \u0026#39;\u0026#39;\u0026#39; 클라이언트 접속 \u0026#39;\u0026#39;\u0026#39;  print(f\u0026#34;connect address = {environ[\u0026#39;REMOTE_ADDR\u0026#39;]}, sid = {sid}\u0026#34;)   def on_disconnect(self, sid: str):  \u0026#39;\u0026#39;\u0026#39; 클라이언트 접속 종료 \u0026#39;\u0026#39;\u0026#39;  print(f\u0026#34;disconnect Client disconnected = {sid}\u0026#34;)   def send_event(self, sid: str):  \u0026#39;\u0026#39;\u0026#39; 특정 sid 클라이언트에 이벤트 전송 \u0026#39;\u0026#39;\u0026#39;  print(\u0026#34;send_event\u0026#34;)  self.emit(\u0026#39;send_event\u0026#39;, data, room=sid, namespace=\u0026#39;/transfer\u0026#39;)   def on_client_response(self, sid):  \u0026#39;\u0026#39;\u0026#39; 클라이언트에서 전송한 이벤트 \u0026#39;\u0026#39;\u0026#39;  print(f\u0026#34;on_client_response sid = {sid}\u0026#34;)  3. Client settings client.py\nimport socketio  sio = socketio.Client()  @sio.event def connect():  print(\u0026#34;server connect\u0026#34;)  # 서버로부터 이벤트 데이터 수신 @sio.on(\u0026#39;send_event\u0026#39;) def on_send_event():  print(\u0026#34;receive send_eventdata\u0026#34;)   client_response()  # 서버로 데이터 송신 @sio.event def client_response():  print(\u0026#34;client_response\u0026#34;)  sio.emit(\u0026#39;client_response\u0026#39;)  @sio.event def disconnect():  print(\u0026#34;disconnect From Server\u0026#34;)  def socketio_run():  # sio.connect(\u0026#39;http://host:port\u0026#39;, namespaces=[\u0026#39;/namespace\u0026#39;])  sio.connect(url=\u0026#39;http://127.0.0.1:8080\u0026#39;, transports=\u0026#39;polling\u0026#39;, namespaces=\u0026#39;/transfer\u0026#39;)  print(\u0026#34;socketio server start\u0026#34;)   sio.wait() ","date":"June 11, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-06-11-django-websocket-using-channels-library-guide/","summary":"1. 라이브러리 설치 1.1. server 라이브러리 설치 pip install python-socketio 1.2. client 라이브러리 설치 pip install \u0026#34;python-socketio[client]\u0026#34;  2. Server django settings projectname/wsgi.py\n...  import socketio from appname.views import sio # sio code path ... # application = get_wsgi_application()  sio.register_namespace(TransferNamespace(\u0026#39;/transfer\u0026#39;)) django_app = get_wsgi_application() application = socketio.WSGIApp(sio, django_app) appname/views.py\nimport socketio  sio = socketio.Server(async_mode=\u0026#39;threading\u0026#39;, async_handlers=True, ping_interval=60)  class TransferNamespace(socketio.Namespace):  def on_connect(self, sid: str, environ: dict):  \u0026#39;\u0026#39;\u0026#39; 클라이언트 접속 \u0026#39;\u0026#39;\u0026#39;  print(f\u0026#34;connect address = {environ[\u0026#39;REMOTE_ADDR\u0026#39;]}, sid = {sid}\u0026#34;)   def on_disconnect(self, sid: str):  \u0026#39;\u0026#39;\u0026#39; 클라이언트 접속 종료 \u0026#39;\u0026#39;\u0026#39;  print(f\u0026#34;disconnect Client disconnected = {sid}\u0026#34;)   def send_event(self, sid: str):  \u0026#39;\u0026#39;\u0026#39; 특정 sid 클라이언트에 이벤트 전송 \u0026#39;\u0026#39;\u0026#39;  print(\u0026#34;send_event\u0026#34;)  self.","tags":["django"],"title":"Django socketio 라이브러리 활용한 통신"},{"categories":["Python"],"contents":" 설치버전 : python 3.8.8\n1. 클래스 인스턴스 변수(self)와 함수 매개변수 처리속도 차이 1.1. 예제 코드 import timeit  class CheckTime:  def __init__(self):  self.a = 0  self.b = 0  self.c = 0   def process_self(self):  self.a + self.b + self.c   def process_argument(self, a, b, c):  a + b + c   def get_time(self):  self.a = 1  self.b = 2  self.c = 3   def test1():  self.process_self()  process_self_time = timeit.Timer(stmt=test1).repeat(number=1000000)   a = self.a  b = self.b  c = self.c  def test2():  self.process_argument(a, b, c)  process_argument_time = timeit.Timer(stmt=test2).repeat(number=1000000)   print(f\u0026#34;Self value process = {process_self_time}sec\u0026#34;)  print(f\u0026#34;Argument value process = {process_argument_time}sec\u0026#34;)  checkTime = CheckTime() checkTime.get_time() 1.2. 결과 Self value process = [0.1872074, 0.1858419, 0.1853262, 0.1846126, 0.1845041] sec Argument value process = [0.147073, 0.1466343, 0.1458009, 0.1452553, 0.1468781] sec 결론 : 함수 매개변수는 클래스 인스턴스 변수를 사용하는 것보다 약 35 % 빠름\n이유\n 사전 조회없이 위치 인수를 전달하고 액세스 할 수 있기 때문이다. 클래스 인스턴스 변수에는 할당과 액세스 모두에 대한 사전 검색이 필요하다. 함수 매개변수는 이름으로 색인이 지정된 사전이 아니라 배열에 저장되고 색인으로 액세스된다.  2. 클래스 인스턴스 변수(self)와 함수 로컬변수 처리속도 차이 2.1. 예제 코드 import timeit  class CheckTime:  def __init__(self):  self.a = 0  self.b = 0  self.c = 0   def get_time(self):  self.a = 1  self.b = 2  self.c = 3   def test1():  for _ in range(1000000):  self.a + self.b + self.c  process_self_time = timeit.Timer(stmt=test1).repeat(number=1)   a = self.a  b = self.b  c = self.c  def test2():  for _ in range(1000000):  a + b + c  process_argument_time = timeit.Timer(stmt=test2).repeat(number=1)   print(f\u0026#34;Self value process = {process_self_time}sec\u0026#34;)  print(f\u0026#34;Argument value process = {process_argument_time}sec\u0026#34;)  checkTime = CheckTime() checkTime.get_time() 2.2. 결과 Self value process = [0.0758095, 0.0757394, 0.0756023, 0.0746107, 0.0749142] sec Argument value process = [0.0332198, 0.0332008, 0.0332592, 0.0331674, 0.0332719] sec 결론 : 함수 로컬변수는 클래스 인스턴스 변수를 사용하는 것보다 약 120 % 빠름\n이유 : 클래스 인스턴스 변수에는 할당과 액세스 모두에 대한 사전 검색이 필요하다.\n참고(Reference)  python - 인스턴스 변수 및 함수 인수의 처리 속도  ","date":"May 24, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-05-24-python-class-instance-variable-and-function-local-variable-performance/","summary":"설치버전 : python 3.8.8\n1. 클래스 인스턴스 변수(self)와 함수 매개변수 처리속도 차이 1.1. 예제 코드 import timeit  class CheckTime:  def __init__(self):  self.a = 0  self.b = 0  self.c = 0   def process_self(self):  self.a + self.b + self.c   def process_argument(self, a, b, c):  a + b + c   def get_time(self):  self.a = 1  self.b = 2  self.","tags":["python"],"title":"클래스 인스턴스 변수(self)와 함수 로컬변수 처리속도차이"},{"categories":["Python","Opencv"],"contents":" 설치버전 : opencv-python 4.5.1.48\n docs url  라이브러리 설치\npip install opencv-python 라이브러리 import\nimport cv2  이미지 파일 읽기  cv2.imread(filename[, flags]) -\u0026gt; retval  img = cv2.imread(image_full_path)    매개변수 이름 설명     filename 로드할 파일 이름   flags cv2 값을 사용할 수 있는 플래그     이미지 파일 저장  cv2.imwrite(filename, img[, params]) -\u0026gt; retval 이미지 형식은 파일 이름 확장자에 따라 선택됨  cv2.imwrite(image_full_path, img)  메모리 버퍼로 인코딩  이미지를 ext형식으로 변환하여 메모리 버퍼로 인코딩 cv2.imencode(ext, img[, params]) -\u0026gt; refval, buf  retval, buffer = cv2.imencode(\u0026#39;.png\u0026#39;, img)    매개변수 이름 설명     ext 출력 형식을 정의하는 파일 확장명   img 변환할 이미지   params 이미지 형식별 매개 변수   buf 이미지 형식에 맞게 크기가 조정된 출력 버퍼     이미지 보기  변수에 담겨있는 이미지 보기 cv2.imshow(winname, mat)  cv2.imshow(\u0026#39;Window Name\u0026#39;, img) cv2.waitKey() # 키입력까지 대기 cv2.destroyAllWindows() # 윈도우창 닫기  이미지 정보 조회  이미지 파일 세로,가로,채널 조회 img.shape  img = cv2.imread(image_full_path) h, w, c = img.shape print(\u0026#39;height: {}, width: {}, channel: {}\u0026#39;.format(h, w, c)) ","date":"May 21, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-05-21-python-opencv-guide/","summary":"설치버전 : opencv-python 4.5.1.48\n docs url  라이브러리 설치\npip install opencv-python 라이브러리 import\nimport cv2  이미지 파일 읽기  cv2.imread(filename[, flags]) -\u0026gt; retval  img = cv2.imread(image_full_path)    매개변수 이름 설명     filename 로드할 파일 이름   flags cv2 값을 사용할 수 있는 플래그     이미지 파일 저장  cv2.imwrite(filename, img[, params]) -\u0026gt; retval 이미지 형식은 파일 이름 확장자에 따라 선택됨  cv2.","tags":["python","opencv"],"title":"python opencv 사용법"},{"categories":["Python","Numpy"],"contents":" 선형대수 기반의 python 라이브러리\n 루프없이 배열 연산이 가능하여 연산속도가 빠름  설치버전 : numpy 1.20.2\n 라이브러리 import\nimport numpy as np  1. 생성 arange  np.arange([start,] stop, [step,] dtype) 지정한 숫자 범위의 array 생성함수  np.arange(10) # [0 1 2 3 4 5 6 7 8 9]  np.arange(0, 5, 0.5) # [0. 0.5 1. 1.5 2. 2.5 3. 3.5 4. 4.5] zeros  np.zeros(shape, dtype) 0으로 선언된 array 생성  np.zeros((2,4)) # [[0. 0. 0. 0.] # [0. 0. 0. 0.]]  np.zeros(shape=(5,), dtype=np.int8) # [0 0 0 0 0] ones  np.ones(shape, dtype) 1로 선언된 array 생성  np.ones((2,4)) # [[1. 1. 1. 1.] # [1. 1. 1. 1.]]  np.ones(shape=(5,), dtype=np.int8) # [1 1 1 1 1] empty  np.empty(shape, dtype) 초기화되지 않은 array 생성  np.empty(shape=(2,4), dtype=np.int8) # [[ 0 0 -128 63] # [ 0 0 -128 63]]  np.empty(shape=(5,)) # [1.13941795e-311 0.00000000e+000 6.95331628e-310 1.13949703e-311 0.00000000e+000] full  np.full(shape, fill_value, dtype) 지정한 값으로 채워진 array 생성  np.full(shape=(2,4), fill_value=5, dtype=np.int8) # [[5 5 5 5]  # [5 5 5 5]] iinfo  np.iinfo(dtype) 지정한 타입의 최댓값, 최솟값 얻기  np.iinfo(np.int8) # Machine parameters for int8 # --------------------------------------------------------------- # min = -128 # max = 127 # ---------------------------------------------------------------  np.iinfo(np.int8).min # -128  np.iinfo(np.int8).max # 127 something_like  zeros_like, ones_like, empty_like, full_like(shape, dtype) _like는 지정된 array의 shape 크기만큼 like로 지정된 값의 크기로 array 반환  exp_array = np.arange(8).reshape(2,4)  np.zeros_like(exp_array) # [[0 0 0 0] # [0 0 0 0]]  np.ones_like(exp_array) # [[1 1 1 1] # [1 1 1 1]]  np.empty_like(exp_array) # [[1 0 8 0] # [4 0 4 0]] random  np.random.rand(shape) (0, 1) 범위의 난수 array 생성  np.random.rand(5) # [0.3966061 0.90252864 0.42164379 0.29060846 0.92335056]  np.random.rand(2, 4) # [[0.69718482 0.87517471 0.1429788 0.11088321] # [0.21131956 0.00997556 0.39068644 0.74352718]]  random.randint(min, max, size) (최소값, 최대값)의 범위에서 임의의 정수 array 생성  np.random.randint(1, 5, size=5) # [1 1 3 1 2]  np.random.randint(1, 5, size=(2, 4)) # [[2 2 4 3] # [4 1 3 1]]  random.randn(shape) 표준정규분포에서 샘플링된 난수로 array 생성  np.random.randn(5) # [-0.21797309 0.43488398 -2.56991621 0.62828858 0.12212911]  np.random.randn(2, 3) # [[ 0.83103422 0.29135557 -2.41843352 -0.62250774] # [ 0.35476654 1.70384283 0.38937963 0.99051868]]  sigma, mu = 1.5, 2.0 sigma * np.random.randn(5) + mu  표준정규분포 N(1, 0)가 아닌\n평균 μ, 표준편차 σ 를 갖는 정규분포 N(μ, σ2)의 난수 생성 σ * np.random.randn(shape) + μ 형태로 사용할 수 있음  sigma, mu = 1.5, 2.0 sigma * np.random.randn(5) + mu  2. 차원 출력 및 변경  행렬의 차원을 shape로 표현  사용예제\nexp_array = np.array([  [1,2,3,4],  [1,2,3,4]  ]) Shape  1차원 4, 2차원 2 -\u0026gt; (4,2) 표현  exp_matrix = exp_array.shape  print(exp_matrix) # (2, 4) reshape np.reshape(n, \u0026hellip;)\n 배열의 차원크기 변경 배열의 요소 갯수는 유지하며 차원만 조정함  exp_array.reshape(8,) # [1 2 3 4 1 2 3 4]  exp_array.reshape(2,2,2) # [[[1 2] # [3 4]]  # [[1 2] # [3 4]]]  # -1은 입력받은 array의 size로 자동 맞춤 exp_array.reshape(-1) # [1 2 3 4 1 2 3 4]  exp_array.reshape(-1,2) # [[1 2] # [3 4] # [1 2] # [3 4]] flatten  배열을 1차원 배열로 변환함  exp_array.flatten() # [1 2 3 4 1 2 3 4]  3. 올림, 내림, 반올림 사용예제\nexp_array = np.array([-3.16, -2.58, -1.72, -0.83, 0.39, 1.26, 2.71, 3.46]) 올림  np.ceil(array)  np.ceil(exp_array) # [-3. -2. -1. -0. 1. 2. 3. 4.] 내림 np.trunc(exp_array) # [-3. -2. -1. -0. 0. 1. 2. 3.] 반올림  np.around(array) 0.5 기준으로 반올림  np.around(exp_array) # [-3. -2. -2. -1. 0. 1. 3. 3.]  np.round(array, n) n 소수점 자리까지 반올림  np.around(exp_array, 1) # [-3.1 -2.5 -1.7 -0.8 0.3 1.2 2.7 3.4]  np.rint 가장 가까운 정수로 반올림  np.rint(exp_array) # [-3. -2. -2. -1. 0. 1. 3. 3.] 0에 수렴하는 정수  np.fix(array)  np.fix(exp_array) # [-3. -2. -1. -0. 0. 1. 2. 3.]  4. 조건 연산 where  where(조건, 참, 거짓)  np.where(0 \u0026lt; exp_array, True, False) # [False False False False True True True True]  np.where(0 \u0026lt; exp_array, exp_array, False) # [0. 0. 0. 0. 0.39 1.26 2.71 3.46] ","date":"May 21, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-05-21-python-numpy-guide/","summary":"선형대수 기반의 python 라이브러리\n 루프없이 배열 연산이 가능하여 연산속도가 빠름  설치버전 : numpy 1.20.2\n 라이브러리 import\nimport numpy as np  1. 생성 arange  np.arange([start,] stop, [step,] dtype) 지정한 숫자 범위의 array 생성함수  np.arange(10) # [0 1 2 3 4 5 6 7 8 9]  np.arange(0, 5, 0.5) # [0. 0.5 1. 1.5 2. 2.5 3. 3.5 4. 4.5] zeros  np.zeros(shape, dtype) 0으로 선언된 array 생성  np.","tags":["python","numpy"],"title":"python numpy 사용법"},{"categories":["Python","Learning"],"contents":" Part 1 헬로, 자료구조!  Chapter 01 숫자 1.1 정수 int() 불변형 객체로 문자열을 정수로 변환하거나 다른 진법의 문자열을 정수로 변환\nint(문자열, 밑(n진법))\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#39;11\u0026#39; \u0026gt;\u0026gt;\u0026gt; b = int(s, 2) \u0026gt;\u0026gt;\u0026gt; print(b) 11 정수에 필요한 바이트 수(python 3.1이상)\n\u0026gt;\u0026gt;\u0026gt; (정수).bit_length() 10 발생가능한 Exception : ValueError\n1.2 부동 소수점 float() float 32bit\n 1bit 부호, 8bit 지수, 23bit 유효 숫자 자릿수  1.2.1 부동소수점끼리 비교하기 이진수 분수로 표현으로 소수점의 정확한 비교는 어렵지만,\n동등성 테스트로 사전에 정의된 정밀도 범위 내에서 비교는 가능한다.\nunittest 모듈의 assertAlmostEqual() 메소드 같은 접근법 사용\n\u0026gt;\u0026gt;\u0026gt; def a(x, y, places=7):  return rount(abs(x-y), places) == 0 1.2.2 정수와 부동소수점 메서드 나누기 연산자 / 는 항상 부동소수점을 연산자 // 는 정수를 반환한다.\ndivmod(x, y)\n x를 y로 나눌 때, 몫과 나머지를 반환  \u0026gt;\u0026gt;\u0026gt; divmod(45, 6) (7, 3) round(x, n)\n n이 양수인 경우, x를 소수점 이하 n번째 자리로 반올림한 값을 반환한다. n이 음수인 경우, x를 정수 n번째 자리에서 반올림한 값을 반환한다.  as_interger_ratio()\n 부동소수점을 분수로 표현  \u0026gt;\u0026gt;\u0026gt; 2.75.as_integer_ratio() (11, 4) 1.3 복소수 1.4 fraction 모듈 분수를 다루는 라이브러리\nfrom fractions import Fraction  def rounding_floats(num1, places):  return round(num1, places)  def float_to_fractions(num):  return Fraction(*num.as_integer_ratio())  def get_denominator(num1, num2):  \u0026#39;\u0026#39;\u0026#39; 분모 반환 \u0026#39;\u0026#39;\u0026#39;  a = Fraction(num1, num2)  return a.denominator  def get_numerator(num1, num2):  \u0026#39;\u0026#39;\u0026#39; 분자 반환 \u0026#39;\u0026#39;\u0026#39;  a = Fraction(num1, num2)  return a.numerator  def test_testing_floats():  num1 = 1.25  num2 = 1  num3 = -1  num4 = 5/4  num6 = 6  assert(rounding_floats(num1, num2) == 1.2)  assert(rounding_floats(num1*10, num3) == 10)  assert(float_to_fractions(num1) == num4)  assert(get_denominator(num2, num6) == num6)  assert(get_numerator(num2, num6) == num2)  print(\u0026#34;테스트 통과!\u0026#34;)  if __name__ == \u0026#39;__main__\u0026#39;:  test_testing_floats() 테스트 통과! 1.5 decimal 모듈 정확한 10진법의 부동소수점 숫자가 필요한 경우, 부동소수점 불변 타입인 decimal.Decimal 사용할 수 있다.\n일반적인 float 데이터는 정확한 값 비교를 할 수 없다.\n\u0026gt;\u0026gt;\u0026gt; a = sum([0.1 for _ in range(10)]) \u0026gt;\u0026gt;\u0026gt; b = 1.0 \u0026gt;\u0026gt;\u0026gt; a == b False decimal.Decimal 모듈을 사용한 float 데이터는 정확한 값 비교가 가능하다.\n\u0026gt;\u0026gt;\u0026gt; from decimal import Decimal \u0026gt;\u0026gt;\u0026gt; a = sum(Decimal(\u0026#39;0.1\u0026#39;) for _ in range(10)) \u0026gt;\u0026gt;\u0026gt; b = Decimal(\u0026#39;1.0\u0026#39;) \u0026gt;\u0026gt;\u0026gt; a == b True 1.6 2진수, 8진수, 16진수 bin(n)\n 정수 n의 2진수 문자열 반환한다.  \u0026gt;\u0026gt;\u0026gt; bin(30) \u0026#39;0b11110\u0026#39; oct(n)\n 정수 n의 8진수 문자열 반환한다.  \u0026gt;\u0026gt;\u0026gt; oct(30) \u0026#39;0o36\u0026#39; hex(n)\n 정수 n의 16진수 문자열 반환한다.  \u0026gt;\u0026gt;\u0026gt; hex(30) \u0026#39;0x1e\u0026#39; 1.7 random 모듈 난수 생성 모듈 예제 코드\nimport random  def testing_random():  \u0026#39;\u0026#39;\u0026#39; random 모듈 테스트 \u0026#39;\u0026#39;\u0026#39;  values = [1, 2, 3, 4]  print(random.choice(values))  print(random.choice(values))  print(random.choice(values))  print(random.sample(values, 2))  print(random.sample(values, 3))   \u0026#39;\u0026#39;\u0026#39; values 리스트를 섞는다. \u0026#39;\u0026#39;\u0026#39;  random.shuffle(values)  print(values)   \u0026#39;\u0026#39;\u0026#39; 0~10의 임의의 정수를 생성한다. \u0026#39;\u0026#39;\u0026#39;  print(random.randint(0, 10))  print(random.randint(0, 10))  if __name__ == \u0026#39;__main__\u0026#39;:  testing_random() 결과는 매번 다르게 출력된다.\n3 3 2 [4, 3] [1, 3, 4] [4, 3, 2, 1] 4 3 1.8 numpy 패키지 대규모의 다차원 배열 및 행렬을 지원하며, 배열 연산에 쓰이는 수학함수 라이브러리를 제공한다.\narray 메서드 np.array()\n 다차원 배열 생성 함수 예시 : 시퀀스의 시퀀스(리스트 또는 튜플)를 2차원 numpy 배열로 생성할 수 있다.  \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; np.array(((11,12,13), (21,22,23), (31,32,33))) [[11 12 13]  [21 22 23]  [31 32 33]] ndim 속성은 배열의 차원 수를 반환한다.\n\u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; a = np.array(((11,12,13), (21,22,23))) \u0026gt;\u0026gt;\u0026gt; a.ndim 2 간단한 사용예제\nimport numpy as np  def testing_numpy():  \u0026#39;\u0026#39;\u0026#39; tests many features of numpy \u0026#39;\u0026#39;\u0026#39;  ax = np.array([1,2,3])  ay = np.array([3,4,5])  print(ax)  # [1 2 3]  print(ax * 2)  # [2 4 6]  print(ax + 10)  # [11 12 13]  print(np.sqrt(ax))  # [1. 1.41421356 1.73205081]  print(np.cos(ax))  # [ 0.54030231 -0.41614684 -0.9899925 ]  print(ax-ay)  # [-2 -2 -2]  print(np.where(ax\u0026lt;2, ax, 10))  # [ 1 10 10]   m = np.matrix([ax, ay, ax])  print(m)  # [[1 2 3]  # [3 4 5]  # [1 2 3]]  print(m.T)  # [[1 3 1]  # [2 4 2]  # [3 5 3]]   grid1 = np.zeros(shape=(3,3), dtype=float)  grid2 = np.ones(shape=(3,3), dtype=float)  print(grid1)  # [[0. 0. 0.]  # [0. 0. 0.]  # [0. 0. 0.]]  print(grid2)  # [[1. 1. 1.]  # [1. 1. 1.]  # [1. 1. 1.]]  print(grid1[1]+10)  # [10. 10. 10.]  print(grid2[:,2]*2)  # [2. 2. 2.]  if __name__ == \u0026#39;__main__\u0026#39;:  testing_numpy() numpy 배열은 파이썬 list 보다 더 효율적이다.\n numpy 연산이 약 80배 정도 빠르다.  import numpy as np import time  def trad_version():  t1 = time.time()  X = range(10000000)  Y = range(10000000)  Z = []  for i in range(len(X)):  Z.append(X[i] + Y[i])  return time.time() - t1  def numpy_version():  t1 = time.time()  X = np.arange(10000000)  Y = np.arange(10000000)  Z = X + Y  return time.time() - t1  if __name__ == \u0026#39;__main__\u0026#39;:  print(trad_version())  # 2.2733571529388428  print(numpy_version())  # 0.028986215591430664 1.9 연습문제 1.9.1 n진법 변환 n진법의 숫자를 10진법으로 변환하는 코드작성(2\u0026lt;= n \u0026lt;=10)\n 테스트 실행함수   def convert_to_decimal1(n, base):  \u0026#39;\u0026#39;\u0026#39; 나머지, 나누기 연산 이용한 방법 \u0026#39;\u0026#39;\u0026#39;  digit = 1  result = 0  while 0 \u0026lt; n:  n, m = n//10, n%10  result += (m * digit)  digit *= base  return result  def convert_to_decimal2(number, base):  \u0026#39;\u0026#39;\u0026#39; 내장함수 int 이용한 방법 \u0026#39;\u0026#39;\u0026#39;  result = int(str(number), base)  return result  if __name__ == \u0026#39;__main__\u0026#39;:  number, base = 1001, 2  assert(convert_to_decimal1(number, base) == 9)  assert(convert_to_decimal2(number, base) == 9)  print(\u0026#39;테스트 통과!\u0026#39;) 10진법의 숫자를 n진법로 변환하는 코드작성(2\u0026lt;= n \u0026lt;=10)\n 테스트 실행함수  def convert_from_decimal(n, base):  digit = 1  result = 0  while 0 \u0026lt; n:  n, m = n // base, n % base  result += (m * digit)  digit *= 10  return result  if __name__ == \u0026#39;__main__\u0026#39;:  number, base = 9, 2  assert(convert_from_decimal(number, base) == 1001)  print(\u0026#39;테스트 통과!\u0026#39;) 10진법의 숫자를 20이하 진법으로 변환하는 코드작성(2\u0026lt;= n \u0026lt;=20)\n 테스트 실행함수  def convert_from_decimal_larger_bases(n, base):  digit = \u0026#39;0123456789ABCDEFGHIJ\u0026#39;  result = \u0026#39;\u0026#39;  m = 1  while 0 \u0026lt; n:  n, m = n // base, n % base  result = digit[m] + result  return result  if __name__ == \u0026#39;__main__\u0026#39;:  number, base = 31, 16  assert(convert_from_decimal_larger_bases(number, base) == \u0026#39;1F\u0026#39;)  print(\u0026#39;테스트 통과!\u0026#39;) 1.9.2 최대 공약수 두 정수의 최대 공약수를 계산하는 코드작성\n 테스트 실행함수  def find_gcd(a, b):  \u0026#39;\u0026#39;\u0026#39; a가 b보다 큰 값일때 \u0026#39;\u0026#39;\u0026#39;  result = 0  while b != 0:  result = b  a, b = b, a % b  return result  if __name__ == \u0026#39;__main__\u0026#39;:  number1 = 21  number2 = 12  assert(find_gcd(number1, number2) == 3)  print(\u0026#39;테스트 통과!\u0026#39;) 1.9.3 피보나치 수열 피보나치 수열 : 첫째 및 둘째 항이 1이며, 그 이후 모든 항은 바로 앞 두항의 합인 수열\n피보나치 수열의 특정 인덱스 값을 계산하는 코드작성\n 테스트 실행함수 (시간 복잡도 O(n))  def find_fibonacci_seq_iter(n):  if n \u0026lt; 2: return n   a, b = 0, 1  for _ in range(n):  a, b = b, a+b  return a  if __name__ == \u0026#39;__main__\u0026#39;:  n = 10  assert(find_fibonacci_seq_iter(n) == 55)  print(\u0026#39;테스트 통과!\u0026#39;) 제너레이터(generator) 이용한 방법\n yield문을 사용 전체 시퀀스를 한 번에 메모리에 생성하고 정렬할 필요 없이, 시퀀스를 순회할 수 있다. 제너레이터를 순회할 때마다 마지막으로 호출된 요소를 기억하고 다음 값을 반환한다.  def fib_generator():  a, b = 0, 1  while True:  yield b  a, b = b, a+b  if __name__ == \u0026#39;__main__\u0026#39;:  fg = fib_generator()  for _ in range(10):  print(next(fg), end=\u0026#39; \u0026#39;) 1.9.4 소수 소수 : 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수\n소수를 판단하는 코드작성\n 테스트 실행 함수  import math import random  def finding_prime(num):  \u0026#39;\u0026#39;\u0026#39; 무차별 대입 방법 \u0026#39;\u0026#39;\u0026#39;  num = abs(num)  if num \u0026lt; 4: return True  for i in range(2, num):  if num % i == 0:  return False  return True  def finding_prime_sqrt(num):  \u0026#39;\u0026#39;\u0026#39; 제곱근 활용한 방법 \u0026#39;\u0026#39;\u0026#39;  num = abs(num)  if num \u0026lt; 4: return True   # 직접 연산한것 보다 math 라이브러리가 약 10% 정도 빠르다.  sqrt = int(math.sqrt(num)) + 1  # sqrt = int(num ** 0.5) + 1   for i in range(2, sqrt):  if num % i == 0:  return False  return True  def finding_prime_fermat(num):  \u0026#39;\u0026#39;\u0026#39; 확률론적 테스트와 페르마의 소정리를 활용한 방법 \u0026#39;\u0026#39;\u0026#39;  if num \u0026lt;= 102:  for a in range(2, num):  if pow(a, num-1, num) != 1:  return False  return True  else:  for _ in range(100):  a = random.randint(2, num-1)  if pow(a, num-1, num) != 1:  return False  return True  if __name__ == \u0026#39;__main__\u0026#39;:  num1 = 17  num2 = 20  assert(finding_prime(num1) is True)  assert(finding_prime(num2) is False)  assert(finding_prime_sqrt(num1) is True)  assert(finding_prime_sqrt(num2) is False)  assert(finding_prime_fermat(num1) is True)  assert(finding_prime_fermat(num2) is False)  print(\u0026#39;테스트 통과!\u0026#39;) random 모듈을 이용한 n비트 소수 생성하는 코드작성\nimport math import random import sys  def finding_prime_sqrt(num):  num = abs(num)  if num \u0026lt; 4: return True   sqrt = int(math.sqrt(num)) + 1  for i in range(2, sqrt):  if num % i == 0:  return False  return True  def generate_prime(num):  while 1:  p = random.randint(pow(2, num-2), pow(2, num-1)-1)  p = 2 * p + 1  if finding_prime_sqrt(p):  return p  if __name__ == \u0026#39;__main__\u0026#39;:  if len(sys.argv) \u0026lt; 2:  print(\u0026#34;Usage: generate_prime.py number\u0026#34;)  sys.exit()  else:  num = int(sys.argv[1])  print(generate_prime(num)) $ generate_prime.py 3 5 (또는 7)  Chapter 02 내장 시퀀스 타입 시퀀스 타입은 다음과 같은 속성을 가진다.\n 멤버십(membership) 연산 : in 키워드 사용 크기(size) 함수 : len(seq) 슬라이싱(slicing) 속성 : seq[:-1] 반복성(iterability) : 반복문에 있는 데이터를 순회할 수 있음  Python에는 문자열, 튜플, 리스트, 바이트 배열, 바이트 등 5개의 내장 시퀀스 타입이 있다.\nl = [] print(type(l)) # \u0026lt;class \u0026#39;list\u0026#39;\u0026gt;  s = \u0026#39;\u0026#39; print(type(s)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;  t = () print(type(t)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt;  ba = bytearray(b\u0026#39;\u0026#39;) print(type(ba)) # \u0026lt;class \u0026#39;bytearray\u0026#39;\u0026gt;  b = bytes([]) print(type(b)) # \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; 2.1 깊은 복사와 슬라이싱 연산 python 불변 객체 타입\n 숫자 튜플 문자열 바이트  python 가변 객체 타입\n 리스트 바이트  2.1.1 가변성 일반적으로 불변 객체 타입은 가변 객체 타입보다 효율적이다.\n파이썬의 모든 변수는 객체 참조(reference)이므로 가변 객체 복사할 때는 주의해야 한다.\n리스트(list)의 깊은 복사 예제\nmy_list = [1, 2, 3, 4] new_list = my_list[:] new_list2 = list(my_list) 셋(set)의 깊은 복사 예제\npeople = {\u0026#39;버피\u0026#39;, \u0026#39;에인절\u0026#39;, \u0026#39;자일스\u0026#39;} slayers = people.copy() slayers.discard(\u0026#39;자일스\u0026#39;) slayers.remove(\u0026#39;에인절\u0026#39;) print(slayers) # {\u0026#39;버피\u0026#39;}  print(people) # {\u0026#39;버피\u0026#39;, \u0026#39;에인절\u0026#39;, \u0026#39;자일스\u0026#39;} 딕셔너리(dict)의 깊은 복사 예제\nmy_dict = {\u0026#39;hello\u0026#39;: \u0026#39;world\u0026#39;} new_dict = my_dict.copy() 기타 객체의 깊은 복사는 copy 모듈을 사용한다.\nimport copy  my_obj = \u0026#39;other something object\u0026#39; new_obj = copy.copy(my_obj) # 얕은 복사(shallow copy) new_obj2 = copy.deepcopy(my_obj) # 깊은 복사(deep copy) 2.1.2 슬라이싱 연산자 파이썬 시퀀스 타입의 슬라이싱 연산자 구문\nseq[시작] seq[시작:끝] seq[시작:끝:스텝] 슬라이싱 예제\nword = \u0026#39;abcde\u0026#39; print(word[0]) # a print(word[1]) # b print(word[-1]) # e print(word[-2:]) # de print(word[-0]) # a print(word[::2]) # ace 2.2 문자열 2.2.1 유니코드 문자열 유니코드 : 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드\nprint(u\u0026#39;Hello\\u0020World !\u0026#39;) # Hello World ! 문자열 코드 크기\n 아스키코드 7bit ANSI코드 8ibt 유니코드 16bit  2.2.2 문자열 메서드 join()\nA.join(B) : 리스트 B에 있는 모든 문자열을 하나의 단일 문자열 A로 결합한다.\nslayer = [\u0026#39;버피\u0026#39;, \u0026#39;앤\u0026#39;, \u0026#39;아스틴\u0026#39;] print(\u0026#39; \u0026#39;.join(slayer)) # 버피 앤 아스틴  print(\u0026#39;-\u0026#39;.join(slayer)) # 버피-앤-아스틴  print(\u0026#39;\u0026#39;.join(slayer)) # 버피앤아스틴  print(\u0026#39;\u0026#39;.join(reversed(slayer))) # 아스틴앤버피 ljust(), rjust()\nA.ljust(width, fillchar) : 문자열 A 맨 처음부터 문자열을 포함한 길이 width 만큼 문자 fillchar로 채운다.\nA.rjust(width, fillchar) : 문자열 A 맨 끝부터 문자열을 포함한 길이 width 만큼 문자 fillchar로 채운다.\nname = \u0026#39;스칼렛\u0026#39; print(name.ljust(20, \u0026#39;-\u0026#39;)) # 스칼렛----------------- print(name.rjust(20, \u0026#39;-\u0026#39;)) # -----------------스칼렛 format()\nA.format() : 문자열 A에 변수를 추가하거나 형식화하는데 사용한다.\nprint(\u0026#34;{0}{1}\u0026#34;.format(\u0026#39;Hello,\u0026#39;, \u0026#39;Python!\u0026#39;)) # Hello, Python! print(\u0026#34;이름 : {who}, 나이 : {age}\u0026#34;.format(who=\u0026#39;제임스\u0026#39;, age=20)) # 이름 : 제임스, 나이 : 20 print(\u0026#34;이름 : {who}, 나이 : {0}\u0026#34;.format(21, who=\u0026#39;에이미\u0026#39;)) # 이름 : 에이미, 나이 : 21  # python 3.1이상 print(\u0026#34;{}{}{}\u0026#34;.format(\u0026#39;파이썬\u0026#39;, \u0026#39;자료구조\u0026#39;, \u0026#39;알고리즘\u0026#39;)) # 파이썬 자료구조 알고리즘  import decimal # !s : 문자열 형식 # !r : 표현 형식 # !a : 아스키코드 형식  print(\u0026#34;{0}{0!s}{0!r}{0!a}\u0026#34;.format(decimal.Decimal(\u0026#39;99.9\u0026#39;))) # 99.9 99.9 Decimal(\u0026#39;99.9\u0026#39;) Decimal(\u0026#39;99.9\u0026#39;) 문자열 언패킹\n연산자 ** : 함수로 전달하기 적합한 키-값 딕셔너리가 생성된다.\nlocals() 메서드는 현재 스코프에 있는 지역변수를 딕셔너리로 반환한다.\nhero = \u0026#39;버피\u0026#39; num = 999 print(\u0026#34;{number}: {hero}\u0026#34;.format(**locals())) # 999: 버피 splitlines()\nA.splitlines() : 문자열 A에 대해 줄 바꿈 문자를 기준으로 분리한 결과를 문자열 리스트로 반환한다.\nslayers = \u0026#34;로미오\\n줄리엣\u0026#34; print(slayers.splitlines()) # [\u0026#39;로미오\u0026#39;, \u0026#39;줄리엣\u0026#39;] split()\nA.split(t, n) : 문자열 A의 왼쪽부터 문자열 t를 기준으로 정수 n번만큼 분리한 문자열 리스트를 반환한다. t의 기본값은 공백(\u0026rsquo; \u0026lsquo;)이다.\nslayers = \u0026#34;버피 크리스-메리 16\u0026#34; print(slayers.split()) # [\u0026#39;버피\u0026#39;, \u0026#39;크리스-메리\u0026#39;, \u0026#39;16\u0026#39;] print(slayers.split(\u0026#39;-\u0026#39;)) # [\u0026#39;버피 크리스\u0026#39;, \u0026#39;메리 16\u0026#39;] A.rsplit(t, n) : 문자열 A의 오른쪽부터 문자열 t를 기준으로 정수 n번만큼 분리한 문자열 리스트를 반환한다.\nstrip(s), lstrip(s), rstrip(s)\n각각 양쪽, 왼쪽, 오른쪽 문자열 s를 삭제한다. s의 기본값은 공백(\u0026rsquo; \u0026lsquo;)이다.\nswapcase()\nA.swapcase() : 문자열 A에서 대소문자를 반전한 문자열의 복사본을 반환한다.\nindex(), find(), rindex(), rfind()\nA.index(sub, start, end) : 문자열A 에서 부분 문자열 sub의 인덱스 위치를 반환하며, 실패하면 ValueError 예외를 발생시킨다.\nA.find(sub, start, end) : 문자열 A에서 부분 문자열 sub의 인덱스 위치를 반환하며, 실패하면 -1을 반환한다.\n인덱스 start와 end는 문자열 범위이며, 생략할 경우 전체 문자열에서 부분 문자열 sub를 찾는다.\ncount()\nA.count(sub, start, end) : 문자열 A에서 인덱스 start, end 범위 내의 부분 문자열 sub가 나온 횟수를 반환한다.\nreplace()\nA.replace(old, new, max_replace) : 문자열 A에서 문자열 old를 대체 문자열 new로 max_replace만큼 변경한 문자열을 복사본을 반환한다.\nf-strings\nf-strings은 파이썬 3.6부터 사용가능하다.\nname = \u0026#39;abcde\u0026#39; print(f\u0026#34;이름은 {name}입니다.\u0026#34;) # 이름은 abcde 입니다. print(f\u0026#34;이름은 {name!r}입니다.\u0026#34;) # 이름은 \u0026#39;abcde\u0026#39; 입니다. 2.3 튜플 튜플 : 쉼표로 구분된 값으로 이루어지는 불변 시퀀스 타입\n튜플은 값과 쉼표를 사용해 생성한다.\n괄호안에 쉼표없이 값 하나만 넣으면 튜플이 생성되지 않는다.\nt1 = 1234, \u0026#39;Hello!\u0026#39; print(t1[0]) # 1234 print(t1) # (1234, \u0026#39;Hello!\u0026#39;)  t2 = t1, (1,2,3) # 중첩가능 print(t2) # ((1234, \u0026#39;Hello!\u0026#39;), (1, 2, 3)) 2.3.1 튜플 메서드 A.count(x) : 튜플 A에 담긴 항목 x의 개수를 반환한다.\nA.index(x) : 튜플 A에 담긴 항목 x의 인덱스 위치를 반환한다.\n2.3.2 튜플 언패킹 파이썬에서 모든 반복 가능한(iterable) 객체는 시퀀스 언패킹 연산자 *를 사용하여 언패킹 할 수 있다.\nx, *y = (1, 2, 3, 4) print(x) # 1 print(y) # [2, 3, 4]  *x, y = (1, 2, 3, 4) print(x) # [1, 2, 3] print(y) # 4 2.3.3 네임드 튜플 파이썬 표준 모듈 collections에는 네임드 튜플 시퀀스 타입이 있다.\n 네임드 튜플은 일반 튜플과 비슷한 성능과 특성을 가진다. 튜플 항목을 인덱스 위치, 이름으로 참조할 수 있다.  collections.namedtuple() 메서드의 첫번째 인수는 만들고자 하는 사용자 정의 튜플 데이터 타입의 이름이다.\n","date":"May 17, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-05-17-python-datastructures-and-algorithms/","summary":"Part 1 헬로, 자료구조!  Chapter 01 숫자 1.1 정수 int() 불변형 객체로 문자열을 정수로 변환하거나 다른 진법의 문자열을 정수로 변환\nint(문자열, 밑(n진법))\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#39;11\u0026#39; \u0026gt;\u0026gt;\u0026gt; b = int(s, 2) \u0026gt;\u0026gt;\u0026gt; print(b) 11 정수에 필요한 바이트 수(python 3.1이상)\n\u0026gt;\u0026gt;\u0026gt; (정수).bit_length() 10 발생가능한 Exception : ValueError\n1.2 부동 소수점 float() float 32bit\n 1bit 부호, 8bit 지수, 23bit 유효 숫자 자릿수  1.2.1 부동소수점끼리 비교하기 이진수 분수로 표현으로 소수점의 정확한 비교는 어렵지만,","tags":["python","learning"],"title":"python 자료구조와 알고리즘(by 미아 스타인) 책 정리"},{"categories":["Windows10","WSL"],"contents":" 1. WSL(Windows Subsystem for Linux)2 리눅스용 윈도우 하위 시스템(Windows Subsystem for Linux)은 Windows 10에서 네이티브로 리눅스 실행 파일을 실행하기 위한 호환성 계층 프로그램이다.\n 2. 사전 설정  microsoft store에서 Windows Terminal 설치한다. Windows Terminal 프로그램을 관리자 권한으로 실행한다.  2.1. WSL2 활성화를 위한 DISM 명령어 실행후 재부팅 \u0026gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart \u0026gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 2.2. Windows Store 에서 설치하는 모든 Linux 배포판 포맷을 WSL 2로 설정 \u0026gt; wsl --set-default-version 2  3. 실습 및 팁 3.1. 기존에 설치한 WSL 배포 목록확인 microsoft store에서 Ubuntu 18.04 LTS 설치\n\u0026gt; wsl -l -v  NAME STATE VERSION * docker-desktop-data Running 2  docker-desktop Running 2  Ubuntu-18.04 Running 2 윈도우 탐색기에서 \\\\wsl$ 경로로 접속하면 wsl 리눅스 배포판 접속가능하다.\n3.2. wsl 터미널에서 현재 작업 위치 Windows 탐색기로 열기 explorer.exe . 3.3. wsl에서 vscode 실행하기 vscode 확장 프로그램에서 Remote-WSL 설치 후\nwsl 터미널에서 code . 명령어 실행하면 리눅스 배포환경에서 vscode로 작업 가능하다.\n$ code . 참고(Reference)  WSL2 설치 및 사용 방법 도커 데스크톱 WSL 2 백엔드 WSL 1과 WSL 2 비교  ","date":"May 7, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/os/windows/2021-05-07-windows10-wsl2-guide/","summary":"1. WSL(Windows Subsystem for Linux)2 리눅스용 윈도우 하위 시스템(Windows Subsystem for Linux)은 Windows 10에서 네이티브로 리눅스 실행 파일을 실행하기 위한 호환성 계층 프로그램이다.\n 2. 사전 설정  microsoft store에서 Windows Terminal 설치한다. Windows Terminal 프로그램을 관리자 권한으로 실행한다.  2.1. WSL2 활성화를 위한 DISM 명령어 실행후 재부팅 \u0026gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart \u0026gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 2.2. Windows Store 에서 설치하는 모든 Linux 배포판 포맷을 WSL 2로 설정 \u0026gt; wsl --set-default-version 2  3.","tags":["windows10","wsl"],"title":"Windows10 WSL2(Windows Subsystem for Linux) 사용법"},{"categories":["Docker","MSSQL"],"contents":" 1. mssql docker 도커 설치 방법 1.1. 도커 허브에서 이미지 검색 docker search \u0026lt;검색할 이미지 이름\u0026gt; 1.2. pull - 도커 이미지 다운받기 docker pull mcr.microsoft.com/mssql/server:2017-latest 1.3. docs 예시 docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;SA_PASSWORD=\u0026lt;YourStrong@Passw0rd\u0026gt;\u0026#34;  -p 1433:1433 --name mssql2017 -h mssql2017  -v \u0026lt;host directory\u0026gt;/data:/var/opt/mssql/data  -v \u0026lt;host directory\u0026gt;/log:/var/opt/mssql/log  -v \u0026lt;host directory\u0026gt;/secrets:/var/opt/mssql/secrets  -d mcr.microsoft.com/mssql/server:2017-latest Docker on Windows 의 호스트 볼륨 매핑은 현재 /var/opt/mssql 디렉토리가 아닌 /var/opt/mssql/data 등의 하위 디렉터리를 호스트 머신에 매핑할 수 있다.\n1.4. 사용 명령어 예시 docker volume create mssqldata docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;SA_PASSWORD=Airiss123!\u0026#34; -p 11433:1433 --name mssql2017_1 -h mssql2017_1 -v mssqldata:/var/opt/mssql/data -d mcr.microsoft.com/mssql/server:2017-latest    변수 설명     -p 호스트 환경의 TCP 포트를 컨테이너의 TCP 포트로 매핑   --name 컨테이너 이름 지정   -h 컨테이너 호스트 이름을 명시적으로 설정   -e \u0026quot;ACCEPT_EULA\u0026quot; 최종 사용자 사용권 계약 수락   -e \u0026quot;SA_PASSWORD\u0026quot; 암호는 8자 이상이어야 하며 대문자, 소문자, 숫자 및 특수문자를 사용하는 모든 조합을 포함해아함   -d 백그라운드에서 컨테이너 실행    1.5. 파일저장 기본위치 변경 -e \u0026#34;MSSQL_DATA_DIR=/my/file/path\u0026#34; -v /my/host/path:/my/file/path  참고(Reference)  SQL Server Docker 컨테이너 구성 및 사용자 지정  https://docs.microsoft.com/ko-kr/sql/linux/sql-server-linux-docker-container-configure?view=sql-server-2017\u0026amp;pivots=cs1-cmd   Docker + MSSQL 개발하기  https://hyesunzzang.tistory.com/91    ","date":"May 6, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/docker/2021-05-06-docker-mssql2017-setup/","summary":"1. mssql docker 도커 설치 방법 1.1. 도커 허브에서 이미지 검색 docker search \u0026lt;검색할 이미지 이름\u0026gt; 1.2. pull - 도커 이미지 다운받기 docker pull mcr.microsoft.com/mssql/server:2017-latest 1.3. docs 예시 docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;SA_PASSWORD=\u0026lt;YourStrong@Passw0rd\u0026gt;\u0026#34;  -p 1433:1433 --name mssql2017 -h mssql2017  -v \u0026lt;host directory\u0026gt;/data:/var/opt/mssql/data  -v \u0026lt;host directory\u0026gt;/log:/var/opt/mssql/log  -v \u0026lt;host directory\u0026gt;/secrets:/var/opt/mssql/secrets  -d mcr.microsoft.com/mssql/server:2017-latest Docker on Windows 의 호스트 볼륨 매핑은 현재 /var/opt/mssql 디렉토리가 아닌 /var/opt/mssql/data 등의 하위 디렉터리를 호스트 머신에 매핑할 수 있다.","tags":["docker","mssql"],"title":"mssql 2017 도커 이미지 설치 및 컨테이너 실행방법"},{"categories":["Docker","PostgreDB"],"contents":" 1. Postgres Docker 이미지 설치 Postgres Version : 13.2\n1.1. 다운로드 및 설정 아래 명령어를 실행한다.\n$ docker run -p 15432:5432 --name postgres -e POSTGRES_PASSWORD=password1! -d postgres  -d : 백그라운드에서 컨테이너 실행 -p 15432:5432 : 호스트와 컨테이너 간의 배포(publish)포트/바인드(bind)포트  호스트 15432번 포트를 컨테이너 5432번 포트에 매핑   --name : 생성할 컨테이너 이름 -e : 도커 컨테이너의 환경변수 설정  POSTGRES_PASSWORD : PostgresDB 관리자 비밀번호    실행 결과\nUnable to find image \u0026#39;postgres:latest\u0026#39; locally latest: Pulling from library/postgres 75646c2fb410: Pull complete 2355d0ffeb55: Pull complete 7e98825f6d67: Pull complete cfd3ce06be45: Pull complete c7b7bb83e8f7: Pull complete c67869305108: Pull complete 19614baa7ddd: Pull complete af508737d813: Pull complete b60c3437a436: Pull complete 424da1ff3ea9: Pull complete 076f107f1898: Pull complete 7b398ea488bf: Pull complete e0fcc114ae29: Pull complete 67d927dd9b8a: Pull complete Digest: sha256:b25265ac1dfa19224fd47dd9f5744aa177248fd64e89f407446559cc7dbc7a23 Status: Downloaded newer image for postgres:latest 47d090f5c4a593b833c237cef181f960571e71004ace5ebc804907f4feae1433 1.2. 도커 이미지 확인 도커에서 실행중인 이미지 정보확인\n$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 47d090f5c4a5 postgres \u0026#34;docker-entrypoint.s…\u0026#34; 16 seconds ago Up 14 seconds 0.0.0.0:15432-\u0026gt;5432/tcp postgres 1.3. 도커 이미지 접속 postgres 이미지 bash쉘 접속\n$ docker exec -it postgres /bin/bash  -it : 컨테이너를 종료하지 않고, 터미널의 입력을 컨테이너로 전달하기 위해서 사용  1.4. Postgres DB 및 User 생성   데이터베이스 접속\npsql -U postgres   데이터베이스 생성\nCREATE DATABASE \u0026#34;{database_name}\u0026#34;;   User 생성\nCREATE USER {user_name} WITH PASSWORD \u0026#39;{user_password}\u0026#39;;   권한부여\nGRANT {permissions} ON DATABASE {db_name} TO {user_name};  사용예시  GRANT ALL ON DATABASE \u0026#34;ABCD_DB\u0026#34; TO abcd_user;   계정 권한 확인\n\\du   1.5. 도커 컨테이너 삭제 도커 이미지가 실행중일 경우 두 가지 방법으로 삭제할 수 있다.\n  컨테이너 종료 후 삭제\n$ docker stop {CONTAINER ID} $ docker rm {CONTAINER ID}   컨테이너 강제 삭제\n$ docker rm -f {CONTAINER ID}   1.6. 모든 컨테이너 종료 및 삭제 $ docker stop $(docker ps -a -q) $ docker rm $(docker ps -a -q) 1.7. 볼륨 컨테이너 컨테이너를 삭제하면 데이터도 같이 삭제되므로 데이터 저장용으로 사용하는 볼륨 컨테이너를 같이 사용한다.\n  볼륨 컨테이너 생성\ndocker volume create pgdata   볼륨 컨테이너 연동하여 postgresDB 이미지 생성\ndocker run -p 15432:5432 --name postgres -e POSTGRES_PASSWORD=password1! -d -v pgdata:/var/lib/postgresql/data postgres  -v : 생성된 볼륨 컨테이너 지정하는 것으로 호스트(host) 컴퓨터의 파일 시스템의 특정 경로를 컨테이너의 파일 시스템의 특정 경로로 마운트(mount)한다.  위에서 설정한 DB설정을 그대로 반복하여 실행한다.\n  볼륨 정보확인\n 볼륨 리스트 확인  $ docker volume list DRIVER VOLUME NAME local pgdata  볼륨 위치 및 상세정보 확인  $ docker volume inspect pgdata [  {  \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-04-01T07:43:03Z\u0026#34;,  \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;,  \u0026#34;Labels\u0026#34;: {},  \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/pgdata/_data\u0026#34;,  \u0026#34;Name\u0026#34;: \u0026#34;pgdata\u0026#34;,  \u0026#34;Options\u0026#34;: {},  \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;  } ]    2. pgadmin4 이미지 설치 pgadmin4 Version : 13.2\n2.1. 설치 이미지를 다운받는다.\ndocker pull dpage/pgadmin4 2.2. 도커 이미지 실행 아래의 설정으로 다운받은 이미지 사용하여 도커컨테이너를 실행한다.\ndocker run -p 80:80 --name pgadmin4 -e PGADMIN_DEFAULT_EMAIL=\u0026#34;account@site.com\u0026#34; -e PGADMIN_DEFAULT_PASSWORD=\u0026#34;password1!\u0026#34; -d dpage/pgadmin4  -p 80:80 : 호스트와 컨테이너 간의 배포(publish)포트/바인드(bind)포트  호스트 80번 포트를 컨테이너 80번 포트에 매핑   --name : 생성할 컨테이너 이름 -e : 도커 컨테이너의 환경변수 설정  PGADMIN_DEFAULT_EMAIL : pgadmin4 로그인계정 (필수설정) PGADMIN_DEFAULT_PASSWORD : 계정 비밀번호 (필수설정)   -d : 백그라운드에서 컨테이너 실행 dpage/pgadmin4 : 사용할 이미지 이름  2.3. 실행 웹 브라우저에서 localhost:80 주소로 접속하여 설정한 계정과 비밀번호로 접속하면된다.\n","date":"April 29, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/docker/2021-04-29-docker-postgresdb-pgadmin4-setup-guide/","summary":"1. Postgres Docker 이미지 설치 Postgres Version : 13.2\n1.1. 다운로드 및 설정 아래 명령어를 실행한다.\n$ docker run -p 15432:5432 --name postgres -e POSTGRES_PASSWORD=password1! -d postgres  -d : 백그라운드에서 컨테이너 실행 -p 15432:5432 : 호스트와 컨테이너 간의 배포(publish)포트/바인드(bind)포트  호스트 15432번 포트를 컨테이너 5432번 포트에 매핑   --name : 생성할 컨테이너 이름 -e : 도커 컨테이너의 환경변수 설정  POSTGRES_PASSWORD : PostgresDB 관리자 비밀번호    실행 결과","tags":["docker","postgredb"],"title":"PostgreDB, pgadmin4 도커 설치 방법"},{"categories":["Django"],"contents":" 청크단위 파일 업로드  용량제한 없이 대용량파일 업로드 가능 실시간 업로드 상황을 프로그래스바에 응용가능  from django.conf import settings  def upload(request): \tif request.method == \u0026#39;POST\u0026#39;: \tpath = settings.MEDIA_ROOT \tfiles = request.FILES[\u0026#39;file\u0026#39;]  \tfor file in files:  file_path = f\u0026#39;{path}/{file.name}\u0026#39; \twith open(file_path,\u0026#39;wb+\u0026#39;) as dst_file: \tfor chunk in file.chunks(): \tdst_file.write(chunk) ","date":"April 22, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-04-22-django-file-upload/","summary":" 청크단위 파일 업로드  용량제한 없이 대용량파일 업로드 가능 실시간 업로드 상황을 프로그래스바에 응용가능  from django.conf import settings  def upload(request): \tif request.method == \u0026#39;POST\u0026#39;: \tpath = settings.MEDIA_ROOT \tfiles = request.FILES[\u0026#39;file\u0026#39;]  \tfor file in files:  file_path = f\u0026#39;{path}/{file.name}\u0026#39; \twith open(file_path,\u0026#39;wb+\u0026#39;) as dst_file: \tfor chunk in file.chunks(): \tdst_file.write(chunk) ","tags":["django"],"title":"Django 파일 업로드"},{"categories":["Django","Models"],"contents":" api 서버 등 json 데이터로 통신하는 서버에서 사용할 수 있는 예제이다.\n1. 사전 설정 프로젝트 생성 후 user 앱의 User 모델을 생성한다.\n임의의 user 데이터를 2개 등록한다.\nmodels.py\nclass User(models.Model):  id = models.AutoField(primary_key=True)  name = models.CharField(max_length=20, unique=True)  2. 사용 예시 2.1. QuerySet(Model Instance)을 json형태로 변환할 경우 .all() serializers.serialize('json', value_name) 함수를 사용하여 json 형태로 변환시킨다.\nviews.py\nfrom django.core import serializers  res_data = User.objects.all() # \u0026lt;QuerySet [\u0026lt;User: User object (1)\u0026gt;, \u0026lt;User: User object (2)\u0026gt;]\u0026gt;  res_data = serializers.serialize(\u0026#39;json\u0026#39;, res_data) return HttpResponse(res_data, content_type=\u0026#34;text/json-comment-filtered\u0026#34;) 출력결과\n[  {  \u0026#34;model\u0026#34;: \u0026#34;user.user\u0026#34;,  \u0026#34;pk\u0026#34;: 1,  \u0026#34;fields\u0026#34;: {  \u0026#34;name\u0026#34;: \u0026#34;KimTester\u0026#34;,  }  },  {  \u0026#34;model\u0026#34;: \u0026#34;user.user\u0026#34;,  \u0026#34;pk\u0026#34;: 2,  \u0026#34;fields\u0026#34;: {  \u0026#34;name\u0026#34;: \u0026#34;LeeTester\u0026#34;,  }  } ] 2.2. QuerySet(dict)을 json형태로 변환할 경우 .values() QuerySet 자료형은 json 내장함수를 사용할 수 없어 QuerySet를 list형으로 변환시킨후 json.dumps() 함수를 통해 json형태로 변환시킨다.\nviews.py\nimport json  res_data = Template.objects.values(\u0026#39;name\u0026#39;) # res_data = \u0026lt;QuerySet [{\u0026#39;name\u0026#39;: \u0026#39;KimTester\u0026#39;}, {\u0026#39;name\u0026#39;: \u0026#39;LeeTester\u0026#39;}]\u0026gt;  res_data = json.dumps(list(res_data)) return HttpResponse(res_data, content_type=\u0026#34;text/json-comment-filtered\u0026#34;) 출력결과\n[  {  \u0026#34;name\u0026#34;: \u0026#34;KimTester\u0026#34;  },  {  \u0026#34;name\u0026#34;: \u0026#34;LeeTester\u0026#34;  } ] ","date":"April 20, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-04-20-django-model-to-json-response/","summary":"api 서버 등 json 데이터로 통신하는 서버에서 사용할 수 있는 예제이다.\n1. 사전 설정 프로젝트 생성 후 user 앱의 User 모델을 생성한다.\n임의의 user 데이터를 2개 등록한다.\nmodels.py\nclass User(models.Model):  id = models.AutoField(primary_key=True)  name = models.CharField(max_length=20, unique=True)  2. 사용 예시 2.1. QuerySet(Model Instance)을 json형태로 변환할 경우 .all() serializers.serialize('json', value_name) 함수를 사용하여 json 형태로 변환시킨다.\nviews.py\nfrom django.core import serializers  res_data = User.objects.all() # \u0026lt;QuerySet [\u0026lt;User: User object (1)\u0026gt;, \u0026lt;User: User object (2)\u0026gt;]\u0026gt;  res_data = serializers.","tags":["django","models"],"title":"Django json 데이터 반환하기"},{"categories":["Docker"],"contents":" 1. 개요 도커(Docker)는 리눅스 컨테이너를 기반으로 특정 서비스를 패키징하고 배포할 수 있는 오픈소스 프로그램이다.\n 컨테이너 : 리눅스 커널 네임 스페이스, cgroup의 기능을 활용하여 호스트 시스템의 모든 프로세스와 격리된 시스템의 프로세스   2. 도커를 사용하는 이유 도커는 소프트웨어 버전관리, 애플리케이션 배포, 개발환경 구성등 사전에 생성하고 도커 이미지를 배포하고 배포한 이미지를 컨테이너에 담아서 사용된다.\n 도커 이미지 : 컨테이너의 파일시스템과 애플리케이션 실행에 필요한 모든 항목(모든 종속성, 구성, 스크립트, 바이너리, 환경변수, 실행하는 기본 명령)이 포함된다.  도커파일(Docker File)을 만들어서 \u0026ldquo;특정 소프트웨어를 컨테이너에 담아서 구동시킬 것이다.\u0026ldquo;를 명시해주고 빌드(Build)하면, 도커 이미지가 생성됩니다. 그리고 해당 도커 이미지를 구동(run)시키면 도커 컨테이너에서 실행됩니다.\n 3. VM(Virtual Machine)과 컨테이너(Container) 차이점 가상 머신(Virtual Machine) : 하드웨어의 가상화 기능으로 Guest OS를 통해 소프트웨어를 실행한다.\n 예를들면 윈도우 운영체제를 사용하는 Host OS에서 리눅스라는 Guest OS를 실행한다. Host OS와 Guest OS는 서로 의존적이지 않아 각 가상 머신마다 Guest OS를 실행하여야 한다. Guest OS의 I/O 기능을 Host OS를 통해서 실행되기 때문에 속도가 느리다. 또한 설치 용량도 크다.     속도 메모리 사용량 설치 용량     느림 많음 많음(GB단위)    컨테이너(Container) : 별도의 Guest OS 없이 도커 엔진(Docker Engine)에서 동작하여 바로 소프트웨어를 실행한다.\n Guest OS를 사용하지 않아 실행과정이 단순화되어 성능적으로 빨라지고 메모리 용량도 적게 사용한다. Host OS와 도커 컨테이너 간에 의존성이 존재하며 운영체제 환경(Kernel)을 공유한다.     속도 메모리 사용량 설치 용량     빠름 적음 적음(MB단위)     4. 설치 설치환경 : Windows 10 docker version : 3.2.2\nDownload URL - https://www.docker.com/get-started\n다운로드 페이지에서 실행파일을 다운받아 설치한다.\nDocker Desktop 실행한다.\n설치 후 아래와 같은 에러 발생시\n 5. 오류 해결방법   Hyper-V가 비활성화되었거나 설치되지 않은 경우\n 관리자 권한으로 PowerShell 실행 Hyper-V 활성화 후 시스템 재시작\ndism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All\n    Hyper-V 기능이 이미 활성화되어 있지만 작동하지 않는 경우\n 관리자 권한으로 PowerShell 실행 하이퍼 바이저 활성화 후 시스템 재시작\nbcdedit /set hypervisorlaunchtype auto    1,2번 방법으로도 문제가 지속될 경우\n Hyper-V 프로그램이 손상되었을 수 있어 재설치 해야한다. 제어판 - 프로그램 - Windows 기능 켜기/끄기 - Hyper-V 관련요소 체크 해제 후 확인 클릭 시스템 재시작 후 같은 방법으로 Hyper-V 관련요소 체크 후 확인 클릭\n    3번 방법으로도 문제가 지속될 경우\n BIOS에서 CPU 가상화 기능이 활성화 되어있는지 확인하여 비활성화인 경우 활성화 시킨다.    CPU 제조사 가상화 기능     Intel VT-x   AMD SVM         6. 참고사항 다른 가상화 솔루션이 실행되고있는경우 실행되지 않을 수 있다.\n 7. WSL2 설치 시스템 재시작 후 WSL2 설치 안내 메세지에서 kernel update 링크에서 x64 머신용 최신 WSL2 Linux 커널 업데이트 패키지를 다운받아 업데이트한다.\n WSL : 윈도우에서 경량 가상화 기술을 사용하여 리눅스를 구동할 수 있도록 도와주는 기능\n  그 후 Restart 버튼 클릭하여 도커를 재실행한다.\n 8. Docker 대시보드 도커에서 docker tutorial 실행 후 아래의 튜토리얼 진행\nhttp://localhost/tutorial/ ","date":"April 8, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/docker/2021-04-08-docker-summary/","summary":"1. 개요 도커(Docker)는 리눅스 컨테이너를 기반으로 특정 서비스를 패키징하고 배포할 수 있는 오픈소스 프로그램이다.\n 컨테이너 : 리눅스 커널 네임 스페이스, cgroup의 기능을 활용하여 호스트 시스템의 모든 프로세스와 격리된 시스템의 프로세스   2. 도커를 사용하는 이유 도커는 소프트웨어 버전관리, 애플리케이션 배포, 개발환경 구성등 사전에 생성하고 도커 이미지를 배포하고 배포한 이미지를 컨테이너에 담아서 사용된다.\n 도커 이미지 : 컨테이너의 파일시스템과 애플리케이션 실행에 필요한 모든 항목(모든 종속성, 구성, 스크립트, 바이너리, 환경변수, 실행하는 기본 명령)이 포함된다.","tags":["docker"],"title":"도커의 개요 및 windows10 버전 설치 방법"},{"categories":["Django","Models"],"contents":" 1. 정참조와 역참조 객체 호출 데이터베이스의 임의의 테이블로 User, Occupation 생성한다.\n두 테이블은 User 모델의 객체가 Occupation 모델의 객체를 N:1 참조관계를 가진다.\nmodels.py 설정\nclass User(models.Model):  name\t= models.CharField(max_length=50) \tage\t= models.IntegerField()  job\t= models.ForeignKey(\u0026#39;Occupation\u0026#39;, on_delete=models.CASCADE)  class Occupation(models.Model):  name = models.CharField(max_length=50)  2. 정참조 객체 호출하기 user1 객체가 Occupation 모델을 참조키(ForeignKey)로 정참조하여, Occupation 모델의 속성을 사용할 수 있다.\nuser1 = User.objects.get(id = 1) user1.job.name \u0026gt;\u0026gt;\u0026gt; \u0026#39;Developer\u0026#39;  3. 역참조 객체 호출하기 역참조 관계에서는 정참조와 같이 바로 참조한 모델의 속성을 사용할 수 없다.\n하지만 별도의 방법을 사용하면 역참조한 모델의 속성을 사용할 수 있다.\njobs객체를 참조키(ForeignKey)로 참조하고있는 \u0026lsquo;User\u0026rsquo; [classname(소문자)_set] 모델에 객체를 호출할 수 있다.\njobs = Occupation.objects.get(id=1) jobs.user_set.get().age \u0026gt;\u0026gt;\u0026gt; 20 3.1. 1:N 참조 관계  역참조 목록 list로 반환  [역참조할 모델 인스턴스].[정참조한 모델 클래스]_set.all()  특정 조건을 만족하는 역참조 목록 list로 반환  [역참조할 모델 인스턴스].[정참조한 모델 클래스]_set.filter(참조키=조건값) 3.2. 1:1 참조 관계  역참조 항목 반환  [역참조할 모델 인스턴스].[정참조한 모델 클래스]_set.all()  특정 조건을 만족하는 역참조 항목 반환  [역참조할 모델 인스턴스].[정참조한 모델 클래스]_set.filter(참조키=조건값) ","date":"April 7, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-models-relations-object-call/","summary":"1. 정참조와 역참조 객체 호출 데이터베이스의 임의의 테이블로 User, Occupation 생성한다.\n두 테이블은 User 모델의 객체가 Occupation 모델의 객체를 N:1 참조관계를 가진다.\nmodels.py 설정\nclass User(models.Model):  name\t= models.CharField(max_length=50) \tage\t= models.IntegerField()  job\t= models.ForeignKey(\u0026#39;Occupation\u0026#39;, on_delete=models.CASCADE)  class Occupation(models.Model):  name = models.CharField(max_length=50)  2. 정참조 객체 호출하기 user1 객체가 Occupation 모델을 참조키(ForeignKey)로 정참조하여, Occupation 모델의 속성을 사용할 수 있다.\nuser1 = User.objects.get(id = 1) user1.job.name \u0026gt;\u0026gt;\u0026gt; \u0026#39;Developer\u0026#39;  3.","tags":["django","models"],"title":"Django model 참조 객체 호출하기"},{"categories":["Django","Models"],"contents":" 1. Django 동적 모델 및 테이블 생성 django는 makemigrations, migrate 명령어를 통하여 테이블 생성한다.\n이때 웹서버는 실행중일 경우 중단하고 다시 재시작한다.\n운영환경에 따라서 웹서버가 중단되지 않고 운영이 필요한경우에는 위의 방법이 아닌 동적 모델 및 테이블 생성방법이 필요하다.\n 2. 예시코드 2.1. 상속받을 추상모델 작성 models.py\nfrom django.db import models  class Board(models.Model): \ttitle = models.CharField(max_length=100) \tcontents = models.CharField(max_length=500) \t class Meta:  abstract = True 2.2. 동적 모델 생성 및 삭제 from .models import Board  TABLE_MAP = {}  def create_model(name: str): \t\u0026#39;\u0026#39;\u0026#39; 동적 모델 생성 \u0026#39;\u0026#39;\u0026#39; \tbaseclass = Board \ttablename = board2 \t# attrs 를 dict 형태로 지정한다. \tclass Meta: \tdb_table = tablename \tattrs = { \t\u0026#39;__module__\u0026#39;: baseclass.__module__, \t\u0026#39;Meta\u0026#39;: Meta, \t} \t# 클래스 타입을 지정하여 객체(클래스 명, 복사 참조 클래스, 속성값)를 지정한다.  \tTABLE_MAP[name] = type(name, (baseclass,), attrs)  def delete_model(name: str): \t\u0026#39;\u0026#39;\u0026#39; 동적 모델 삭제 \u0026#39;\u0026#39;\u0026#39; \tdel TABLE_MAP[name] 2.3. 동적 테이블 생성 및 삭제 from django.db import connection  def create_table(name: str): \t\u0026#39;\u0026#39;\u0026#39; 동적 테이블 생성 \u0026#39;\u0026#39;\u0026#39; \twith connection.schema_editor() as schema_editor: \tschema_editor.create_model(TABLE_MAP[name])  def delete_table(name: str): \t\u0026#39;\u0026#39;\u0026#39; 동적 테이블 삭제 \u0026#39;\u0026#39;\u0026#39; \twith connection.schema_editor() as schema_editor: \tschema_editor.delete_model(TABLE_MAP[name])  참고(Reference)  추상클래스  모델 생성시 사용   closure 사용하기  모델 생성시 type() 동작 원리   django 동적 모델 생성  type 활용   django 동적 테이블 생성  connection.schema_editor    ","date":"April 7, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-dynamic-model-and-table-create/","summary":"1. Django 동적 모델 및 테이블 생성 django는 makemigrations, migrate 명령어를 통하여 테이블 생성한다.\n이때 웹서버는 실행중일 경우 중단하고 다시 재시작한다.\n운영환경에 따라서 웹서버가 중단되지 않고 운영이 필요한경우에는 위의 방법이 아닌 동적 모델 및 테이블 생성방법이 필요하다.\n 2. 예시코드 2.1. 상속받을 추상모델 작성 models.py\nfrom django.db import models  class Board(models.Model): \ttitle = models.CharField(max_length=100) \tcontents = models.CharField(max_length=500) \t class Meta:  abstract = True 2.2. 동적 모델 생성 및 삭제 from .","tags":["django","models"],"title":"Django 동적 모델 및 테이블 생성"},{"categories":["Django","Models"],"contents":" 1. QuerySet 이란? Database에서 응답받은 결과 목록(list)으로 Python 코드가 SQL 구문으로 맵핑(mapping)되고 DB로 전달하여 받은 응답값을 QuerySet 자료형으로 반환한다.\n 2. 사전설정 django version : 3.2\nmodels.py\nfrom django.db import models  class User():  name = models.CharField(max_length=20)  age = models.models.PositiveSmallIntegerField() \u0026gt;\u0026gt;\u0026gt; python manage.py shell #shell 실행 \u0026gt;\u0026gt;\u0026gt; from user.models import User #모델클래스 임포트 \u0026gt;\u0026gt;\u0026gt; user1 = User(name=\u0026#39;Foo\u0026#39;, age=15) # 데이터추가 \u0026gt;\u0026gt;\u0026gt; user1.save() # 데이터 저장 \u0026gt;\u0026gt;\u0026gt; user2 = User(name=\u0026#39;Bar\u0026#39;, age=20) # 데이터추가 \u0026gt;\u0026gt;\u0026gt; user2.save() # 데이터 저장  3. 객체별 접근방식 Database Table구조는 column(세로)과 row(가로)로 구분된다.\n   id name age     1 Foo 15   2 Bar 20     column : 모델(model)클래스에서 지정한 속성 row : 각 속성에 부여된 값  3.1. 단일 객체 \u0026lt;모델클래스\u0026gt;.objects.get(id=1) or \u0026lt;모델클래스\u0026gt;.objects.latest(\u0026#39;id\u0026#39;)  DB테이블 데이터의 행 하나를 dictionary 자료형으로 반환한다. 해당 조건의 요소가 존재하지 않을때는 DoesNotExist 에러가 발생한다. .get() 조건으로 여러개 존재할때는 MultipleObjectsReturned 에러가 발생한다. 객체 하나로 반환되기 때문에, .(dot notation)으로 접근할 수 있다. \u0026lt;variable name\u0026gt;.name  \u0026gt;\u0026gt;\u0026gt; user = User.objects.get(id=1) \u0026gt;\u0026gt;\u0026gt; user.name \u0026#39;Foo\u0026#39; 3.2. 다중 객체 all \u0026lt;모델클래스\u0026gt;.objects.all()  all()은 QuerySet안의 모든 객체를 list 자료형으로 반환한다. 따라서, \u0026lt;variable name\u0026gt;[index] 형식으로 접근할 수 있다.  \u0026gt;\u0026gt;\u0026gt; user = User.objects.all() \u0026gt;\u0026gt;\u0026gt; user \u0026lt;QuerySet [\u0026lt;User: User object (1)\u0026gt;, \u0026lt;User: User object (2)\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; user[1] \u0026lt;User: User object (2)\u0026gt; filter \u0026lt;모델클래스\u0026gt;.objects.filter()  filter()는 조건식에 따라 필터링하여 query의 결과를 list 자료형으로 반환한다. QuerySet()은 list 형태이고, list 요소는 dictionary 자료형이다. \u0026lt;variable name\u0026gt;[index][key] 형식이로 key를 통해 value에 접근할 수 있다.  \u0026gt;\u0026gt;\u0026gt; user = User.objects.filter(name__startswith=\u0026#39;F\u0026#39;) \u0026gt;\u0026gt;\u0026gt; user \u0026lt;QuerySet [\u0026lt;User: User object (1)\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; user[0].name \u0026#39;Foo\u0026#39; 3.3. 결과 조회 입력한 컬럼에 대한 값만 조회한다.\nvalues \u0026lt;모델클래스\u0026gt;.objects.values() 객체정보가 아닌 dictionary와 list의 자료형의 값으로 반환한다.\n\u0026gt;\u0026gt;\u0026gt; User.objects.values(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) \u0026lt;QuerySet [{\u0026#39;name\u0026#39;: \u0026#39;Foo\u0026#39;, \u0026#39;age\u0026#39;: 15}, {\u0026#39;name\u0026#39;: \u0026#39;Bar\u0026#39;, \u0026#39;age\u0026#39;: 20}]\u0026gt; valies_list \u0026lt;모델클래스\u0026gt;.objects.values_list()  각 ID값이 분리된 2차원 list 자료형으로 반환한다.  \u0026gt;\u0026gt;\u0026gt; User.objects.values_list(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) \u0026lt;QuerySet [(\u0026#39;Foo\u0026#39;, 15), (\u0026#39;Bar\u0026#39;, 20)]\u0026gt;  flat 옵션 사용시 필드 조회 결과값을 1차원 list 자료형으로 반환한다. 2개이상의 필드 입력시 TypeError 에러가 발생한다.  \u0026gt;\u0026gt;\u0026gt; User.objects.values_list(\u0026#39;name\u0026#39;, flat=True) \u0026lt;QuerySet [\u0026#39;Foo\u0026#39;, \u0026#39;Bar\u0026#39;]\u0026gt; order_by \u0026lt;모델클래스\u0026gt;.objects.values().order_by() 조회된 결과값을 특정 필드명을 기준으로 정렬하여 반환한다.\n order_by 에서 지정한 필드명 앞에 -붙이면 내림차순 정렬된다.  \u0026gt;\u0026gt;\u0026gt; User.objects.values(\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;).order_by(\u0026#39;id\u0026#39;) \u0026lt;QuerySet [{\u0026#39;id\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;Foo\u0026#39;}, {\u0026#39;id\u0026#39;: 2, \u0026#39;name\u0026#39;: \u0026#39;Bar\u0026#39;}]\u0026gt;  \u0026gt;\u0026gt;\u0026gt; User.objects.values(\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;).order_by(\u0026#39;-id\u0026#39;) \u0026lt;QuerySet [{\u0026#39;id\u0026#39;: 2, \u0026#39;name\u0026#39;: \u0026#39;Bar\u0026#39;}, {\u0026#39;id\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;Foo\u0026#39;}]\u0026gt; 특정 갯수 조회 \u0026lt;모델클래스\u0026gt;.objects.values()[검색시작 index : 검색종료 index] 검색 쿼리의 범위 지정할 수 있다.\n list index 형식과 동일하다. queryset 구문을 sql 질의문으로 변환 str(queryset.query) 하여 확인하면 SQL 쿼리문 끝에 limit 사용한 것을 볼 수 있다.  \u0026gt;\u0026gt;\u0026gt; User.objects.values(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;)[0:1] \u0026lt;QuerySet [{\u0026#39;id\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;Foo\u0026#39;}]\u0026gt;  \u0026gt;\u0026gt;\u0026gt; User.objects.values(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;)[:1] \u0026lt;QuerySet [{\u0026#39;id\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;Foo\u0026#39;}]\u0026gt;  \u0026gt;\u0026gt;\u0026gt; User.objects.values(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;)[1:2] \u0026lt;QuerySet [{\u0026#39;id\u0026#39;: 2, \u0026#39;name\u0026#39;: \u0026#39;Bar\u0026#39;}]\u0026gt; ","date":"April 6, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-04-06-django-queryset-object-access/","summary":"1. QuerySet 이란? Database에서 응답받은 결과 목록(list)으로 Python 코드가 SQL 구문으로 맵핑(mapping)되고 DB로 전달하여 받은 응답값을 QuerySet 자료형으로 반환한다.\n 2. 사전설정 django version : 3.2\nmodels.py\nfrom django.db import models  class User():  name = models.CharField(max_length=20)  age = models.models.PositiveSmallIntegerField() \u0026gt;\u0026gt;\u0026gt; python manage.py shell #shell 실행 \u0026gt;\u0026gt;\u0026gt; from user.models import User #모델클래스 임포트 \u0026gt;\u0026gt;\u0026gt; user1 = User(name=\u0026#39;Foo\u0026#39;, age=15) # 데이터추가 \u0026gt;\u0026gt;\u0026gt; user1.save() # 데이터 저장 \u0026gt;\u0026gt;\u0026gt; user2 = User(name=\u0026#39;Bar\u0026#39;, age=20) # 데이터추가 \u0026gt;\u0026gt;\u0026gt; user2.","tags":["django","models"],"title":"Django QuerySet 객체 접근방식 및 조회"},{"categories":["Django","Models"],"contents":" model 상속할때 테이블 컬럼 데이터 자동 생성방법\n 라이브러리 설치 pip install django-annoying  models 설정 django의 models.OneToOneField는 데이터 변경없이(default 설정) 저장하면 해당 데이터(row)가 생성되지않음\nmodels.AutoOneToOneField는 데이터가 default값이어도 데이터(row) 생성됨\nfrom annoying.fields import AutoOneToOneField  # User모델 Save에서 제어 class User(models.Model):  name = models.CharField(max_length=30)  def save(self):  is_new = False  if self.pk is None:  is_new = True   if is_new:  Profile.objects.create(user=self)  class Profile(models.Model):  user = AutoOneToOneField(User, primary_key=True) \thome_page = models.URLField(max_length=255, blank=True)  icq = models.IntegerField(blank=True, null=True)  참고사항 문제점 : TypeError: __init__() missing 1 required positional argument: 'on_delete' 에러 발생\n Django model에서 ForeignKey 사용하는 경우 발생하는 에러로 Django 2.0이상 버전에서는 파라미터 2개를 입력받음 AutoOneToOneField \u0026gt; OneToOneField \u0026gt; ForeignKey 클래스 순으로 상속함 Docs : ForeignKey  해결방법 : on_delete 파라미터 추가작성\nclass Profile(models.Model):  user = AutoOneToOneField(User, primary_key=True, on_delete=models.CASCADE)  models.CASCADE 옵션 : RestrictedError(django.db의 하위클래스) 발생시켜 참조된 객체의 삭제를 방지함(무결성 오류 방지) models.RESTRICT 옵션 : CASCADE 관계를 통해 참조된 객체도 같이 삭제함 Docs : on_delete  ","date":"March 31, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/framework/django/2021-03-31-django-models-autoonetoonefield/","summary":"model 상속할때 테이블 컬럼 데이터 자동 생성방법\n 라이브러리 설치 pip install django-annoying  models 설정 django의 models.OneToOneField는 데이터 변경없이(default 설정) 저장하면 해당 데이터(row)가 생성되지않음\nmodels.AutoOneToOneField는 데이터가 default값이어도 데이터(row) 생성됨\nfrom annoying.fields import AutoOneToOneField  # User모델 Save에서 제어 class User(models.Model):  name = models.CharField(max_length=30)  def save(self):  is_new = False  if self.pk is None:  is_new = True   if is_new:  Profile.objects.create(user=self)  class Profile(models.","tags":["django","models"],"title":"Django models AutoOneToOneField 사용법"},{"categories":["Python","Guide"],"contents":" python 파일을 윈도우에서 python 이나 가상환경 설정없이 실행이 가능한 .exe 으로 변환해주는 라이브러리\n 1. 설치 설치환경 : Windows 10\npython 실행이 가능한 가상환경 터미널에서 아래의 명령어 실행\npip install pyinstaller  2. 간단한 사용예제 pyinstaller --clean --distpath . -F -n [프로그램이름] [변환시킬 파일].py  3. 옵션    옵션 설명     \u0026ndash;clean 빌드하기 전에 PyInstaller 캐시를 정리하고 임시파일 제거   -F, \u0026ndash;onefile 단일 실행파일로 생성(실행시 사용한 라이브러리 임시파일 생성됨)   -D, \u0026ndash;onedir 실행 파일을 포함하는 단일 폴더로 생성   \u0026ndash;distpath DIR 실행파일 생성 경로(default: ./dist)   -n 실행파일 이름 지정   -c, \u0026ndash;console, \u0026ndash;nowindowed console 모드   -w, \u0026ndash;windowed, \u0026ndash;noconsole Not console 모드   \u0026ndash;hidden-import import 에러 발생한 라이브러리 명시적 포함옵션 이 옵션은 여러 번 사용가능   -win-private-assemblies 응용프로그램에 번들로 제공된 모든 공유 어셈블리가 개인 어셈블리로 변경 즉, 변환한 환경의 어셈블리 버전으로 항상 사용되며 사용자 시스템에 설치된 모든 최신 버전은 시스템 수준에서 무시됨   -runtime-tmpdir PATH onefile 모드 에서 라이브러리 및 지원 파일이 압축 해제될 위치 .exe 실행시 생성되는 임시디렉토리 경로지정 (default : C:\\Users{username}\\AppData\\Local\\Temp)   \u0026ndash;icon=icon.ico 실행파일에 포함될 아이콘 지정   -p DIR, \u0026ndash;paths DIR 가져오기를 검색하는 경로 (예: PYTON PATH 사용) 경로가 여러 개 허용되거나 \u0026lsquo;:\u0026lsquo;로 구분되거나 이 옵션을 여러 번 사용할 수 있습니다. \u0026ndash;paths .\\venv\\Lib\\site-packages   -workpath WORKPATH 모든 임시 작업 파일, .log, .pyz 등을 저장할 위치 (기본값 : ./build)    3.1 ^ 줄넘김 옵션 옵션줄이 길어질경우 가독성을 위해 ^ 문자로 구분하여 명령 실행\npyinstaller --clean ^ \t--distpath . ^ \t--onedir ^ \t-n [프로그램이름] ^ \t--win-private-assemblies ^ \t--runtime-tmpdir ./temp ^ \t--console ^ \t--icon=logo.ico ^ \t--key [바이트 AES블록암호화 키 16자리 문자열] ^ \trun.py 3.2 실행파일 바이트코드 블록 암호화 필요한 라이브러리 설치\npip install tinyaes key : AES 블록암호화 키 문자열 16자리\npyinstaller --clean ^ \t--onedir ^ \t-n [프로그램이름] ^ \t--win-private-assemblies ^ \t--key [암호화키 문자열 16자리] ^ \trun.py  4. 참고사항 4.1 python 코드가 아닌 외부 참조 파일사용시 별도로 추가필요 예를 들어 ./config/config.json 파일이 있으면\n.exe 생성후 같은 상대경로에 config.json 파일이 있어야 실행파일이 해당 외부참조 파일사용 가능함\n생성된 실행파일이 있는 디렉토리안에 config 디렉토리에서 사용하는 .json 파일 복사\n4.2 별도의 외장 라이브러리 사용시 주의사항 문제점 : python 라이브러리에서 조건문을 통한 import 사용시 pyinstaller 에서 인식하지 못함 해결방안 : 조건문 없이도 import 할 수 있도록 라이브러리 코드 수정해야함\n해결예시 : tensorpack 라이브러리 디렉토리안에 모든 __init__.py 파일에서 if STATICA_HACK 조건문을 통한 import 코드를 조건문 없이 import 하도록 코드 수정\n4.3 tensorflow 사용시 문제점 : numpy import error 발생\n해결방안 : 별도로 numpy import 필요함\n--hidden-import numpy.random.common ^ --hidden-import numpy.random.bounded_integers ^ --hidden-import numpy.random.entropy ^ 문제점 : tensorflow 1.15버전 이후부터 라이브러리 폴더명이 tensorflow-core 로 수정되어 인식하지 못함\n해결방안 : tensorflow 폴더를 인식할 수 있도록 수정한 hooks-contrib 버전 업데이트\npip install \u0026quot;pyinstaller-hooks-contrib==2020.9\u0026quot;\n4.4 아이콘 파일 옵션 적용시 참고사항 문제점 : 아이콘 옵션 적용 후 아이콘이 변경되지 않을경우 windows 시스템 버퍼에 저장된 이미지가 적용되어 안바뀐것 처럼 보임\n해결방안 : 정상적으로 적용이 되었으나 버퍼상에 전 이미지가 남아있는것으로 다른 경로로 복사하여 아이콘 이미지 적용이 되었는지 확인\n4.5 멀티프로세싱 사용시 주의사항 문제점 : windows10 환경에서 멀티프로세싱 기능을 사용할때 exe 프로세스마다 main함수가 실행이 됩니다.\n해결방안 : freeze_support() 함수 호출 후 main 함수를 호출하면 관련된 exe 프로세스에서 main함수는 1번만 실행됩니다.\nfrom sys import platform from multiprocessing import freeze_support  if __name__ == \u0026#39;__main__\u0026#39;:  if platform.startswith(\u0026#39;win\u0026#39;):  # 윈도우에서만 해당 코드 실행  freeze_support() \tmain()  참고(Reference)  Using PyInstaller Docs  ","date":"March 10, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-03-10-pyinstaller-guide/","summary":"python 파일을 윈도우에서 python 이나 가상환경 설정없이 실행이 가능한 .exe 으로 변환해주는 라이브러리\n 1. 설치 설치환경 : Windows 10\npython 실행이 가능한 가상환경 터미널에서 아래의 명령어 실행\npip install pyinstaller  2. 간단한 사용예제 pyinstaller --clean --distpath . -F -n [프로그램이름] [변환시킬 파일].py  3. 옵션    옵션 설명     \u0026ndash;clean 빌드하기 전에 PyInstaller 캐시를 정리하고 임시파일 제거   -F, \u0026ndash;onefile 단일 실행파일로 생성(실행시 사용한 라이브러리 임시파일 생성됨)   -D, \u0026ndash;onedir 실행 파일을 포함하는 단일 폴더로 생성   \u0026ndash;distpath DIR 실행파일 생성 경로(default: .","tags":["python","library"],"title":"pyinstaller 라이브러리 사용법 (Pyinstaller Library Guide)"},{"categories":["Go","Learning"],"contents":" 1. 디렉토리 관련 함수 2021년 3월 3일 수요일 오전 8:55:31\n1.1. 단일 디렉토리 생성 os.Mkdir(path, permission)\nerr := os.Mkdir(\u0026#34;tmp\u0026#34;, 0755) if err != nil {  log.Fatal(err) } 1.2. 다중 디렉토리 생성 os.MkdirAll(path, permission) :\nerr := os.MkdirAll(\u0026#34;tmp/new\u0026#34;, 0755) if err != nil {  log.Fatal(err) } 1.3. 현재 작업 디렉토리 얻기 os.Getwd()\npath, err := os.Getwd() if err != nil {  log.Println(err) } fmt.Println(path) 1.4. 디렉토리 존재유무 확인 os.Stat(paht)\nif _, err := os.Stat(\u0026#34;/dirname\u0026#34;); os.IsNotExist(err) { \t// does not exist }  if _, err := os.Stat(\u0026#34;/dirname\u0026#34;); !os.IsNotExist(err) { \t// exist } 1.5. 디렉토리 이름 바꾸기 os.Rename(oldpath, newpath)\nerr := os.Rename(\u0026#34;tmp\u0026#34;, \u0026#34;tmp2\u0026#34;) if err != nil {  log.Fatal(err) }  2. struct 구조체 기본값 지정 2021년 3월 3일 수요일 오후 5:43:23\n{  \u0026#34;index\u0026#34;:0,  \u0026#34;value\u0026#34;:\u0026#34;bar\u0026#34;,  \u0026#34;result\u0026#34;:false } package main  import (  \u0026#34;encoding/json\u0026#34;  \u0026#34;fmt\u0026#34; )  type Config struct {  Index int\t`json:\u0026#34;index\u0026#34;`  Value string `json:\u0026#34;value\u0026#34;`  Result bool `json:\u0026#34;result\u0026#34;` }  var data = Config{}  func main() {  con, err := ioutil.ReadFile(\u0026#34;config.json\u0026#34;) \tif err != nil { \tlog.Print(err) \t} \tif err := json.Unmarshal(con, \u0026amp;data); err != nil { \tlog.Print(err) \t}  fmt.Println(data) }  3. Time 변수 문자열 변환 (convert time.Time to string) 2021년 3월 4일 목요일 오후 2:54:09\n// caution : format string is `2006-01-02 15:04:05.000000000` nowTime := time.Now()  fmt.Println(\u0026#34;origin :\u0026#34;, nowTime.String()) // origin : 2021-03-03 15:26:37.123456789 +0900 KST  fmt.Println(\u0026#34;mm-dd-yyyy :\u0026#34;, nowTime.Format(\u0026#34;01-02-2006\u0026#34;)) // mm-dd-yyyy : 03-03-2021  fmt.Println(\u0026#34;yyyy-mm-dd :\u0026#34;, nowTime.Format(\u0026#34;2006-01-02\u0026#34;)) // yyyy-mm-dd : 2021-03-03  // separated by . fmt.Println(\u0026#34;yyyy.mm.dd :\u0026#34;, nowTime.Format(\u0026#34;2006.01.02\u0026#34;)) // yyyy.mm.dd : 2021.03.03  fmt.Println(\u0026#34;yyyy-mm-dd HH:mm:ss :\u0026#34;, nowTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) // yyyy-mm-dd HH:mm:ss : 2021-03-03 15:26:37  // Stamp Micro second fmt.Println(\u0026#34;yyyy-mm-dd HH:mm:ss :\u0026#34;, nowTime.Format(\u0026#34;2006-01-02 15:04:05.000000\u0026#34;)) // yyyy-mm-dd HH:mm:ss : 2021-03-03 15:26:37.123456  // Stamp Nano second fmt.Println(\u0026#34;yyyy-mm-dd HH:mm:ss :\u0026#34;, nowTime.Format(\u0026#34;2006-01-02 15:04:05.000000000\u0026#34;)) // yyyy-mm-dd HH:mm:ss : 2021-03-03 15:26:37.123456789  4. 디렉토리 내 파일목록 읽기 2021년 3월 4일 목요일 오후 5:45:44\nioutil.ReadDir(path)\nfiles, err := ioutil.ReadDir(\u0026#34;tmp\u0026#34;) if err != nil{  fmt.Println(err) } for i ,f := range files {  fmt.Println(i, f.Name()) } 0 test1.txt 1 test2.txt  5. 문자열 분할 2021년 3월 8일 월요일 오전 1:21:36\nSplit (s, sep string ) [] string\ntmp := \u0026#34;one_two_three\u0026#34; slice := strings.Split(tmp, \u0026#34;_\u0026#34;)  for i, str := range slice {  fmt.Println(i, str) } 0 one 1 two 2 three SplitAfter(s, sep string) []string\ntmp := \u0026#34;one_two_three\u0026#34; slice := strings.SplitAfter(tmp, \u0026#34;_\u0026#34;)  for i, str := range slice {  fmt.Println(i, str) } 0 one_ 1 two_ 2 three 아래의 함수는 split 횟수를 n번으로 제한하는 함수\nSplitN(s, sep string, n int) []string\nSplitAfterN(s, sep string, n int) []string\n 6. 타입 확인 2021년 3월 8일 월요일 오전 9:26:56\nreflect.TypeOf(i interface{}) reflect.Type\nx, y, z := 1, \u0026#34;2\u0026#34;, 3.14  fmt.Println(\u0026#34;x type :\u0026#34;, reflect.TypeOf(x)) fmt.Println(\u0026#34;y type :\u0026#34;, reflect.TypeOf(y)) fmt.Println(\u0026#34;z type :\u0026#34;, reflect.TypeOf(z)) x type : int y type : string z type : float64  7. 타입 변경 strconv\n7.1. 숫자 변환 Atoi : 문자열에서 int로\nItoa : int에서 문자열로\ni, err := strconv.Atoi(\u0026#34;-42\u0026#34;) s := strconv.Itoa(-42) 문자열을 값으로 변환\nb, err := strconv.ParseBool(\u0026#34;true\u0026#34;) f, err := strconv.ParseFloat(\u0026#34;3.1415\u0026#34;, 64) i, err := strconv.ParseInt(\u0026#34;-42\u0026#34;, 10, 64) u, err := strconv.ParseUint(\u0026#34;42\u0026#34;, 10, 64) 문자열을 가장 넓은 유형 (float64, int64 및 uint64)을 반환\n size 인수가 더 좁은 너비를 지정하면 결과를 데이터 손실없이 더 좁은 유형으로 변환  s := \u0026#34;2147483647\u0026#34; // biggest int32 i64, err := strconv.ParseInt(s, 10, 32) ... i := int32(i64) 값을 문자열로 변환\ns := strconv.FormatBool(true) s := strconv.FormatFloat(3.1415, \u0026#39;E\u0026#39;, -1, 64) s := strconv.FormatInt(-42, 16) s := strconv.FormatUint(42, 16) 7.2. 문자열 변환 2021년 3월 8일 월요일 오전 10:14:38\n문자열을 인용 된 Go 문자열 리터럴로 변환\nq := strconv.Quote(\u0026#34;Hello, World\u0026#34;) q := strconv.QuoteToASCII(\u0026#34;Hello, World\u0026#34;)  8. 에러 핸들링 2021년 3월 8일 월요일 오전 10:52:04\n8.1. 복합한 에러 핸들링 빈 디렉토리 tmp 생성후 해당 코드 실행시\n*fs.PathError 에러가 발생하는데 아래의 switch case err.(*fs.PathError) 구문으로 별도의 에러 핸들링이 가능해진다.\ndirPath := \u0026#34;tmp\u0026#34; files, err := ioutil.ReadDir(dirPath) switch err { case nil:  break case err.(*fs.PathError):  fmt.Println(\u0026#34;[findKey] 현재 디렉토리에 파일이 없습니다.\u0026#34;) default:  fmt.Println(\u0026#34;[findKey] Error :\u0026#34;, err) }  9. 특정 날짜/시간 동작 2021년 3월 8일 월요일 오후 1:29:32\ngo get github.com/robfig/cron c := cron.New() c.AddFunc(\u0026#34;@midnight\u0026#34;, func() {  findKey() }) c.Start() customLocation, _ := time.LoadLocation(\u0026#34;Asia/Seoul\u0026#34;) c := cron.NewWithLocation(customLocation) c.AddFunc(\u0026#34;@midnight\u0026#34;, func() {  fmt.Print(\u0026#34;time :\u0026#34;, time.Now()) }) c.Start()  10. 로그파일 작성 2021년 3월 8일 월요일 오후 1:29:32\nrl, _ := rotatelogs.New( \u0026#34;D:/tmp/Logfile.%Y-%m-%d.log\u0026#34;, rotatelogs.WithMaxAge(-1), // 정해진 시간보다 지난 파일 삭제 (-1은 비활성화) rotatelogs.WithRotationTime(time.Hour), // 로테이션 반복 주기 rotatelogs.WithClock(rotatelogs.Local), // 로컬 시간으로 설정 rotatelogs.WithRotationCount(30), // 유지되는 파일 개수 ) log.SetFlags(log.Ldate | log.Ltime | log.Lmicroseconds) log.SetOutput(rl)  log.Println(\u0026#34;log write\u0026#34;)  11. 프로젝트내 다른 로컬패키지 호출 2021년 3월 11일 목요일 오후 6:02:36\ngo언어는 패키지를 GOPATH 기준으로 검색하기때문에\nGOPATH가 아닌 다른경로에서 프로젝트를 개발할 경우\n프로젝트이름 기준으로 패키지 검색\n디렉토리 구조 예시\nproject1 ├── package1/ | └── package1.go └── package2/ └── package2.go 11.1. 로컬패키지 호출 예시 package1.go파일에서 로컬패키지 package2 호출\n./package1.go\nimport (  \u0026#34;project1/package2\u0026#34; ) 11.2. 잘못 사용한 예시 go언어에서는 import 구문으로 상대경로를 사용하지 않음\nimport (  \u0026#34;../package2\u0026#34; )  12. uint16형 데이터 2Byte형태로 변환 b := make([]byte, 2) binary.BigEndian.PutUint16(b, uint16(258))  fmt.Println(string(b))  13. 서로 다른 byte 데이터 비교 b := make([]byte, 2) binary.BigEndian.PutUint16(b, uint16(258))  if bytes.Compare(b, []byte{1, 2}) == 0 {  fmt.Println(\u0026#34;같은 데이터 입니다.\u0026#34;) } ","date":"March 2, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-03-02-golang-grammar/","summary":"1. 디렉토리 관련 함수 2021년 3월 3일 수요일 오전 8:55:31\n1.1. 단일 디렉토리 생성 os.Mkdir(path, permission)\nerr := os.Mkdir(\u0026#34;tmp\u0026#34;, 0755) if err != nil {  log.Fatal(err) } 1.2. 다중 디렉토리 생성 os.MkdirAll(path, permission) :\nerr := os.MkdirAll(\u0026#34;tmp/new\u0026#34;, 0755) if err != nil {  log.Fatal(err) } 1.3. 현재 작업 디렉토리 얻기 os.Getwd()\npath, err := os.Getwd() if err != nil {  log.Println(err) } fmt.Println(path) 1.4. 디렉토리 존재유무 확인 os.","tags":["go","learning"],"title":"Go 언어 문법 (Golang grammar)"},{"categories":["Go","Learning","Scraper"],"contents":" 0. 소개 설치 환경 : Windows 10 IDE : vscode\n0.1. 설치 해당 URL에서 golang 설치파일을 다운받아 실행\n https://golang.org/dl/ 설치파일에서 안내한 경로인 C:\\Program Files\\Go 폴더에 Go 설치 되었는지 확인  0.2. 설정  Go Path 환경변수 확인   Go는 지정된 Go Path 디렉토리에만 저장되어야함 시스템 환경변수에 등록된 GOPATH 값 확인 %USERPROFILE%\\go -\u0026gt; C:\\Users\\[Profle_Name]\\go 해당 경로가 Go Path 환경변수로 사용되는 경로  기본 설정   go 디렉토리로 이동하여 bin, pkg, src 디렉토리 생성 src 디렉토리안에 지정된 도메인 디렉토리 추가  go에서 다운받은 코드를 지정된 도메인 별로 분류하여 저장   src 디렉토리안에 github.com 디렉토리 생성 github.com 디렉토리안에 깃유저별로 디렉토리 구분하여 저장 C:\\Users\\[Profle_Name]\\go\\src\\github.com\\[git_username]\\learngo\\ 디렉토리 생성  vscode 실행   learngo 디렉토리내 main.go 파일 생성 후 vscode로 실행 vscode 우측 하단에 표시된 go 관련 Extensions 업데이트 모두 설치 vscode 재실행   1. 이론 1.0. Main Package 컴파일 되기 위해서는 main.go 파일에 코드 작성해야함\n또한 main pkackage 와 main function 을 꼭 호출해야함\n go 컴파일시 맨 처음 호출되는 부분이기 때문  package main  func main() {  } go 파일 실행 명령어\ngo run main.go 1.1. Packages and Imports 터미널에서 문자열 출력\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfmt.Println(\u0026#34;Hello World\u0026#34;) } vscode에서는 import 없이 함수를 사용해도 ctrl+s 저장하면 자동으로 import 코드를 추가해줌\n반대로 함수를 사용하지 않으면 import 코드가 사라짐\nfmt : formatting을 위한 package\n 다른 package function을 export 하고 싶으면 대문자로 시작되는 function을 호출 소문자로 시작하는 함수는 private 함수로 외부에서 호출할 수 없음  1.2. 변수와 상수(Variables and Constants) const : 상수\nlet : 변수\n Go 언어는 타입언어로 타입을 지정해야만 사용가능 정해진 타입은 수정할 수 없음 축약형 선언은 func 안에서만 사용가능하고 변수에만 적용  package main  import \u0026#34;fmt\u0026#34;  func main() { \tconst name1 string = \u0026#34;first\u0026#34; \tfmt.Println(name1)  \tvar name2 string = \u0026#34;first\u0026#34; \tname2 = \u0026#34;second\u0026#34; \tfmt.Println(name2)  \tname3 := \u0026#34;third\u0026#34; \tfmt.Println(name3) } 1.3. 함수(Functions) Go 언어에서 사용가능한 Type 목록\n https://go101.org/article/type-system-overview.html https://golang.org/pkg/go/types/  func에서 변수와 반환을 전달할때는 해당 변수의 타입이 무엇인지 명시해야함\npackage main  import \u0026#34;fmt\u0026#34;  func multiply(a int, b int) int { // (a, b int) 도 가능 \treturn a * b }  func main() { \tfmt.Println(multiply(2, 2)) } 함수에서 여러개 변수 return 가능함\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func lenAndUpper(name string) (int, string) { \treturn len(name), strings.ToUpper(name) }  func main() { \ttotalLenght, _ := lenAndUpper(\u0026#34;first\u0026#34;) // _ 변수 무시가능 \tfmt.Println(totalLenght) \ttotalLenght, upperName := lenAndUpper(\u0026#34;first\u0026#34;) \tfmt.Println(totalLenght, upperName) } 함수에 매개변수 여러개를 전달하여 호출하기\n 매개변수 type 앞에 \u0026hellip;(3개) 추가 아래 코드 실행결과는 array 형태로 출력됨 [one two three]  package main  import \u0026#34;fmt\u0026#34;  func repeatMe(words ...string) { \tfmt.Println(words) }  func main() { \trepeatMe(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;) } 함수 선언부분에서 return 변수명 명시하면 return 변수를 명시하지 않아도 됨\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func lenAndUpper(name string) (lenght int, uppercase string) { \tlenght = len(name) \tuppercase = strings.ToUpper(name) \treturn }  func main() { \ttotalLenght, up := lenAndUpper(\u0026#34;first\u0026#34;) \tfmt.Println(totalLenght, up) } defer : function 실행 끝나고 추가동작 지정가능\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func lenAndUpper(name string) (lenght int, uppercase string) { \tdefer fmt.Println(\u0026#34;I\u0026#39;m done\u0026#34;) \tlenght = len(name) \tuppercase = strings.ToUpper(name) \treturn }  func main() { \ttotalLenght, up := lenAndUpper(\u0026#34;first\u0026#34;) \tfmt.Println(totalLenght, up) } 1.4. for, range, args for : loop는 for함수로만 가능\nrange : array에 loop 적용 가능\n- range는 index를 같이 넘겨줌\nfor ~ range 사용한 loop 예시\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func superAdd(numbers ...int) int { \tfor index, number := range numbers { \tfmt.Println(index, number) \t} \treturn 1 }  func main() { \tsuperAdd(1, 2, 3, 4, 5, 6) } for 사용한 loop 예시\nfunc superAdd(numbers ...int) int { \tfor i := 0; i \u0026lt; len(numbers); i++ { \tfmt.Println(i, numbers[i]) \t} \treturn 1 } for ~ range 사용한 loop 예시 2\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func superAdd(numbers ...int) int { \ttotal := 0 \tfor _, number := range numbers { \ttotal += number \t} \treturn total }  func main() { \tresult := superAdd(1, 2, 3, 4, 5, 6) \tfmt.Println(result) } 1.5. If with a Twist if 조건문 사용형식\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func canIDrink(age int) bool { \tif age \u0026lt; 18 { \treturn false \t} \treturn true }  func main() { \tfmt.Println(canIDrink((16))) } if 문안에 조건문에서 사용할 변수를 선언하여 사용가능\n if-else의 조건에서만 사용하기 위해 variable을 생성한다는 의미 variable expression  func canIDrink(age int) bool { \tif koreanAge := age + 2; koreanAge \u0026lt; 18 { \treturn false \t} \treturn true } 1.6. Switch package main  import ( \t\u0026#34;fmt\u0026#34; )  func canIDrink(age int) bool { \tswitch age { \tcase 10: \treturn false \tcase 18: \treturn true \t} \treturn false }  func main() { \tfmt.Println(canIDrink((18))) } case 구문에 조건식 작성가능\nfunc canIDrink(age int) bool { \tswitch { \tcase age \u0026lt; 18: \treturn false \tcase age == 18: \treturn true \tcase 50 \u0026lt; age: \treturn false \t} \treturn false } if문과 마찬가지로 switch 전용 variable 사용가능\nfunc canIDrink(age int) bool { \tswitch koreanAge := age + 2; koreanAge { \tcase 10: \treturn false \tcase 18: \treturn true \t} \treturn false } 1.7. Pointers 복사는 기본적으로 값 복사를 실행\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ta := 2 \tb := a \ta = 10 \tfmt.Println(\u0026amp;a, \u0026amp;b) } 주소값 대입으로 여러 변수에서 같은 주소의 값 접근가능\nfunc main() { \ta := 2 \tb := \u0026amp;a \tfmt.Println(\u0026amp;a, b) } func main() { \ta := 2 \tb := \u0026amp;a \tfmt.Println(a, *b) } 1.8. Arrays and Slices array : 크기를 정해서 사용하는 배열 (크기 수정 불가)\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \tnames := [5]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} \tnames[3] = \u0026#34;d\u0026#34; \tnames[4] = \u0026#34;e\u0026#34; \tfmt.Println(names) } slices : 크기를 정하지 않고 사용하는 배열 (크기 수정 가능)\nfunc main() { \tnames := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} \tfmt.Println(names) } append(slice, item) : slice 변수에 item 추가\nfunc main() { \tnames := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} \tnames = append(names, \u0026#34;d\u0026#34;) \tfmt.Println(names) } 1.9. Maps map : key, value 로 이루어진 자료형\nmap[string]string\n key : string 타입 선언 value : string 타입 선언  package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \tval := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;20\u0026#34;} \tfmt.Println(val) } map, range 같이 사용가능\nfunc main() { \ttest := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;20\u0026#34;} \tfor key, value := range test { \tfmt.Println(key, value) \t} } func main() { \ttest := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;20\u0026#34;} \tfor _, value := range test { \tfmt.Println(value) \t} } 1.10. Structs map 자료형보다 유연함\npackage main  import \u0026#34;fmt\u0026#34;  type person struct { \tname string \tage int \tfavFood []string }  func main() { \tfavFood := []string{\u0026#34;apple\u0026#34;, \u0026#34;bottle\u0026#34;} \ttest := person{\u0026#34;a\u0026#34;, 30, favFood} \tfmt.Println(\u0026#34;name\u0026#34;, test.name) \tfmt.Println(\u0026#34;age\u0026#34;, test.age) \tfmt.Println(\u0026#34;favFood\u0026#34;, test.favFood) } struct 변수 선언시 변수명도 같이 작성가능\nfunc main() { \tfavFood := []string{\u0026#34;apple\u0026#34;, \u0026#34;bottle\u0026#34;} \ttest := person{name: \u0026#34;a\u0026#34;, age: 20, favFood: favFood} \tfmt.Println(\u0026#34;name\u0026#34;, test.name) \tfmt.Println(\u0026#34;age\u0026#34;, test.age) \tfmt.Println(\u0026#34;favFood\u0026#34;, test.favFood) }  2. BANK \u0026amp; DICTIONARY PROJECTS 2.0. Account + NewAccount 변수명 첫글자가 대문자이면 public\n변수명 첫글자가 소문자이면 private\n private은 외부 패키지에서 접근할 수 없음  2.0.1. pubilc main.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/banking\u0026#34; )  func main() { \taccount := banking.Account{Owner: \u0026#34;foo\u0026#34;, Balance: 1000} \tfmt.Println(\u0026#34;Owner : \u0026#34;, account.Owner) \tfmt.Println(\u0026#34;Balance : \u0026#34;, account.Balance) } banking/banking.go\npackage banking  // Account struct type Account struct { \tOwner string \tBalance int } no required module provides package /lectures/banking\n위와 같은 에러 발생시 아래의 명령어로 mod 파일 생성 및 빌드 진행후 다시 go run 실행\n go.mod 파일은 모듈의 루트에 존재  go mod init go build 2.0.2. private 외부 패키지에서 account 정보 수정하지 못하도록 private 방식으로 코드 수정\nmain.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/accounts\u0026#34; )  func main() { \taccount := accounts.NewAccount(\u0026#34;foo\u0026#34;) \tfmt.Println(\u0026#34;account : \u0026#34;, account) } 생성한 object 주소를 return\n 이미 만들어진 object를 반환하기 위함 결과값만 저장한 변수를 새로 만들지 않음  accounts/accounts.go\npackage accounts  // Account struct type Account struct { \towner string \tbalance int }  // NewAccount creates Account func NewAccount(owner string) *Account { \taccount := Account{owner: owner, balance: 0} \treturn \u0026amp;account } 2.1. Methods 2.1.1. receiver(method 설정) a Account : receiver에서 접근할 struct의 첫 글자를 따서 변수명을 소문자로 지어야함\n 해당 Account 정보는 복사한 정보  accounts/accounts.go\npackage accounts  // Account struct type Account struct { \towner string \tbalance int }  // NewAccount creates Account func NewAccount(owner string) *Account { \taccount := Account{owner: owner, balance: 0} \treturn \u0026amp;account }  // Deposit x amount on your account func (a Account) Deposit(amount int) { \ta.balance += amount } 2.1.2. Pointer receiver Deposit method 호출한 account 주소 사용\naccounts/accounts.go\n...  // NewAccount creates Account func NewAccount(owner string) *Account { \taccount := Account{owner: owner, balance: 0} \treturn \u0026amp;account } 2.1.3. error handling error 반환 유형 2가지\n return errors.New() nil  ... // Withdraw x amount from your account func (a *Account) Withdraw(amount int) error { \tif a.balance \u0026lt; amount { \treturn errors.New(\u0026#34;Cant\u0026#39;t withdraw you are poor\u0026#34;) \t} \ta.balance -= amount \treturn nil } main.go 실행 결과 Withdraw error가 반환됨\n log.Fatalln(err) : 에러구문 출력 후 프로그램 종료 fmt.Println(err) : 에러구문 출력  main.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/accounts\u0026#34; )  func main() { \taccount := accounts.NewAccount(\u0026#34;foo\u0026#34;) \taccount.Deposit(10) \tfmt.Println(\u0026#34;account : \u0026#34;, account) \tfmt.Println(\u0026#34;balance : \u0026#34;, account.Balance()) \terr := account.Withdraw(20) \tif err != nil { \tlog.Fatalln(err) \t} \tfmt.Println(\u0026#34;balance : \u0026#34;, account.Balance()) } 에러구문을 별도의 변수로 선언하여 사용가능\n 에러 변수명은 err~ 식으로 선언해야함  ...  var errNoMoney = errors.New(\u0026#34;Can\u0026#39;t withdraw\u0026#34;)  ...  // Withdraw x amount from your account func (a *Account) Withdraw(amount int) error { \tif a.balance \u0026lt; amount { \treturn errNoMoney \t} \ta.balance -= amount \treturn nil } 2.2. Finishing Up Go에서 struct 사용시 내부적으로 호출해주는 method\n String : struct 출력시 실행되는 method  method는 struct, type 에 추가할 수 있음\nmain.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/accounts\u0026#34; )  func main() { \taccount := accounts.NewAccount(\u0026#34;foo\u0026#34;) \taccount.Deposit(10) \terr := account.Withdraw(20) \tif err != nil { \tfmt.Println(err) \t} \tfmt.Println(\u0026#34;account : \u0026#34;, account.Owner(), \u0026#34;, balance : \u0026#34;, account.Balance()) } accounts/accounts.go\n...  // ChangeOwner of the account func (a *Account) ChangeOwner(newOnwer string) { \ta.owner = newOnwer }  // Owner of the account func (a Account) Owner() string { \treturn a.owner }  func (a Account) String() string { \treturn fmt.Sprint(a.Owner(), \u0026#34;\u0026#39;s account.\\nHas: \u0026#34;, a.Balance()) } 2.3. Dictionary type Dictionary는 map[string]string자료형의 별명(alias)이다.\nmydict/mydict.go\npackage mydict  // Dictionary type type Dictionary map[string]string main.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/mydict\u0026#34; )  func main() { \tdictionary := mydict.Dictionary{} \tdictionary[\u0026#34;hello\u0026#34;] = \u0026#34;foo\u0026#34; \tfmt.Println(dictionary) } 2.3.1. Search dictionary 와 method 사용\nSearch method 추가\nmydict/mydict.go\npackage mydict  import \u0026#34;errors\u0026#34;  // Dictionary type type Dictionary map[string]string  var errNotFound = errors.New(\u0026#34;Not Found\u0026#34;)  // Search for a word func (d Dictionary) Search(word string) (string, error) { \tvalue, exists := d[word] \tif exists { \treturn value, nil \t} \treturn \u0026#34;\u0026#34;, errNotFound } main.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/mydict\u0026#34; )  func main() { \tdictionary := mydict.Dictionary{\u0026#34;first\u0026#34;: \u0026#34;First word\u0026#34;} \tdefinition, err := dictionary.Search(\u0026#34;second\u0026#34;) \tif err != nil { \tfmt.Println(err) \t} else { \tfmt.Println(definition) \t} } 2.3.2. Add Add method 추가\nmydict/mydict.go\nif문 형식\nvar errWordExists = erros.New(\u0026#34;That word already exists\u0026#34;) ...  // Add a word to the dictionary func (d Dictionary) Add(word, def string) error { \t_, err := d.Search(word) \tif err == errNotFound { \td[word] = def \t} else if err == nil { \treturn errWordExists \t} \treturn nil } switch문 형식\n// Add a word to the dictionary func (d Dictionary) Add(word, def string) error { \t_, err := d.Search(word) \tswitch err { \tcase errNotFound: \td[word] = def \tcase nil: \treturn errWordExists \t} \treturn nil } main.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/mydict\u0026#34; )  func main() { \tdictionary := mydict.Dictionary{} \tword := \u0026#34;hello\u0026#34; \tdefinition := \u0026#34;Greeting\u0026#34; \terr := dictionary.Add(word, definition) \tif err != nil { \tfmt.Println(err) \t} \thello, _ := dictionary.Search(word) \tfmt.Println(\u0026#34;found :\u0026#34;, word, \u0026#34;, definition :\u0026#34;, hello) \terr2 := dictionary.Add(word, definition) \tif err2 != nil { \tfmt.Println(err2) \t} } 2.3.3. Update Delete Update method 추가\nmain.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/mydict\u0026#34; )  func main() { \tdictionary := mydict.Dictionary{} \tbaseWord := \u0026#34;hello\u0026#34; \tdictionary.Add(baseWord, \u0026#34;First\u0026#34;) \terr := dictionary.Update(baseWord, \u0026#34;Second\u0026#34;) \tif err != nil { \tfmt.Println(err) \t} \tword, _ := dictionary.Search(baseWord) \tfmt.Println(word) } mydict/mydict.go\nvar ( \terrNotFound = errors.New(\u0026#34;Not Found\u0026#34;) \terrCantUpdate = errors.New(\u0026#34;Cant update non-existing word\u0026#34;) \terrWordExists = errors.New(\u0026#34;That word already exists\u0026#34;) )  ...  // Update a word func (d Dictionary) Update(word, definition string) error { \t_, err := d.Search(word) \tswitch err { \tcase nil: \td[word] = definition \tcase errNotFound: \treturn errCantUpdate \t} \treturn nil } Delete method 추가\nmain.go\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/sangjuncha-dev/lectures/mydict\u0026#34; )  func main() { \tdictionary := mydict.Dictionary{} \tbaseWord := \u0026#34;hello\u0026#34; \tdictionary.Add(baseWord, \u0026#34;First\u0026#34;) \tdictionary.Search(baseWord) \tdictionary.Delete(baseWord) \tword, err := dictionary.Search(baseWord) \tif err != nil { \tfmt.Println(err) \t} else { \tfmt.Println(word) \t} } mydict/mydict.go\n...  // Delete a word func (d Dictionary) Delete(word string) { \tdelete(d, word) }  3. URL CHECKER \u0026amp; GO ROUTINES 3.0. hitURL hit : 인터넷 웹 서버의 파일 1개에 접속하는것을 뜻함\nrequest 사용을 위해 내장 library http 사용\nmain.go\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;net/http\u0026#34; )  var ( \terrRequestFailed = errors.New(\u0026#34;Request failed\u0026#34;) )  func main() { \turls := []string{ \t\u0026#34;https://www.airbnb.com/\u0026#34;, \t\u0026#34;https://www.google.com/\u0026#34;, \t\u0026#34;https://www.amazon.com/\u0026#34;, \t\u0026#34;https://www.reddit.com/\u0026#34;, \t\u0026#34;https://soundcloud.com/\u0026#34;, \t\u0026#34;https://www.facebook.com\u0026#34;, \t\u0026#34;https://www.instagram.com/\u0026#34;, \t\u0026#34;https://academy.nomadcoders.co/\u0026#34;, \t} \tfor _, url := range urls { \thitURL(url) \t} \tfor url, result := range results { \tfmt.Println(url, result) \t} }  func hitURL(url string) error { \tfmt.Println(\u0026#34;Chacking :\u0026#34;, url) \tresp, err := http.Get(url) \tif err != nil || 400 \u0026lt;= resp.StatusCode { \treturn errRequestFailed \t} \treturn nil } 3.1. Slow URLChecker panic : 컴파일러가 못찾은 에러\nmap 자료형은 초기화 안 하면 값을 넣을 수 없음\nvar results map[string]string results[\u0026#34;hello\u0026#34;] = \u0026#34;Hello\u0026#34; map 자료형은 빈 값으로 초기화 선언해야 값을 넣을 수 있음\nvar results = map[string]string{} results[\u0026#34;hello\u0026#34;] = \u0026#34;Hello\u0026#34; make() : empty map 만들고 초기화 해주는 함수\nvar results = make(map[string]string) main.go\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;net/http\u0026#34; )  var ( \terrRequestFailed = errors.New(\u0026#34;Request failed\u0026#34;) )  func main() { \tvar results = make(map[string]string) \turls := []string{ \t\u0026#34;https://www.airbnb.com/\u0026#34;, \t\u0026#34;https://www.google.com/\u0026#34;, \t\u0026#34;https://www.amazon.com/\u0026#34;, \t\u0026#34;https://www.reddit.com/\u0026#34;, \t\u0026#34;https://soundcloud.com/\u0026#34;, \t\u0026#34;https://www.facebook.com\u0026#34;, \t\u0026#34;https://www.instagram.com/\u0026#34;, \t\u0026#34;https://academy.nomadcoders.co/\u0026#34;, \t} \tfor _, url := range urls { \tresult := \u0026#34;OK\u0026#34; \terr := hitURL(url) \tif err != nil { \tresult = \u0026#34;FAILED\u0026#34; \t} \tresults[url] = result \t} \tfor url, result := range results { \tfmt.Println(url, result) \t} }  func hitURL(url string) error { \tfmt.Println(\u0026#34;Chacking :\u0026#34;, url) \tresp, err := http.Get(url) \tif err != nil || 400 \u0026lt;= resp.StatusCode { \tfmt.Println(err, resp.StatusCode) \treturn errRequestFailed \t} \treturn nil } status code\n 401 : Unauthorized 429 : Too Many Requests  3.2. Goroutines Top-down 방식의 프로그래밍\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \tmyCount(\u0026#34;foo\u0026#34;) \tmyCount(\u0026#34;bar\u0026#34;) }  func myCount(person string) { \tfor i := 0; i \u0026lt; 10; i++ { \tfmt.Println(person, \u0026#34;is number :\u0026#34;, i) \ttime.Sleep(time.Second) \t} } Goroutines : 다른 함수와 동시에 실행시키는 함수\n Goroutines은 프로그램이 작동하는 동안만 실행  main 함수 부분에서 go 루틴사용시 함수가 끝나기전에 main함수가 끝나면 프로그램이 종료되므로 main함수가 끝나지 않게 만든 상태에서 go 루틴 사용해야함\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \tgo myCount(\u0026#34;foo\u0026#34;) \tgo myCount(\u0026#34;bar\u0026#34;) \ttime.Sleep(time.Second * 5) }  func myCount(person string) { \tfor i := 0; i \u0026lt; 10; i++ { \tfmt.Println(person, \u0026#34;is number :\u0026#34;, i) \ttime.Sleep(time.Second) \t} } 3.3. Channels Channel\n goroutine과 main함수 사이에 정보를 전달하기 위한 방법 goroutine에서 다른 goroutine으로 커뮤니케이션 채널을 통해서 데이터를 받거나 보낼 수 있음  package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \tc := make(chan bool) \tpeople := [2]string{\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;} \tfor _, person := range people { \tgo isMy(person, c) \t} \tfmt.Println(\u0026lt;-c) \tfmt.Println(\u0026lt;-c) }  func isMy(person string, c chan bool) { \ttime.Sleep(time.Second * 5) \tfmt.Println(person) \tc \u0026lt;- true } 3.4. Channels Recap blocking operation : 해당 작업이 끝날때까지 멈춤\n \u0026lt;-c : 채널로부터 메세지를 얻음 하나의 메세지를 받으면 다음 라인으로 넘어감  package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \tc := make(chan string) \tpeople := [2]string{\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;} \tfor _, person := range people { \tgo isMy(person, c) \t} \tfmt.Println(\u0026#34;Waiting for message\u0026#34;) \tfor i := 0; i \u0026lt; len(people); i++ { \tfmt.Print(\u0026#34;waiting for \u0026#34;, i, \u0026#34; \u0026#34;) \tfmt.Println(\u0026lt;-c) \t} }  func isMy(person string, c chan string) { \ttime.Sleep(time.Second * 5) \tc \u0026lt;- person + \u0026#34; is OK\u0026#34; }  채널의 메세지를 받는것 == blocking operation 채널을 통해서 보내는 부분과 받는 부분 모두 타입 지정해야함  3.5. URLChecker + Go Routines c chan\u0026lt;- : Send Only(보내기만 가능)\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;net/http\u0026#34; )  type requestResult struct { \turl string \tstatus string }  var errRequestFailed = errors.New(\u0026#34;Request failed\u0026#34;)  func main() { \tvar results = make(map[string]string) \tc := make(chan requestResult) \turls := []string{ \t\u0026#34;https://www.airbnb.com/\u0026#34;, \t\u0026#34;https://www.google.com/\u0026#34;, \t\u0026#34;https://www.amazon.com/\u0026#34;, \t\u0026#34;https://www.reddit.com/\u0026#34;, \t\u0026#34;https://soundcloud.com/\u0026#34;, \t\u0026#34;https://www.facebook.com\u0026#34;, \t\u0026#34;https://www.instagram.com/\u0026#34;, \t\u0026#34;https://academy.nomadcoders.co/\u0026#34;, \t} \tfor _, url := range urls { \tgo hitURL(url, c) \t} \tfor i := 0; i \u0026lt; len(urls); i++ { \tresult := \u0026lt;-c \tresults[result.url] = result.status \t} \tfor url, status := range results { \tfmt.Println(url, status) \t} }  func hitURL(url string, c chan\u0026lt;- requestResult) { \tresp, err := http.Get(url) \tstatus := \u0026#34;OK\u0026#34; \tif err != nil || 400 \u0026lt;= resp.StatusCode { \tstatus = \u0026#34;FAILED\u0026#34; \t} \tc \u0026lt;- requestResult{url: url, status: status} }  4. JOB SCRAPPER 4.0. getPages 라이브러리 설치\ngo get github.com/PuerkitoBio/goquery goquery Doc URL\n https://github.com/PuerkitoBio/goquery https://pkg.go.dev/github.com/PuerkitoBio/goquery  strconv : 타입 변환 라이브러리\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;strconv\u0026#34;  \t\u0026#34;github.com/PuerkitoBio/goquery\u0026#34; )  var baseURL string = \u0026#34;https://kr.indeed.com/jobs?q=python\u0026amp;limit=50\u0026#34;  func main() { \ttotalPages := getPages() \t// fmt.Println(totalPages)  \tfor i := 0; i \u0026lt; totalPages; i++ { \tgetPage(i) \t} }  func getPage(page int) { \tpageURL := baseURL + \u0026#34;\u0026amp;start=\u0026#34; + strconv.Itoa(page*50) \tfmt.Println(\u0026#34;Requesting :\u0026#34;, pageURL) }  func getPages() int { \tpages := 0 \tres, err := http.Get(baseURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tdoc.Find(\u0026#34;.pagination\u0026#34;).Each(func(i int, s *goquery.Selection) { \t// fmt.Println(s.Html()) \tpages = s.Find(\u0026#34;a\u0026#34;).Length() \t})  \treturn pages }  func checkErr(err error) { \tif err != nil { \tlog.Fatalln(err) \t} }  func checkCode(res *http.Response) { \tif res.StatusCode != 200 { \tlog.Fatalln(\u0026#34;Request failed with Status :\u0026#34;, res.StatusCode) \t} } 4.1. extractJob strings.TrimSpace(str) : 문자열 양쪽 끝 공백 제거\nstrings.Fields(str) : 문자열 배열형태로 반환\nstrings.Join([]string, \u0026quot; \u0026ldquo;) : 문자열 배열을 \u0026quot; \u0026ldquo;으로 합쳐서 문자열 변환\nappend(slice1, slice2) : slice1배열 안의 원소로 slice2 추가\nappend(slice1, slice2\u0026hellip;) : 두개의 배열을 하나의 배열로 합치기\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;strconv\u0026#34; \t\u0026#34;strings\u0026#34;  \t\u0026#34;github.com/PuerkitoBio/goquery\u0026#34; )  type extractedJob struct { \tid string \ttitle string \tlocation string \tsalary string \tsummary string }  var baseURL string = \u0026#34;https://kr.indeed.com/jobs?q=python\u0026amp;limit=50\u0026#34;  func main() { \tvar jobs []extractedJob \ttotalPages := getPages()  \tfor i := 0; i \u0026lt; totalPages; i++ { \textractedJobs := getPage(i) \tjobs = append(jobs, extractedJobs...) \t} \tfmt.Println(jobs) }  func getPage(page int) []extractedJob { \tvar jobs []extractedJob \tpageURL := baseURL + \u0026#34;\u0026amp;start=\u0026#34; + strconv.Itoa(page*50) \tfmt.Println(\u0026#34;Requesting :\u0026#34;, pageURL) \tres, err := http.Get(pageURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tsearchCards := doc.Find(\u0026#34;.jobsearch-SerpJobCard\u0026#34;) \tsearchCards.Each(func(i int, card *goquery.Selection) { \tjob := extractJob(card) \tjobs = append(jobs, job) \t})  \treturn jobs }  func extractJob(card *goquery.Selection) extractedJob { \tid, _ := card.Attr(\u0026#34;data-jk\u0026#34;) \ttitle := cleanString(card.Find(\u0026#34;.title\u0026gt;a\u0026#34;).Text()) \tlocation := cleanString(card.Find(\u0026#34;.sjcl\u0026#34;).Text()) \tsalary := cleanString(card.Find(\u0026#34;.salaryText\u0026#34;).Text()) \tsummary := cleanString(card.Find(\u0026#34;.summary\u0026#34;).Text()) \treturn extractedJob{ \tid: id, \ttitle: title, \tlocation: location, \tsalary: salary, \tsummary: summary, \t} }  // card 데이터에서 공백 제거 func cleanString(str string) string { \treturn strings.Join(strings.Fields(strings.TrimSpace(str)), \u0026#34; \u0026#34;) }  // 전체 페이지수 얻기 func getPages() int { \tpages := 0 \tres, err := http.Get(baseURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tdoc.Find(\u0026#34;.pagination\u0026#34;).Each(func(i int, s *goquery.Selection) { \tpages = s.Find(\u0026#34;a\u0026#34;).Length() \t})  \treturn pages }  func checkErr(err error) { \tif err != nil { \tlog.Fatalln(err) \t} }  func checkCode(res *http.Response) { \tif res.StatusCode != 200 { \tlog.Fatalln(\u0026#34;Request failed with Status :\u0026#34;, res.StatusCode) \t} } 4.2. Writing Jobs encoding/csv : csv 관련 패키지\nw.Write([]string) : 파일 버퍼에 기록\ndefer w.Flush() : 함수가 끝나는 시점에 파일에 데이터를 작성하는 함수\npackage main  import ( \t\u0026#34;encoding/csv\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;strconv\u0026#34; \t\u0026#34;strings\u0026#34;  \t\u0026#34;github.com/PuerkitoBio/goquery\u0026#34; )  type extractedJob struct { \tid string \ttitle string \tlocation string \tsalary string \tsummary string }  var baseURL string = \u0026#34;https://kr.indeed.com/jobs?q=python\u0026amp;limit=50\u0026#34;  func main() { \tvar jobs []extractedJob \ttotalPages := getPages()  \tfor i := 0; i \u0026lt; totalPages; i++ { \textractedJobs := getPage(i) \tjobs = append(jobs, extractedJobs...) \t}  \twriteJons(jobs) \tfmt.Println(\u0026#34;Done, extracted\u0026#34;, len(jobs)) }  func writeJons(jobs []extractedJob) { \tfile, err := os.Create(\u0026#34;jobs.csv\u0026#34;) \tcheckErr(err)  \tw := csv.NewWriter(file) \tdefer w.Flush()  \theaders := []string{\u0026#34;Link\u0026#34;, \u0026#34;Title\u0026#34;, \u0026#34;Location\u0026#34;, \u0026#34;Salary\u0026#34;, \u0026#34;Summary\u0026#34;}  \twErr := w.Write(headers) \tcheckErr(wErr)  \tfor _, job := range jobs { \tjobSclice := []string{\u0026#34;https://kr.indeed.com/viewjob?jk=\u0026#34; + job.id, job.title, job.location, job.salary, job.summary} \tjwErr := w.Write(jobSclice) \tcheckErr(jwErr) \t} }  func getPage(page int) []extractedJob { \tvar jobs []extractedJob \tpageURL := baseURL + \u0026#34;\u0026amp;start=\u0026#34; + strconv.Itoa(page*50) \tfmt.Println(\u0026#34;Requesting :\u0026#34;, pageURL) \tres, err := http.Get(pageURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tsearchCards := doc.Find(\u0026#34;.jobsearch-SerpJobCard\u0026#34;) \tsearchCards.Each(func(i int, card *goquery.Selection) { \tjob := extractJob(card) \tjobs = append(jobs, job) \t})  \treturn jobs }  // 카드에서 일자리 정보 추출 func extractJob(card *goquery.Selection) extractedJob { \tid, _ := card.Attr(\u0026#34;data-jk\u0026#34;) \ttitle := cleanString(card.Find(\u0026#34;.title\u0026gt;a\u0026#34;).Text()) \tlocation := cleanString(card.Find(\u0026#34;.sjcl\u0026#34;).Text()) \tsalary := cleanString(card.Find(\u0026#34;.salaryText\u0026#34;).Text()) \tsummary := cleanString(card.Find(\u0026#34;.summary\u0026#34;).Text()) \treturn extractedJob{ \tid: id, \ttitle: title, \tlocation: location, \tsalary: salary, \tsummary: summary, \t} }  // 데이터에서 공백 제거 func cleanString(str string) string { \treturn strings.Join(strings.Fields(strings.TrimSpace(str)), \u0026#34; \u0026#34;) }  // 전체 페이지수 얻기 func getPages() int { \tpages := 0 \tres, err := http.Get(baseURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tdoc.Find(\u0026#34;.pagination\u0026#34;).Each(func(i int, s *goquery.Selection) { \tpages = s.Find(\u0026#34;a\u0026#34;).Length() \t})  \treturn pages }  func checkErr(err error) { \tif err != nil { \tlog.Fatalln(err) \t} }  func checkCode(res *http.Response) { \tif res.StatusCode != 200 { \tlog.Fatalln(\u0026#34;Request failed with Status :\u0026#34;, res.StatusCode) \t} } 4.3. Channels Time package main  import ( \t\u0026#34;encoding/csv\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;strconv\u0026#34; \t\u0026#34;strings\u0026#34;  \t\u0026#34;github.com/PuerkitoBio/goquery\u0026#34; )  type extractedJob struct { \tid string \ttitle string \tlocation string \tsalary string \tsummary string }  var baseURL string = \u0026#34;https://kr.indeed.com/jobs?q=python\u0026amp;limit=50\u0026#34;  func main() { \tvar jobs []extractedJob \tc := make(chan []extractedJob) \ttotalPages := getPages()  \tfor i := 0; i \u0026lt; totalPages; i++ { \tgo getPage(i, c) \t} \tfor i := 0; i \u0026lt; totalPages; i++ { \textractJobs := \u0026lt;-c \tjobs = append(jobs, extractJobs...) \t}  \twriteJons(jobs) \tfmt.Println(\u0026#34;Done, extracted\u0026#34;, len(jobs)) }  func getPage(page int, mainC chan\u0026lt;- []extractedJob) { \tvar jobs []extractedJob \tc := make(chan extractedJob) \tpageURL := baseURL + \u0026#34;\u0026amp;start=\u0026#34; + strconv.Itoa(page*50) \tfmt.Println(\u0026#34;Requesting :\u0026#34;, pageURL) \tres, err := http.Get(pageURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tsearchCards := doc.Find(\u0026#34;.jobsearch-SerpJobCard\u0026#34;) \tsearchCards.Each(func(i int, card *goquery.Selection) { \tgo extractJob(card, c) \t})  \tfor i := 0; i \u0026lt; searchCards.Length(); i++ { \tjob := \u0026lt;-c \tjobs = append(jobs, job) \t} \tmainC \u0026lt;- jobs }  // 카드에서 일자리 정보 추출 func extractJob(card *goquery.Selection, c chan\u0026lt;- extractedJob) { \tid, _ := card.Attr(\u0026#34;data-jk\u0026#34;) \ttitle := cleanString(card.Find(\u0026#34;.title\u0026gt;a\u0026#34;).Text()) \tlocation := cleanString(card.Find(\u0026#34;.sjcl\u0026#34;).Text()) \tsalary := cleanString(card.Find(\u0026#34;.salaryText\u0026#34;).Text()) \tsummary := cleanString(card.Find(\u0026#34;.summary\u0026#34;).Text()) \tc \u0026lt;- extractedJob{ \tid: id, \ttitle: title, \tlocation: location, \tsalary: salary, \tsummary: summary, \t} }  // 데이터에서 공백 제거 func cleanString(str string) string { \treturn strings.Join(strings.Fields(strings.TrimSpace(str)), \u0026#34; \u0026#34;) }  // 전체 페이지수 얻기 func getPages() int { \tpages := 0 \tres, err := http.Get(baseURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tdoc.Find(\u0026#34;.pagination\u0026#34;).Each(func(i int, s *goquery.Selection) { \tpages = s.Find(\u0026#34;a\u0026#34;).Length() \t})  \treturn pages }  func writeJons(jobs []extractedJob) { \tfile, err := os.Create(\u0026#34;jobs.csv\u0026#34;) \tcheckErr(err)  \tw := csv.NewWriter(file) \tdefer w.Flush()  \theaders := []string{\u0026#34;Link\u0026#34;, \u0026#34;Title\u0026#34;, \u0026#34;Location\u0026#34;, \u0026#34;Salary\u0026#34;, \u0026#34;Summary\u0026#34;}  \twErr := w.Write(headers) \tcheckErr(wErr)  \tfor _, job := range jobs { \tjobSclice := []string{\u0026#34;https://kr.indeed.com/viewjob?jk=\u0026#34; + job.id, job.title, job.location, job.salary, job.summary} \tjwErr := w.Write(jobSclice) \tcheckErr(jwErr) \t} }  func checkErr(err error) { \tif err != nil { \tlog.Fatalln(err) \t} }  func checkCode(res *http.Response) { \tif res.StatusCode != 200 { \tlog.Fatalln(\u0026#34;Request failed with Status :\u0026#34;, res.StatusCode) \t} }  5. WEB SERVER WITH ECHO 5.0. Setup go echo 서버 만들기\n라이브러리 설치\ngo get github.com/labstack/echo main.go\npackage main  import ( \t\u0026#34;net/http\u0026#34;  \t\u0026#34;github.com/labstack/echo\u0026#34; )  func handleHome(c echo.Context) error { \treturn c.String(http.StatusOK, \u0026#34;Hello, World!\u0026#34;) }  func main() { \te := echo.New() \te.GET(\u0026#34;/\u0026#34;, handleHome) \te.Logger.Fatal(e.Start(\u0026#34;:1323\u0026#34;)) } go run main.go 실행 후\n웹 브라우저에서 localhost:1323 접속시 접속되는 것을 확인\n5.1. scrapper 서버 생성 scrapper 폴더 생성후 해당 폴더로 main.go 파일 이동후 아래와 같이 수정\n 파일명 main.go -\u0026gt; scrapper.go 패키지명 package main -\u0026gt; package scrapper 함수명 func main() -\u0026gt; func scrape  scrapper/scrapper.go\npackage scrapper  import ( \t\u0026#34;encoding/csv\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;strconv\u0026#34; \t\u0026#34;strings\u0026#34;  \t\u0026#34;github.com/PuerkitoBio/goquery\u0026#34; )  type extractedJob struct { \tid string \ttitle string \tlocation string \tsalary string \tsummary string }  // Scrape Indeed by a term func Scrape(term string) { \tvar baseURL string = \u0026#34;https://kr.indeed.com/jobs?q=\u0026#34; + term + \u0026#34;\u0026amp;limit=50\u0026#34; \tvar jobs []extractedJob \tc := make(chan []extractedJob) \ttotalPages := getPages(baseURL)  \tfor i := 0; i \u0026lt; totalPages; i++ { \tgo getPage(i, baseURL, c) \t} \tfor i := 0; i \u0026lt; totalPages; i++ { \textractJobs := \u0026lt;-c \tjobs = append(jobs, extractJobs...) \t}  \twriteJobs(jobs) \tfmt.Println(\u0026#34;Done, extracted\u0026#34;, len(jobs)) }  func getPage(page int, url string, mainC chan\u0026lt;- []extractedJob) { \tvar jobs []extractedJob \tc := make(chan extractedJob) \tpageURL := url + \u0026#34;\u0026amp;start=\u0026#34; + strconv.Itoa(page*50) \tfmt.Println(\u0026#34;Requesting :\u0026#34;, pageURL) \tres, err := http.Get(pageURL) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tsearchCards := doc.Find(\u0026#34;.jobsearch-SerpJobCard\u0026#34;) \tsearchCards.Each(func(i int, card *goquery.Selection) { \tgo extractJob(card, c) \t})  \tfor i := 0; i \u0026lt; searchCards.Length(); i++ { \tjob := \u0026lt;-c \tjobs = append(jobs, job) \t} \tmainC \u0026lt;- jobs }  // 카드에서 일자리 정보 추출 func extractJob(card *goquery.Selection, c chan\u0026lt;- extractedJob) { \tid, _ := card.Attr(\u0026#34;data-jk\u0026#34;) \ttitle := CleanString(card.Find(\u0026#34;.title\u0026gt;a\u0026#34;).Text()) \tlocation := CleanString(card.Find(\u0026#34;.sjcl\u0026#34;).Text()) \tsalary := CleanString(card.Find(\u0026#34;.salaryText\u0026#34;).Text()) \tsummary := CleanString(card.Find(\u0026#34;.summary\u0026#34;).Text()) \tc \u0026lt;- extractedJob{ \tid: id, \ttitle: title, \tlocation: location, \tsalary: salary, \tsummary: summary, \t} }  // CleanString cleans a string func CleanString(str string) string { \treturn strings.Join(strings.Fields(strings.TrimSpace(str)), \u0026#34; \u0026#34;) }  // 전체 페이지수 얻기 func getPages(url string) int { \tpages := 0 \tres, err := http.Get(url) \tcheckErr(err) \tcheckCode(res)  \tdefer res.Body.Close()  \tdoc, err := goquery.NewDocumentFromReader(res.Body) \tcheckErr(err)  \tdoc.Find(\u0026#34;.pagination\u0026#34;).Each(func(i int, s *goquery.Selection) { \tpages = s.Find(\u0026#34;a\u0026#34;).Length() \t})  \treturn pages }  func writeJobs(jobs []extractedJob) { \tfile, err := os.Create(\u0026#34;jobs.csv\u0026#34;) \tcheckErr(err)  \tw := csv.NewWriter(file) \tdefer w.Flush()  \theaders := []string{\u0026#34;Link\u0026#34;, \u0026#34;Title\u0026#34;, \u0026#34;Location\u0026#34;, \u0026#34;Salary\u0026#34;, \u0026#34;Summary\u0026#34;}  \twErr := w.Write(headers) \tcheckErr(wErr)  \tfor _, job := range jobs { \tjobSclice := []string{\u0026#34;https://kr.indeed.com/viewjob?jk=\u0026#34; + job.id, job.title, job.location, job.salary, job.summary} \tjwErr := w.Write(jobSclice) \tcheckErr(jwErr) \t} }  func checkErr(err error) { \tif err != nil { \tlog.Fatalln(err) \t} }  func checkCode(res *http.Response) { \tif res.StatusCode != 200 { \tlog.Fatalln(\u0026#34;Request failed with Status :\u0026#34;, res.StatusCode) \t} } main.go\npackage main  import ( \t\u0026#34;strings\u0026#34;  \t\u0026#34;github.com/SangjunCha-dev/learngo/scrapper\u0026#34; \t\u0026#34;github.com/labstack/echo\u0026#34; )  func handleHome(c echo.Context) error { \treturn c.File(\u0026#34;home.html\u0026#34;) }  func handleScrape(c echo.Context) error { \tterm := strings.ToLower(scrapper.CleanString(c.FormValue(\u0026#34;term\u0026#34;))) \tscrapper.Scrape(term) \treturn nil }  func main() { \te := echo.New() \te.GET(\u0026#34;/\u0026#34;, handleHome) \te.POST(\u0026#34;/scrape\u0026#34;, handleScrape) \te.Logger.Fatal(e.Start(\u0026#34;:1323\u0026#34;)) } home.html 파일 생성\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Go Jobs\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;  \u0026lt;h1\u0026gt;Go Jobs\u0026lt;/h1\u0026gt;  \u0026lt;h3\u0026gt;Indeed.com scrapper\u0026lt;/h3\u0026gt;  \u0026lt;form method=\u0026#34;POST\u0026#34; action=\u0026#34;/scrape\u0026#34;\u0026gt;  \u0026lt;input placeholder=\u0026#34;what job do you want\u0026#34; name=\u0026#34;term\u0026#34;/\u0026gt;  \u0026lt;button\u0026gt;Search\u0026lt;/button\u0026gt;  \u0026lt;/form\u0026gt; \u0026lt;/html\u0026gt; 5.2. File Download return c.Attachment(filename1, filename2) : filename1 파일 찾아서 filename2 이름으로 다운로드\nmain.go\npackage main  import ( \t\u0026#34;os\u0026#34; \t\u0026#34;strings\u0026#34;  \t\u0026#34;github.com/SangjunCha-dev/learngo/scrapper\u0026#34; \t\u0026#34;github.com/labstack/echo\u0026#34; )  const fileName string = \u0026#34;jobs.csv\u0026#34;  func handleHome(c echo.Context) error { \treturn c.File(\u0026#34;home.html\u0026#34;) }  func handleScrape(c echo.Context) error { \tdefer os.Remove(fileName) \tterm := strings.ToLower(scrapper.CleanString(c.FormValue(\u0026#34;term\u0026#34;))) \tscrapper.Scrape(term) \treturn c.Attachment(fileName, fileName) }  func main() { \te := echo.New() \te.GET(\u0026#34;/\u0026#34;, handleHome) \te.POST(\u0026#34;/scrape\u0026#34;, handleScrape) \te.Logger.Fatal(e.Start(\u0026#34;:1323\u0026#34;)) }  참고(Reference) buffalo\n django의 go버전 프레임워크 db, template, api, server, logger, orm 등 모든 것이 있는 풀스택 프레임워크 라우팅, hot code reload, 프론트엔드 파이프라인, 모델, 테스트 등 기능 지원  ","date":"February 22, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/golang/2021-02-22-go-for-beginners-lectures/","summary":"0. 소개 설치 환경 : Windows 10 IDE : vscode\n0.1. 설치 해당 URL에서 golang 설치파일을 다운받아 실행\n https://golang.org/dl/ 설치파일에서 안내한 경로인 C:\\Program Files\\Go 폴더에 Go 설치 되었는지 확인  0.2. 설정  Go Path 환경변수 확인   Go는 지정된 Go Path 디렉토리에만 저장되어야함 시스템 환경변수에 등록된 GOPATH 값 확인 %USERPROFILE%\\go -\u0026gt; C:\\Users\\[Profle_Name]\\go 해당 경로가 Go Path 환경변수로 사용되는 경로  기본 설정   go 디렉토리로 이동하여 bin, pkg, src 디렉토리 생성 src 디렉토리안에 지정된 도메인 디렉토리 추가  go에서 다운받은 코드를 지정된 도메인 별로 분류하여 저장   src 디렉토리안에 github.","tags":["go","learning","scraper"],"title":"노마드코더 쉽고 빠른 Go 시작하기(nomadcoders Go-for-beginners lectures)"},{"categories":["Python","Guide","Sniff"],"contents":" 설치환경 : Windows 10, python 3.7\n1. 설치  와이어샤크 프로그램에 포함된 npcap 설치 필요  https://www.wireshark.org/download.html   pip install pyshark   2. 사용법   캡쳐파일 읽기\ncapture = pyshark.FileCapture(\u0026#39;./test.pcapng\u0026#39;)   실시간 패킷캡처 interface\ncapture = pyshark.LiveCapture(interface=\u0026#39;이더넷\u0026#39;, bpf_filter=\u0026#39;ether src host 11:22:33:44:55:66\u0026#39;, use_json=True, include_raw=True)   패킷 캡처\n 패킷 1개 캡처하거나 10ms 경과하면 캡처 결과 반환  capture.sniff(packet_count=1, timeout=10)  패킷 10개 캡처하거나 10ms 경과하면 캡처 결과 반환  capture.sniff(packet_count=10, timeout=10)   패킷 bytes 형태로 반환\nprint(capture[0].get_raw_packet())   모든 패킷을 실행하고 읽은대로 각 패킷과 함께 주어진 콜백(함수) 호출\ndef print_callback(self, pkt):  print(f\u0026#34;packet = {pkt}\u0026#34;) print(capture.apply_on_packets(print_callback(pkt)))    3. bpf_filter 패킷 캡쳐 조건 지정\n  사용 예시\n bpf_filter=\u0026lsquo;ether host 11:22:33:44:55:66\u0026rsquo; bpf_filter=\u0026lsquo;ip src 192.168.0.1\u0026rsquo; bpf_filter=\u0026lsquo;len == 1518\u0026rsquo;    bpf_filter 사용 참고사이트\n Filter packets with Berkeley Packet Filter syntax Berkeley Packet Filter (BPF) syntax     4. display_filter(wireshark) 필터   사용 예시\n display_filter=\u0026lsquo;eth.addr == 11:22:33:44:55:66\u0026rsquo;    display_filter 참고사이트\n wireshark-filter     5. 예제코드 import pyshark import struct  import os import datetime as dt   class SniffPacket():  def run(self):  # 실시간 패킷캡처 interface  capture = pyshark.LiveCapture(interface=\u0026#39;이더넷\u0026#39;, bpf_filter=\u0026#39;ether src host 11:22:33:44:55:66\u0026#39;, use_json=True, include_raw=True)   print(\u0026#39;capture start\u0026#39;)  for raw_data in capture.sniff_continuously():  # capture.sniff_continuously() : 설정된 인터페이스에서 캡처하여 패킷을 지속적으로 반환하는 생성기를 반환  # pyshark.LiveCapture(..., use_json=True, include_raw=True) # 위의 기능을 사용하기 위해서는 Capture 설정에서 use_json=True, include_raw=True 옵션을 추가해야함   self.analysis_data(raw_data.get_raw_packet())   def analysis_data(self, raw_data):  src_mac = struct.unpack(\u0026#39;!6B\u0026#39;, raw_data[6:12])  src_mac = \u0026#39;%02x:%02x:%02x:%02x:%02x:%02x\u0026#39; % src_mac   if src_mac == \u0026#39;11:22:33:44:55:66\u0026#39;:  dst_mac = struct.unpack(\u0026#39;!6B\u0026#39;, raw_data[:6])  dst_mac = \u0026#39;%02x:%02x:%02x:%02x:%02x:%02x\u0026#39; % dst_mac   (len,) = struct.unpack(\u0026#39;!H\u0026#39;, raw_data[12:14])   data = raw_data[14:]  sniffPacket = SniffPacket() sniffPacket.run()  참고(Reference)  pyshark Docs  ","date":"February 10, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-02-10-pyshark-library-guide/","summary":"설치환경 : Windows 10, python 3.7\n1. 설치  와이어샤크 프로그램에 포함된 npcap 설치 필요  https://www.wireshark.org/download.html   pip install pyshark   2. 사용법   캡쳐파일 읽기\ncapture = pyshark.FileCapture(\u0026#39;./test.pcapng\u0026#39;)   실시간 패킷캡처 interface\ncapture = pyshark.LiveCapture(interface=\u0026#39;이더넷\u0026#39;, bpf_filter=\u0026#39;ether src host 11:22:33:44:55:66\u0026#39;, use_json=True, include_raw=True)   패킷 캡처\n 패킷 1개 캡처하거나 10ms 경과하면 캡처 결과 반환  capture.sniff(packet_count=1, timeout=10)  패킷 10개 캡처하거나 10ms 경과하면 캡처 결과 반환  capture.","tags":["python","library","sniff"],"title":"pyshark 라이브러리 사용법 (pyshark Library Guide)"},{"categories":["Python","Guide","Sniff"],"contents":" 설치환경 : Windows 10\n1. 설치  와이어샤크 프로그램에 포함된 npcap 설치 필요  https://www.wireshark.org/download.html   pip install --pre scapy[basic]  2. Client 예제 from scapy.all import * from scapy.utils import rdpcap  import datetime as dt  # PCAP 파일 읽기 # could be used like this rdpcap(\u0026#34;filename\u0026#34;,500) fetches first 500 pkts pkts = rdpcap(\u0026#34;./pcap/test.pcapng\u0026#34;, -1)  pkts = pkts[21:100]  cnt = 0 repeat = 10 s_time = dt.datetime.now()  for _ in range(repeat):  for pkt in pkts:  # print(f\u0026#34;hexdump(pkt) = {hexdump(pkt)}\u0026#34;)  # Send one or more packets at 2 layer  sendp(pkt, inter=0, loop=0, count=1, iface=None)   # Send one or more packets at 3 layer  # send(pkt, inter=0, loop=0, count=1, iface=None)  cnt += 1  print(cnt)  sendp(b\u0026#39;\u0026#39;, inter=0, loop=0, count=1, iface=None)  time.sleep(0.05)  e_time = dt.datetime.now() print(f\u0026#34;실행시간 : {e_time - s_time}\u0026#34;) 3. Server 예제  소량 데이터 스니핑에는 문제없으나 패킷 전송간격 1ms 이내의 스니핑은 TShark 이용하는 pyshark를 추천함  from scapy.all import * import struct  cnt = 0 while 1:  # 비동기 Sniffer 실행방식  # t = AsyncSniffer(prn=lambda x: x.summary(), count=10, store=True, filter=\u0026#39;host 11:22:33:44:55:66\u0026#39;)  # t.start()  # t.join()  # pkts = t.results   # 동기 sniff 실행방식  # filter 사용 참고사이트 (https://docs.extrahop.com/8.3/bpf-syntax/)  pkts = sniff(iface=None, count=800, store=True, filter=\u0026#39;ether src host 11:22:33:44:55:66\u0026#39;)   for pkt in pkts:  # 802.3 11:22:33:44:55:66 \u0026gt; e4:54:e8:51:d0:6f / LLC / Raw  cnt += 1  raw_data = bytes(pkt)   print(f\u0026#34;1. pkt.src = {pkt.src}\u0026#34;) # 11:22:33:44:55:66  print(f\u0026#34;2. pkt.dst = {pkt.dst}\u0026#34;) # aa:bb:cc:dd:ee:ff  print(f\u0026#34;3. pkt.len = {pkt.len}\u0026#34;)   dst_mac = struct.unpack(\u0026#39;!6B\u0026#39;, raw_data[:6])  dst_mac = \u0026#39;%02x:%02x:%02x:%02x:%02x:%02x\u0026#39; % dst_mac  print(f\u0026#34;4. dst_mac = {dst_mac}\u0026#34;)   src_mac = struct.unpack(\u0026#39;!6B\u0026#39;, raw_data[6:12])  src_mac = \u0026#39;%02x:%02x:%02x:%02x:%02x:%02x\u0026#39; % src_mac  print(f\u0026#34;5. src_mac = {src_mac}\u0026#34;)   (header,) = struct.unpack(\u0026#39;!H\u0026#39;, raw_data[12:14])  print(f\u0026#34;6. header = {header}\u0026#34;)   (val1,) = struct.unpack(\u0026#39;!B\u0026#39;, raw_data[14:15])  print(f\u0026#34;7. val1 = {val1}\u0026#34;)  (val2,) = struct.unpack(\u0026#39;!B\u0026#39;, raw_data[15:16])  print(f\u0026#34;8. val2 = {val2}\u0026#34;)   (val3,) = struct.unpack(\u0026#39;!L\u0026#39;, raw_data[16:20])  print(f\u0026#34;9. val3 = {val3}\u0026#34;)   data = raw_data[20:]  print(f\u0026#34;10. len(data) = {len(data)}\u0026#34;)   print(f\u0026#34;cnt = {cnt}\u0026#34;)  참고(Reference)  Scapy Docs  ","date":"February 9, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-02-09-scapy-library-guide/","summary":"설치환경 : Windows 10\n1. 설치  와이어샤크 프로그램에 포함된 npcap 설치 필요  https://www.wireshark.org/download.html   pip install --pre scapy[basic]  2. Client 예제 from scapy.all import * from scapy.utils import rdpcap  import datetime as dt  # PCAP 파일 읽기 # could be used like this rdpcap(\u0026#34;filename\u0026#34;,500) fetches first 500 pkts pkts = rdpcap(\u0026#34;./pcap/test.pcapng\u0026#34;, -1)  pkts = pkts[21:100]  cnt = 0 repeat = 10 s_time = dt.","tags":["python","library","sniff"],"title":"scapy 라이브러리 사용법 (Scapy Library Guide)"},{"categories":["Python","Guide"],"contents":" paramiko, scp 라이브러리 연계 사용한 ssh 파일 전송\n   라이브러리 암호화 여부 속도     paramiko 로그인:암호화 / 파일전송:암호화 느림   paramiko+scp 로그인:암호화 / 파일전송:평문 보통    실습환경 : windows10, 원격서버환경 : linux(RHEL8)\n사전에 ssh 접속가능한 linux를 구축한 후 실습 진행\n 1. 라이브러리 설치 pip install paramiko pip install scp paramiko : SSH 접속 및 종료 기능\n Docs URL - http://docs.paramiko.org/en/stable/  scp : 파일 전송 및 다운로드 기능\n Docs URL - https://pypi.org/project/scp/   2. 사용예제 코드 2.1. SSHManager SSHManager.py\nimport paramiko from scp import SCPClient, SCPException  class SSHManager:  def __init__(self):  self.ssh_client = None   def create_ssh_client(self, hostname, port, username, password):  try:  if self.ssh_client is None:  self.ssh_client = paramiko.SSHClient()  self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())  self.ssh_client.connect(hostname, port, username=username, password=password)  print(f\u0026#34;[create_ssh_client] host = {hostname}:{port}/{username}\u0026#34;)  else:  print(f\u0026#34;[create_ssh_client] SSH client session exist. {hostname}\u0026#34;)   except Exception as ex:  print(f\u0026#34;[create_ssh_client] Error : {ex}\u0026#34;)   def close_ssh_client(self):  try:  self.ssh_client.close()  print(f\u0026#34;[close_ssh_client] Disconnect\u0026#34;)  except Exception as ex:  print(f\u0026#34;[close_ssh_client] Error : {ex}\u0026#34;)   def send_file(self, local_path, remote_path):  try:  with SCPClient(self.ssh_client.get_transport()) as scp:  scp.put(local_path, remote_path, preserve_times=True)  print(f\u0026#34;[send_file] local_path = {local_path}| remote_path = {remote_path}\u0026#34;)  except SCPException:  print(f\u0026#34;[send_file] SCP Error : {SCPException.message}\u0026#34;)  raise SCPException.message  except Exception as ex:  print(f\u0026#34;[send_file] Error : {ex}\u0026#34;)   def get_file(self, remote_path, local_path):  try:  with SCPClient(self.ssh_client.get_transport()) as scp:  scp.get(remote_path, local_path)  except SCPException:  print(f\u0026#34;[send_file] SCP Error : {SCPException.message}\u0026#34;)  raise SCPException.message  except Exception as ex:  print(f\u0026#34;[get_file] Error : {ex}\u0026#34;)   def send_command(self, cmd):  try:  print(f\u0026#34;[send_command] cmd = {cmd}\u0026#34;)  stdin, stdout, stderr = self.ssh_client.exec_command(cmd)  return stdout.readlines()  except Exception as ex:  print(f\u0026#34;[send_command] Error : {ex}| cmd = {cmd}\u0026#34;) 2.2. client client.py\nfrom SSHManager import SSHManager  class Client:  def run(self):  self.create_dir(\u0026#34;server_dir\u0026#34;)   # 원격서버 SSH 접속  self.client = SSHManager()  self.client.create_ssh_client(\u0026#34;hostname\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;)   # 파일 업로드  self.client.send_file(\u0026#39;local_path\u0026#39;, \u0026#39;remote_path\u0026#39;)  # 파일 다운로드  self.client.get_file(\u0026#39;remote_path\u0026#39;, \u0026#39;local_path\u0026#39;)   # 압축파일 해제  self.decompress(\u0026#39;server_dir\u0026#39;, \u0026#39;filename\u0026#39;)  # 압축파일 삭제  self.remove_file(\u0026#39;server_dir\u0026#39;, \u0026#39;filename\u0026#39;)   # 원격서버 SSH 접속종료  self.client.close_ssh_client()   def create_dir(self, server_dir):  try:  cmd = f\u0026#39;mkdir -m 775 -p {server_dir}\u0026#39;  self.client.send_command(cmd)  except Exception as ex:  print(f\u0026#34;[create_dir] Error = {ex}\u0026#34;)   def decompress(self, server_dir, filename):  try:  cmd = f\u0026#34;unzip {server_dir}/{filename}-d {server_dir}/{filename.split(\u0026#39;.\u0026#39;)[0]}/\u0026#34;  result = self.client.send_command(cmd)  if result:  print(f\u0026#34;[decompress] 압축해제 성공 | filename = {filename}\u0026#34;)  else:  print(f\u0026#34;[decompress] 압축해제 실패 | filename = {filename}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[decompress] Error = {ex}| filename = {filename}\u0026#34;)   def remove_file(self, server_dir, filename):  try:  cmd = f\u0026#39;rm -f {server_dir}/{filename}\u0026#39;  self.client.send_command(cmd)  except Exception as ex:  print(f\u0026#34;[remove_file] Error = {ex}| filename = {filename}\u0026#34;)  client = Client() client.run()  참고(Reference)  SSH \u0026amp; SCP in Python with Paramiko  ","date":"January 6, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2021-01-06-paramiko-scp-guide/","summary":"paramiko, scp 라이브러리 연계 사용한 ssh 파일 전송\n   라이브러리 암호화 여부 속도     paramiko 로그인:암호화 / 파일전송:암호화 느림   paramiko+scp 로그인:암호화 / 파일전송:평문 보통    실습환경 : windows10, 원격서버환경 : linux(RHEL8)\n사전에 ssh 접속가능한 linux를 구축한 후 실습 진행\n 1. 라이브러리 설치 pip install paramiko pip install scp paramiko : SSH 접속 및 종료 기능\n Docs URL - http://docs.","tags":["python","library"],"title":"paramiko-scp 라이브러리 사용법 (paramiko-scp Library Guide)"},{"categories":["Linux","NFS"],"contents":" 설치환경 : 레드햇8 (RHEL8)\n1. NFS 서버 설정 (Server Setting) 1.1. NFS 패키지 설치 yum패키지 설치 도구로 nfs-utils 패키지 설치\nyum install nfs-utils 1.2. NFS서버 서비스 실행 및 OS재부팅시 활성화 nfs서버 데몬 실행하고, OS 재부팅시 자동실행되도록 활성화\nsystemctl start nfs-server systemctl enable nfs-server 1.3. 외부에서 접근할 디렉토리 설정 공유할 디렉토리 생성\nmkdir /NFSVOL01 외부에서 접근할 디렉토리, 외부 접근IP, 접근권한을 exports 파일로 설정\nvi /etc/exports  /NFSVOL01 192.168.0.0/255.255.255.0(rw)  /NFSVOL01 : 공유할 디렉토리\n192.168.0.0/255.255.255.0 : 접속허용 IP 대역\nrw : 디렉토리 권한\n 디렉토리 권한 옵션\n ro : 읽기 (default) rw : 읽기 쓰기 root_squash : 클라이언트 root 권한 접속불가 (default), 루트권한요청(uid/gid -\u0026gt; 0)을 익명계정으로 맵핑 no_root_squash : 클라이언트 root 권한 접속가능 all_squash : 모든 접속권한(uid/gid)을 익명계정으로 맵핑 (default) no_all_squash : no_root_squash 옵션과 동일 sync : 변경 사항이 커밋된 후에만 요청에 응답하여 안정적인 저장가능 (default) async : 요청에 의해 변경되기 전에 요청에 응답, 일반적으로 성능은 향상되지만 비용이 많이 소요.\n부정한 서버 재시작(충돌 등)으로 인해 데이터가 손상 될 수 있음  1.4. exports 파일적용 exports 작성한 내용 적용\nexportfs -ra 1.5. NFS 서비스 방화벽 허용 방화벽이 실행중인 경우 nfs서비스를 방화벽에 허용 정책등록\nfirewall-cmd --permanent --add-service=nfs firewall-cmd --reload firewall-cmd --list-all  \u0026ndash;permanent : 영구등록\n\u0026ndash;add-service=nfs : 허용할 서비스\n\u0026ndash;reload : 방화벽 재시작\n\u0026ndash;list-all : 등록된 방화벽 정책목록 보기\n 1.6. NFS 서비스 동작확인 showmount -e exportfs -s  showmount -e : export된 디렉토리의 목록보기\nexportfs -s : 현재 NFS 설정 확인\n 1.7. 클라이언트 권한설정 클라이언트에서 파일업로드등 쓰기 권한이 필요한 경우 설정\nchmod 777 /NFSVOL01  2. NFS 클라이언트 설정 (Clinet Setting) 2.1. NFS 패키지 설치 yum패키지 설치 도구로 nfs-utils 패키지 설치\nyum install nfs-utils 2.2. mount 서버 확인 NFS 서버 동작 확인\nshowmount -e 192.168.0.100  192.168.0.100 : nfs 서버 주소\n 2.3. mount 등록할 디렉토리 생성 NFS 클라이언트에서 서버로 마운트 등록할 디렉토리 생성\nmkdir /NFSVOL01 2.4. 디렉토리 mount 생성된 디렉토리에 NFS디렉토리 마운트\nmount -t nfs 192.168.0.100:/NFSVOL01 /NFSVOL01 2.5. mount 확인 df -h | grep NFSVOL01 2.6. OS 부팅시 자동 mount mount 영구설정(/etc/fstab) 파일에 등록\nvi /etc/fstab  192.168.0.100:/NFSVOL01 /NFSVOL01 nfs hard 0 0  192.168.0.100:/NFSVOL01 : NFS 서버주소 및 서버 디렉토리 /NFSVOL01 : Mount Point로 클라이언트 디렉토리 지정 nfs : 파일시스템 종류로 NFS사용시 nfs로 지정 hard : 타임아웃이 발생되면 server not responding을 출력하고 무한정 재시도 soft : 타임아웃이 발생되면 프로그램에게 I/O 에러 보고 0 : 덤프 설정(0-덤프불가 / 1-덤프가능) 0 : 무결성 검사설정(0-검사하지않음 / 1-우선순위1로 대부분 루트설정 / 2-우선순위2)  ","date":"January 6, 2021","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/os/linux/2021-01-06-linux-nfs-setting/","summary":"설치환경 : 레드햇8 (RHEL8)\n1. NFS 서버 설정 (Server Setting) 1.1. NFS 패키지 설치 yum패키지 설치 도구로 nfs-utils 패키지 설치\nyum install nfs-utils 1.2. NFS서버 서비스 실행 및 OS재부팅시 활성화 nfs서버 데몬 실행하고, OS 재부팅시 자동실행되도록 활성화\nsystemctl start nfs-server systemctl enable nfs-server 1.3. 외부에서 접근할 디렉토리 설정 공유할 디렉토리 생성\nmkdir /NFSVOL01 외부에서 접근할 디렉토리, 외부 접근IP, 접근권한을 exports 파일로 설정\nvi /etc/exports  /NFSVOL01 192.168.0.0/255.255.255.0(rw)  /NFSVOL01 : 공유할 디렉토리","tags":["linux","nfs"],"title":"리눅스 NFS 설정 (Linux NFS Setting)"},{"categories":["Algorithm","Programmers"],"contents":" 프린터 분류 : 스택/큐\n문제 링크\n 우선순위 priorities 리스트의 최댓값을 num_max변수에 대입 cursor변수에 priorities[0]값 추출하여 대입 cursor 값이 최댓값 일때 cnt 1증가 이때 location값이 0이면 break cursor 값이 최댓값 아닐때 리스트 맨뒤에 cursor 값 추가 이때 location값이 0이면 location변수에 priorities길이값 대입 location 1 감소 위의 순서를 location 0 이상일때 while문 반복실행  def solution(priorities, location):  cnt = 1  while True:  num_max = max(priorities)  cursor = priorities.pop(0)  if cursor == num_max:  if location == 0:  return cnt  cnt += 1  else:  priorities.append(cursor)  if location == 0:  location = len(priorities)  location -= 1 2020-12-22\n min TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.99ms, 10.1MB\n  기능개발 분류 : 스택/큐\n문제 링크\n방법1  progresses[0]+(speeds[0]*i) 값이 100 이상 될 수 있는 i값을 num변수에 대입 후 for 문 break progresses리스트 원소마다 speeds[i]*num 값 덧셈 최대 progresses리스트 길이만큼 반복하여 progresses[0] 원소를 비교하는 for 문 실행  해당 원소가 100 이상일 때 cnt 1증가 및 progresses[0], speeds[0] 삭제, 해당 원소가 100미만일 때 break   cnt변수값을 answer리스트에 추가 위의 과정을 progresses리스트 값이 있다면 while 문 반복 실행  def solution(progresses, speeds):  answer = []   while progresses:  num = 0  for i in range(1, 100):  total = progresses[0]+(speeds[0]*i)  if 100 \u0026lt;= total:  num = i  break   for i in range(len(progresses)):  progresses[i] += (speeds[i]*num)  cnt = 0  for _ in range(len(progresses)):  if 100 \u0026lt;= progresses[0]:  progresses.pop(0)  speeds.pop(0)  cnt += 1  else:  break  answer.append(cnt)   return answer 2020-12-23\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.12ms, 10.1MB\n 방법2  (100 - progresses) // speeds 결과값이 작업 소요일자  def solution(progresses, speeds):  answer = []  m, cnt = 0, 0  for i, j in zip(progresses, speeds):  n = (100-i)//j + 1 if (100-i) % j else (100-i)//j  if not m:  m = n   if m \u0026lt; n:  answer.append(cnt)  m = n  cnt = 1  else:  cnt += 1   return answer if sum(answer) == len(speeds) else answer + [cnt] 2021-02-03\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.03ms, 10.1MB\n  다리를 지나는 트럭 분류 : 스택/큐\n문제 링크\n변수 정의\n bridge_length : 다리길이 weight : 다리 설계하중 truck_weights : 다리를 건널 트럭의 무게(값)와 순서(index) answer : 경과한 시간 bredge_list : 다리를 건너는 중인 트럭의 목록과 위치 ex) [[트럭 무게, 트럭 위치], [트럭 무게, 트럭 위치], \u0026hellip;] cnt : 한 번에 이동할 거리   bredge_list리스트 값이 있을 때  bredge_list[0][1]값이 bridge_length보다 크다면  weight값에 bredge_list[0][0]값 추가 첫 번째 트럭이 다리를 다 지나갔다면 다리가 견딜 수 있는 하중을 복구 bredge_list[0]삭제 리스트에서 첫 번째 트럭 정보 삭제     truck_weights리스트 값이 있을 때  truck_weights[0]값(첫 번째 트럭)을 truck변수에 저장 weight - truck값이 0 이상 일 때  weight값에서 truck만큼 뺄셈 견딜 수 있는 다리 하중 줄어듦 bredge_list리스트에 [truck, 1]값 추가 다리를 건너는 중인 트럭 정보 추가 무게와 위치 truck_weights[0] 삭제 진입 대기 중인 트럭 목록에서 첫 번째 트럭 정보 삭제   다리에 트럭이 추가로 진입할 수 없을 때  bredge_list[0][1]값이 bridge_length보다 크기 위한 cnt값 구하기 다리에 진입한 맨 앞의 트럭이 다리를 건너기 위해 덧셈할 값     bredge_list리스트의 트럭 위치값에 cnt값 덧셈  다리에 진입한 트럭들의 위치 이동   answer값에 cnt값 덧셈  다리에서 이동한 거리만큼 시간이 경과하였기에 cnt값으로 덧셈   bredge_list, truck_weights 둘 중 하나라도 값이 있으면 while 반복 실행  def solution(bridge_length, weight, truck_weights):  answer = 0  bredge_list = []  while bredge_list or truck_weights:  # 트럭이 다리를 건넜을때  if bredge_list:  if bridge_length \u0026lt; bredge_list[0][1]:  weight += bredge_list[0][0]  del bredge_list[0]   cnt = 1 # 한번에 이동할 거리  # 트럭 진입  if truck_weights:  truck = truck_weights[0]  # 진입할 트럭의 무게를 다리가 버틸수 있을때  if 0 \u0026lt;= weight-truck:  weight -= truck  bredge_list.append([truck, 1])  del truck_weights[0]  else:  # 트럭 추가 진입이 불가능할때 한번에 계산  for i in range(1, bridge_length+1):  if bridge_length \u0026lt; (bredge_list[0][1] + i):  cnt = i  break   # 트럭이 다리를 지나간 정도  for i in range(len(bredge_list)):  bredge_list[i][1] += cnt  answer += cnt  return answer 2020-12-23\n min TaseCase : 0.02ms, 10.3MB\nmax TaseCase : 27.21ms, 10.3MB\n  멀쩡한 사각형 분류 : Summer/Winter Coding(2019)\n문제 링크\n방법1  h값이 정수로 나오기위한 최소 w값을 구하기 위해 최대공약수를 gcd변수에 대입 이때 색칠된 픽셀의 갯수는 w+h-1개 w+h-1 곱하기 gcd값이 색칠된 사각형 갯수 line_pixel변수에 대입 반환값은 사각형의 면적인 w*h에서 line_pixel값을 뺄셈하여 반환  def solution(w,h):  gcd = 1   dict1 = prime(w)  dict2 = prime(h)  # 최대공약수  for num in dict1:  if num in dict2:  gcd *= (num ** min(dict1[num], dict2[num]))   line_pixel = ((w+h)/gcd-1) * gcd  return w*h-int(line_pixel)  def prime(num):  num_dict = {}  i = 2  while i \u0026lt;= num:  if num%i == 0:  if i in num_dict:  num_dict[i] += 1  else:  num_dict[i] = 1  num //= i  else:  i += 1  return num_dict 2020-12-24\n min TaseCase : 0.01ms, 10MB\nmax TaseCase : 6345.39ms, 10.1MB\n 방법2  h값이 정수로 나오기위한 정수 최소 w값을 구하기 위해 최대공약수 구하기   유클리드 호제법 공식으로 최대공약수 구하여 v_gcd 변수에 대입  이때 색칠된 픽셀의 갯수는 w+h-1개 w+h-1 곱하기 gcd값이 색칠된 사각형 갯수 line_pixel변수에 대입 반환값은 사각형의 면적인 w*h에서 line_pixel값을 뺄셈하여 반환  def solution(w,h):  v_gcd = f_gcd(max(w,h), min(w,h))   line_pixel = ((w+h)/v_gcd-1) * v_gcd  return w*h-int(line_pixel)  def f_gcd(n_max, n_min):  while n_min != 0:  t = n_max % n_min  (n_max, n_min) = (n_min, t)  return abs(n_max) 2020-12-27\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.01ms, 10.3MB\n 방법3  h값이 정수로 나오기위한 정수 최소 w값을 구하기 위해 최대공약수 구하기   math 라이브러리의 gcd 함수로 구하고 gcd변수에 대입  이때 색칠된 픽셀의 갯수는 w+h-1개 w+h-1 곱하기 gcd값이 색칠된 사각형 갯수 line_pixel변수에 대입 반환값은 사각형의 면적인 w*h에서 line_pixel값을 뺄셈하여 반환  import math  def solution(w,h):  gcd = math.gcd(w,h)   line_pixel = ((w+h)/gcd-1) * gcd  return w*h-int(line_pixel) 2020-12-24\n min TaseCase : 0.00ms, 10.3MB\nmax TaseCase : 0.01ms, 10.3MB\n  조이스틱 분류 : 탐욕법(Greedy)\n문제 링크\n변수 정의\n move_cnt : 조이스틱이 움직인 횟수 text_len : 입력받은 문자열 길이 alphabet : 조이스틱 위아래 움직인 횟수에 따른 알파벳 문자목록 tf_list : 문자 \u0026lsquo;A\u0026rsquo;를 제외한 다른문자 여부목록 distance_r : 기준위치 오른쪽으로 True 까지의 거리 distance_l : 기준위치 왼쪽으로 True 까지의 거리   필요한 변수 선언 및 초기화 문자열 길이만큼 for 반복문을 실행  alphabet리스트에서 name[i]값의 위치를 index변수에 대입 B~N까지는 조이스틱 위로 이동한것으로 index + move_cnt값을 move_cnt변수에 대입 Z~O까지는 조이스틱 아래로 이동한것으로 index-13 + move_cnt값을 move_cnt변수에 대입 해당 문자로 변환하기까지의 조이스틱 움직인 횟수를 구함   tf_list리스트에서 True값이 있을때만 while 반복문 실행  1부터 text_len까지 반복하여 tf_list[(i+j)%text_len]값에 True값 나올때까지 distance_r변수 1증가  기준위치 오른쪽으로 True값 까지의 거리   1부터 text_len까지 반복하여 tf_list[(i-j)%text_len]값에 True값 나올때까지 distance_l변수 1증가  기준위치 왼쪽으로 True값 까지의 거리   distance_l값보다 distance_r값이 클때 (i-1)%text_len값을 i변수에 대입  기준위치 왼쪽으로 1이동   distance_l값보다 distance_r값이 작거나 같을때 (i+1)%text_len값을 i변수에 대입  기준위치 오른쪽으로 1이동   거리 확인한 tf_list[i]값은 False값 대입하고 move_cnt변수 1증가    def solution(name):  move_cnt = 0  text_len = len(name)  alphabet = [\u0026#39;A\u0026#39;,\\  \u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;G\u0026#39;,\u0026#39;H\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;J\u0026#39;,\u0026#39;K\u0026#39;,\u0026#39;L\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;N\u0026#39;,\\  \u0026#39;Z\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;T\u0026#39;,\u0026#39;S\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;Q\u0026#39;,\u0026#39;P\u0026#39;,\u0026#39;O\u0026#39;]   tf_list = [False] * text_len  for i in range(text_len):  index = alphabet.index(name[i])  move_cnt = move_cnt+index if index \u0026lt;= 13 else move_cnt+(index-13)  if index: tf_list[i] = True   tf_list[0] = False  i = 0  while tf_list.count(True):  distance_r = 0  distance_l = 0   for j in range(1, text_len):  distance_r += 1  if tf_list[(i+j)%text_len]:  break   for j in range(1, text_len):  distance_l += 1  if tf_list[(i-j)%text_len]:  break   i = (i-1)%text_len if distance_l \u0026lt; distance_r else (i+1)%text_len  tf_list[i] = False   move_cnt += 1   return move_cnt 2020-12-28\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.03ms, 10.3MB\n  가장 큰 수 분류 : 정렬\n문제 링크\n추가 Test Case\n   numbers Return 검증 case     [12, 121] \u0026lsquo;12121\u0026rsquo; case 1~6   [21, 212] \u0026lsquo;21221\u0026rsquo; case 1~6   [0, 0, 0] \u0026lsquo;0\u0026rsquo; case 11    방법1 변수 정의\n int(math.log10(x)+1 if x else 0) : 입력값 x의 자릿수 구하기   sort함수를 사용하여 numbers 리스트 역정렬 첫번째 정렬조건 원소 x문자열에 x[0] 문자를 (최대자릿수-x자릿수)만큼 추가하여 비교 두번째 정렬조건 x%10 나머지 값으로 정렬 정렬된 numbers 첫번째 값이 0 아닐때 numbers리스트를 하나의 문자열로 합쳐서 반환 정렬된 numbers 첫번째 값이 0 이면 '0' 문자반환  import math  def solution(numbers):  numbers.sort(key=lambda x: (int(str(x)+(str(x)[0]*(4-int(math.log10(x)+1 if x else 0)))), x%10), reverse=True)  return \u0026#39;\u0026#39;.join(map(str, numbers)) if numbers[0] != 0 else \u0026#39;0\u0026#39; 2021-01-07\n min TaseCase : 0.04ms, 10.3MB\nmax TaseCase : 134.49ms, 23.8MB\n 방법2  numbers리스트 int형 원소들을 map함수로 str형으로 변환 원소 x 문자길이를 증가시키기위해 문자열길이 3배 증가시켜 역정렬   30, 34, 3 -\u0026gt; 303030, 343434, 333 첫문자부터 비교 입력정수는 최대 1000이하 이므로 *3 부터 문제없이 실행가능  정렬된 numbers 첫번째 값이 0 아닐때 numbers리스트를 하나의 문자열로 합쳐서 반환 정렬된 numbers 첫번째 값이 0 이면 '0' 문자반환  def solution(numbers):  numbers = list(map(str, numbers))  numbers.sort(key=lambda x : x*3, reverse=True)  return \u0026#39;\u0026#39;.join(numbers) if numbers[0] != \u0026#39;0\u0026#39; else \u0026#39;0\u0026#39; 2021-01-07\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 56.59ms, 27.5MB\n 방법3  방법2와 동일한 알고리즘이나 2줄로 작성하기위해 sorted 함수를 사용   sorted와sort는 정렬 과정은 동일하나 sorted의 경우 리스트 복사과정이 추가되어 메모리를 추가로 할당받음  def solution(numbers):  numbers = sorted(list(map(str, numbers)), key=lambda x: x*3, reverse=True)  return \u0026#39;\u0026#39;.join(numbers) if numbers[0] != \u0026#39;0\u0026#39; else \u0026#39;0\u0026#39; 2021-01-07\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 55.10ms, 28.2MB\n  소수 찾기 분류 : 완전탐색\n문제 링크\n 입력받은 numbers 문자열로 만들수 있는 모든 정수형 리스트 numbers_list 생성  permutations 라이브러리를 사용하여 조합할 수 있는 모든 값 생성   numbers_list 리스트 중복제거 numbers_list 리스트를 prime_number함수로 소수 판별  숫자 num의 약수는 제곱근(num) 범위에 있다 원리를 이용하여 판별   판별결과를 answer변수에 합산하여 반환  from itertools import permutations  def solution(numbers):  answer = 0  numbers_list = []   # 모든 정수형 리스트 만들기  for i in range(1, len(numbers)+1):  num_list = list(permutations(list(numbers), i))   for num in num_list:  numbers_list.append(int(\u0026#39;\u0026#39;.join(list(num))))   # 중복제거  numbers_list = list(set(map(int, numbers_list)))   # 소수 판별후 갯수 체크  for n in numbers_list:  if prime_number(n):  answer += 1   return answer  def prime_number(n):  if n == 2:  return True  elif (n % 2 == 0) or (n \u0026lt; 2):  return False   sqrt = int(n**0.5)+1  for i in range(3,sqrt+1,2):  if n % i == 0:  return False  return True 2021-01-09\n min TaseCase : 0.04ms, 10.4MB\nmax TaseCase : 13.19ms, 10.6MB\n  큰 수 만들기 분류 : 탐욕법(Greedy)\n문제 링크\n추가 Test Case\n   number k return     \u0026ldquo;99999\u0026rdquo; 4 \u0026ldquo;9\u0026rdquo;   \u0026ldquo;543212345\u0026rdquo; 3 \u0026ldquo;543345\u0026rdquo;   \u0026ldquo;87654321\u0026rdquo; 3 \u0026ldquo;87654\u0026rdquo;   \u0026ldquo;54329\u0026rdquo; 4 \u0026ldquo;9\u0026rdquo;     앞숫자가 뒷숫자보다 작은 수일때 앞숫자 삭제  def solution(number, k):  answer = number[0]  for i in number[1:]:  answer += i  try:  while k and answer[-2] \u0026lt; answer[-1]:  answer = answer[:-2] + answer[-1]  k -= 1  except IndexError: pass  return answer[:-k] if k else answer 2021-01-13\n min TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 207.73ms, 11.6MB\n  H-Index 분류 : 정렬\n문제 링크\n추가 Test Case\n   citations(int[]) return     [12, 11, 0] 2   [6, 6, 6, 6, 6, 1] 5   [0, 1, 1, 1, 1, 3, 3, 4] 1    방법1 def solution(citations):  citations.sort(reverse=True)   h_index = 0  list_len = len(citations)  for i in range(list_len):  if citations[i] \u0026lt; h_index+1:  if h_index \u0026lt; list_len-(i+1):  h_index -= 1  else:  break  else:  h_index += 1  return h_index 2021-01-14\n min TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.25ms, 10.2MB\n 방법2 추가 Test Case\n   citations(int[]) return     [12, 11, 0] 2   [6, 6, 6, 6, 6, 1] 5     방법1 3번째 Test Case 예외처리 안한 코드  def solution(citations):  citations.sort(reverse=True)  for i, num in enumerate(citations, start=1):  if num \u0026lt; i: return i-1  return i 2021-01-14\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.18ms, 10.2MB\n  위장 분류 : 해시\n문제 링크\n추가 Test Case\n   clothes(string[][]) Return     [[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;a\u0026rsquo;], [\u0026lsquo;b\u0026rsquo;, \u0026lsquo;b\u0026rsquo;], [\u0026lsquo;c\u0026rsquo;, \u0026lsquo;c\u0026rsquo;]] 7   [[1, \u0026lsquo;a\u0026rsquo;], [2, \u0026lsquo;a\u0026rsquo;], [3, \u0026lsquo;a\u0026rsquo;], [1, \u0026lsquo;b\u0026rsquo;], [2, \u0026lsquo;b\u0026rsquo;], [3, \u0026lsquo;b\u0026rsquo;], [1, \u0026lsquo;c\u0026rsquo;], [2, \u0026lsquo;c\u0026rsquo;], [3, \u0026lsquo;c\u0026rsquo;]] 63     테스트 케이스 2번째 예시로 순열 (3C0 + 3C1) * (3C0 + 3C1) * (3C0 + 3C1) - 1 조합의 갯수이다.  def solution(clothes):  clothes_dict = {}  # 카테고리명과 해당 카테고리 갯수 추출  for cloth in clothes:  if cloth[1] in clothes_dict:  clothes_dict[cloth[1]] += 1  else:  clothes_dict[cloth[1]] = 1  # 조합 연산  answer = 1  for cloth in clothes_dict.values():  answer *= cloth+1  return answer-1 2021-01-14\n min TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.02ms, 10.2MB\n  카펫 분류 : 완전탐색\n문제 링크\n추가 Test Case\n   brown(int) yellow(int) return     18 6 6     (산술기하평균 공식)과 (약수 중간값은 수의 제곱근 이하) 2가지 공식 이용  def solution(brown, yellow):  sqrt = int(yellow**0.5)  while 0 \u0026lt; sqrt:  if (yellow%sqrt == 0) and ((yellow/sqrt+2)*(sqrt+2) == brown+yellow):  return [yellow/sqrt+2, sqrt+2]  sqrt -= 1 2021-01-14\n min TaseCase : 0.01ms, 10MB\nmax TaseCase : 0.06ms, 10.3MB\n  타겟 넘버 분류 : 깊이/너비 우선 탐색(DFS/BFS)\n문제 링크\n재귀 함수 사용\n방법1 def solution(numbers, target):  global max  global n_list  max = len(numbers)  n_list = numbers   return calc(target, 0)  def calc(tot, n):  cnt = 0  if n \u0026lt; max:  cnt += calc(tot + n_list[n], n+1)  cnt += calc(tot - n_list[n], n+1)  elif tot == 0:  cnt = 1  return cnt 2021-01-25\n min TaseCase : 0.51ms, 10.2MB\nmax TaseCase : 310.07ms, 10.2MB\n 방법2 def solution(numbers, target):  if not numbers and target == 0:  return 1  elif not numbers:  return 0  else:  return solution(numbers[1:], target-numbers[0]) + solution(numbers[1:], target+numbers[0]) 2021-01-25\n min TaseCase : 0.58ms, 10.2MB\nmax TaseCase : 372.97ms, 10.2MB\n  이진 변환 반복하기 분류 : 월간 코드 챌린지 시즌1\n문제 링크\ndef solution(s):  bin_cnt, zero_cnt = 0, 0  while s != \u0026#39;1\u0026#39;:  cnt = s.count(\u0026#39;0\u0026#39;)  s = str(bin(len(s)-cnt))[2:]  bin_cnt += 1  zero_cnt += cnt  return [bin_cnt, zero_cnt] 2021-01-14\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.64ms, 10.3MB\n  최댓값과 최솟값 분류 : 연습문제\n문제 링크\ndef solution(s):  s = list(map(int, s.split(\u0026#39; \u0026#39;)))  return f\u0026#34;{min(s)}{max(s)}\u0026#34; 2021-01-18\n min TaseCase : 0.02ms, 10.3MB\nmax TaseCase : 0.05ms, 10.3MB\n  피보나치 수 분류 : 연습문제\n문제 링크\n방법1 def solution(n):  num_list = [0, 1] + [0] * (n-1)  for i in range(2, len(num_list[2:])+2):  num_list[i] = num_list[i-2] + num_list[i-1]  return num_list[-1]%1234567 if n else 0 2021-01-18\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 376.82ms, 456MB\n 방법2 def solution(num):  n, m = 0, 1  for _ in range(1, num):  n, m = m, n+m  return m % 1234567 if n else 0 2021-01-18\n min TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 147.18ms, 10.1MB\n  행렬의 곱셈 분류 : 연습문제\n문제 링크\n   변수명 형식 크기     arr1 2차원리스트 m * k   arr2 2차원리스트 k * n   answer 2차원리스트 m * n    list 자료형 for문 반복문에서 사용할때 일반적인 속도순서(위부터 빠름)\n for val in list: for i in range(len(list)): for i, val in enumerate(list):  list 자료형 for문 반복문에서 사용할때 list 인젝싱포함될경우 속도순서(list 200개 이상)\n for i, val in enumerate(list):  val   for i in range(len(list)):  list[i]    방법1 def solution(arr1, arr2):  answer = []  for m, val1 in enumerate(arr1):  arr_list = []  for k in range(len(arr2[0])):  total = 0  for n, val2 in enumerate(arr2):  total += val1[n] * val2[k]  arr_list.append(total)  answer.append(arr_list)  return answer 2021-01-21\n min TaseCase : 0.56ms, 10.3MB\nmax TaseCase : 52.38ms, 11MB\n 방법2 def solution(arr1, arr2):  answer = [[0 for _ in range(len(arr2[0]))] for _ in range(len(arr1))]  for m, val1 in enumerate(arr1):  for k in range(len(arr2[0])):  for n, val2 in enumerate(arr2):  answer[m][k] += val1[n] * val2[k]  return answer 2021-01-21\n min TaseCase : 0.76ms, 10.3MB\nmax TaseCase : 78.02ms, 11.2MB\n  JadenCase 문자열 만들기 분류 : 연습문제\n문제 링크\n추가 Test Case\n   s(string) Return     \u0026quot; a b c d \u0026quot; \u0026quot; A B C D \u0026quot;    방법1 def solution(s):  return \u0026#39; \u0026#39;.join([text[0].upper() + text[1:].lower() if text else \u0026#39;\u0026#39; for text in s.split(\u0026#39; \u0026#39;)]) 2021-01-21\n min TaseCase : 0.01ms, 9.98MB\nmax TaseCase : 0.01ms, 10.3MB\n 방법2  내장함수 capitalize() : 문자열 첫 글자를 대문자로 변환  def solution(s):  return \u0026#39; \u0026#39;.join([text.capitalize() if text else \u0026#39;\u0026#39; for text in s.split(\u0026#39; \u0026#39;)]) 2021-01-21\n min TaseCase : 0.00ms, 9.98MB\nmax TaseCase : 0.01ms, 10.2MB\n  N개의 최소공배수 분류 : 연습문제\n문제 링크\n유클리드 호제법 사용\n방법1 def solution(arr):  n_dict = {}  for n in arr:  for i, val in euclidean(n).items():  if (not i in n_dict) or (n_dict[i] \u0026lt; val):  n_dict[i] = val  answer = 1  for i, val in n_dict.items():  answer *= (i**val)  return answer  def euclidean(n):  n_dict = {}  i = 2  while 1 \u0026lt; n:  if not n % i:  n //= i  n_dict[i] = n_dict[i] + 1 if i in n_dict else 1  else:  i += 1  return n_dict 2021-01-21\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.03ms, 10.2MB\n 방법2 def solution(arr):  answer = arr[0]  for i in arr[1:]:  answer = lcm(answer, i)  return answer  def lcm(m, n):  return m * n // gcd(m, n)  def gcd(m, n):  while n != 0:  t = m % n  (m,n) = (n,t)  return m 2021-01-21\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.01ms, 10.3MB\n  소수 만들기 분류 : Summer/Winter Coding(~2018)\n문제 링크\n2부터 제곱근까지 나머지 연산하여 0이 안 나올 때 소수로 판정\n방법1  순열로 조합 생성  def solution(nums):  cnt = 0  nums_list = []   for i, val1 in enumerate(nums[:-2]):  for j, val2 in enumerate(nums[i+1:-1], start=i+1):  for val3 in nums[j+1:]:  if prime(sum([val1, val2, val3])):  cnt += 1  return cnt  def prime(n):  if n == 2:  return True  elif (n % 2 == 0) or (n \u0026lt; 2):  return False   sqrt = int(n**0.5)+1  for i in range(3,sqrt+1,2):  if n % i == 0:  return False  return True 2021-01-23\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 12.70ms, 10.3MB\n 방법2  중복되지 않은 원소를 가진 순열조합 combinations 함수  from itertools import combinations def solution(nums):  cnt = 0  for n_list in combinations(nums, 3):  if prime(sum(n_list)):  cnt += 1  return cnt  def prime(n):  if n == 2:  return True  elif (n % 2 == 0) or (n \u0026lt; 2):  return False   sqrt = int(n**0.5)+1  for i in range(3,sqrt+1,2):  if n % i == 0:  return False  return True 2021-01-23\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 12.11ms, 10.3MB\n  예상 대진표 분류 : 2017 팁스타운\n문제 링크\n바텀업 알고리즘 풀이\ndef solution(n, a, b):  cnt = 1  while cnt \u0026lt;= 20:  a = (a+1) // 2  b = (b+1) // 2  if a == b:  break  cnt += 1  return cnt 2021-01-24\n min TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.01ms, 10.2MB\n  124 나라의 숫자 분류 : 연습문제\n문제 링크\n방법1 def solution(n):  ans = \u0026#39;\u0026#39;  while 0 \u0026lt; n:  n, m = n//3, n%3  if not m:  n, m = n-1, 4  ans = str(m) + ans  return ans 2021-02-06\n min TaseCase : 0.01ms, 10MB\nmax TaseCase : 0.01ms, 10.3MB\n 방법2  divmod(n, a) : 정수를 나눈 몫과 나머지를 구하는 함수   n : 나누어야할 수 a : 나눌 기준값  일반적인 a//b, a%b와 퍼포먼스 차이\ndef solution(n):  ans = \u0026#39;\u0026#39;  while 0 \u0026lt; n:  n, m = divmod(n-1, 3)  if not m:  n, m = n-1, 4  ans = str(m) + ans  return ans 2021-02-06\n min TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.01ms, 10.3MB\n 방법3 def solution(n):  num = [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;4\u0026#39;]  ans = \u0026#39;\u0026#39;  while 0 \u0026lt; n:  n -= 1  ans = num[n % 3] + ans  n //= 3  return ans  min TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.01ms, 10.3MB\n  스킬트리 분류 : Summer/Winter Coding(~2018)\n문제 링크\n추가 Test Case\n   skill skill_trees return     \u0026ldquo;REA\u0026rdquo; [\u0026ldquo;POA\u0026rdquo;] 0   \u0026ldquo;CBD\u0026rdquo; [\u0026ldquo;BDA\u0026rdquo;] 0   \u0026ldquo;CBD\u0026rdquo; [\u0026ldquo;AEF\u0026rdquo;, \u0026ldquo;ZJW\u0026rdquo;] 2    방법1 def solution(skill, skill_trees):  ans = 0  for s in skill_trees:  n = s.find(skill[0])  pos = True  for i in skill[1:]:  if (0 \u0026lt;= s.find(i) \u0026lt; n) or (n == -1 and i in s):  pos = False  break  n = s.find(i)  if pos:  ans += 1  return ans 2021-02-07\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.03ms, 10.2MB\n 방법2  for~else문   break 등 중간에 안 끊기고 끝까지 실행하면 else문 실행  def solution(skill, skill_trees):  ans = 0  for s in skill_trees:  n = s.find(skill[0])  for i in skill[1:]:  if (0 \u0026lt;= s.find(i) \u0026lt; n) or (n == -1 and i in s):  break  n = s.find(i)  else:  ans += 1  return ans 2021-02-07\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.03ms, 10.2MB\n 방법3 def solution(skill,skill_tree):  ans = 0  for i in skill_tree:  res = \u0026#39;\u0026#39;  for z in i:  if z in skill:  res += z  if res == skill[0:len(res)]:  ans += 1  return ans  min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.02ms, 10.2MB\n  주식가격 분류 : 스택/큐\n문제 링크\ndef solution(prices):  ans = []  for i in range(len(prices)):  val = prices[i]  for j in range(i+1, len(prices)):  if prices[j] \u0026lt; val:  break  ans.append(j-i)  return ans 2021-02-10\n정확성 테스트\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 1.11ms, 10.3MB\n 효율성 테스트\n min TaseCase : 52.83ms, 17.4MB\nmax TaseCase : 105.50ms, 20MB\n  삼각 달팽이 분류 : 월간 코드 챌린지 시즌1\n문제 링크\ndef solution(n):  m, n = (n**2 + n) // 2, 2  ans = [0 for _ in range(m)]  pos, val, cnt = 0, 0, 1  direct = True  for i in range(1, m+1):  if direct:  if pos + val \u0026lt; m: # 증가  pos += val  val += 1  else: # 초과  pos += 1  if pos == m-1:  m = pos - val  direct = False  else:  if n \u0026lt;= pos - val: # 감소  pos -= val  val -= 1  else: # 미만  n += 2 + cnt * 4  cnt += 1  pos += val  val += 1  direct = True  ans[pos] = i  return ans 2021-02-11\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 92.56ms, 56.9MB\n  문자열 압축 분류 : 2020 KAKAO BLIND RECRUITMENT\n문제 링크\n 문자열 길이별로 분할  [s[n:n+i] for n in range(0, len(s), i)]    def solution(s):  ans = len(s)  for i in range(1, ans//2 + 1):  t_lst = [s[n:n+i] for n in range(0, len(s), i)]  fix, tmp = \u0026#39;\u0026#39;, t_lst[0]  cnt = 0  for txt in t_lst[1:]:  cnt += 1  if txt != tmp:  fix = fix + str(cnt) + tmp if 1 \u0026lt; cnt else fix + tmp  tmp, cnt = txt, 0  else:  fix = fix + str(cnt+1) + tmp if 0 \u0026lt; cnt else fix + tmp  x = len(fix)  ans = x if x \u0026lt; ans else ans  return ans 2021-02-12\n min TaseCase : 0.00ms, 10.3MB\nmax TaseCase : 3.03ms, 10.2MB\n  메뉴 리뉴얼 분류 : 2021 KAKAO BLIND RECRUITMENT\n문제 링크\n방법1  orders 리스트를 course 갯수별 조합생성 조합내 중복제거한 리스트로 조합리스트 내 요소 카운트 카운트값이 가장 높은 조합 목록을 반환  from itertools import combinations  def solution(orders, course):  ans = []  for n in course:  tot_lst = []  for order in orders:  tot_lst.extend(list(combinations(sorted(order), n)))  tot_lst.sort()  tot_set = set(tot_lst)  m = 0  tmp_lst = []  for val in tot_set:  cnt = tot_lst.count(val)  if 1 \u0026lt; cnt and m \u0026lt; cnt:  m = cnt  tmp_lst = [\u0026#39;\u0026#39;.join(val)]  elif m == cnt:  tmp_lst.append(\u0026#39;\u0026#39;.join(val))  ans.extend(tmp_lst)  return sorted(ans) 2021-02-20\n min TaseCase : 0.05ms, 10.2MB\nmax TaseCase : 124.96ms, 10.6MB\n 방법2  collections.Counter()  컨테이너에 동일한 값이 몇개인지를 dictionary로 반환하는 객체 요소의 갯수가 내림차순으로 출력   collections.Counter().most_common(n)  입력된 값의 요소들 중 빈도수(frequency)가 높은 순으로 상위 n개를 리스트 안의 tuple로 반환    from itertools import combinations from collections import Counter  def solution(orders, course):  ans = []  for n in course:  tot_lst = []  for order in orders:  tot_lst.extend(combinations(sorted(order), n))   order_sorted = Counter(tot_lst).most_common()  cnt_max = order_sorted[0][1]  for arr, cnt in order_sorted:  if 1 \u0026lt; cnt and cnt == cnt_max:  ans += [\u0026#39;\u0026#39;.join(arr)]  else:  break  return sorted(ans)  min TaseCase : 0.07ms, 10.1MB\nmax TaseCase : 2.11ms, 10.4MB\n  더 맵게 분류 : 힙(Heap)\n문제 링크\n추가 Test Case\n   scoville K return     [0, 0] 1 -1    방법1 heapq : 이진 트리기반의 최소 힙 자료구조로 데이터를 정렬되게 저장하는 내장 모듈\n heapq.heapify(heap)  리스트를 힙으로 변환   heapq.heappush(heap, item)  heap 리스트에 item 원소추가 이진 트리에 원소를 추가하므로 O(logN)의 시간 복잡도를 가짐   heapq.heappop(heap)`  heap_lst 최소값을 반환하고 해당 리스트에서 삭제함 이진 트리에서 원소를 삭제하므로 O(logN)의 시간 복잡도를 가짐   힙 삭제없이 최소값 얻기  heap[0] : list 자료형 인덱스 접근방식으로 삭제없이 값 획득 가능 두번째 최소값은 heappop()함수로 첫번쨰 최소값을 삭제한뒤 heap[0] 접근하여 두번째 최소값을 얻을 수 있음   heapq.heappushpop(heap, item)  힙에 item을 푸시한 다음, heap에서 가장 작은 항목 팝하고 반환    import heapq  def solution(scoville, K):  ans, size = 0, len(scoville)  heapq.heapify(scoville)  n = heapq.heappop(scoville)  while 1 \u0026lt; size:  m = heapq.heappop(scoville)  n = heapq.heappushpop(scoville, n + m * 2)  ans, size = ans + 1, size - 1  if K \u0026lt;= n:  return ans  return -1 2021-02-20\n정확성 테스트\n min TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 1.02ms, 10.2MB\n 효율성 테스트\n min TaseCase : 139.60ms, 15MB\nmax TaseCase : 2098.58ms, 51.9MB\n 방법2 deque : 스택과 큐를 일반화 한 것\n append(x)  오른쪽에 x 추가   appendleft(x)  왼쪽에 x 추가   pop()  오른쪽에서 요소를 제거하고 반환   popleft()  왼쪽에서 요소를 제거하고 반환     순위 검색 분류 : 2021 KAKAO BLIND RECRUITMENT\n문제 링크\n방법1 풀이방법 : 재귀함수, 이진탐색 사용\ndef binary_search(data: list, target: int):  s_idx = 0  e_idx = len(data)-1  mid = 0  if data:  if data[-1] \u0026lt; target:  mid = len(data)  elif data[0] \u0026lt; target:  while s_idx \u0026lt;= e_idx:  mid = (s_idx+e_idx)//2   if target \u0026lt; data[mid]:  e_idx = mid  elif data[mid] \u0026lt; target:  if e_idx - s_idx == 1:  mid = e_idx  break  elif e_idx == s_idx:  mid = e_idx + 1  break  else:  s_idx = mid  else:  e_idx -= 1  return mid  def dict_count(q_val: list, i_val: list):  cnt = 0  key = q_val[0]  if key == \u0026#39;-\u0026#39;:  for k in i_val:  cnt += dict_count(q_val=q_val[1:], i_val=i_val[k])  elif 1 \u0026lt; len(q_val):  cnt = dict_count(q_val=q_val[1:], i_val=i_val[key])  elif i_val:  cnt = len(i_val) - binary_search(data=i_val, target=key)   return cnt  def solution(info, query):  answer = []   soul_food = {\u0026#39;chicken\u0026#39;: [], \u0026#39;pizza\u0026#39;: []}  career = {\u0026#39;junior\u0026#39;: copy.deepcopy(soul_food), \u0026#39;senior\u0026#39;: copy.deepcopy(soul_food)}  job_group = {\u0026#39;backend\u0026#39;: copy.deepcopy(career), \u0026#39;frontend\u0026#39;: copy.deepcopy(career)}  i_info = {\u0026#39;cpp\u0026#39;: copy.deepcopy(job_group), \u0026#39;java\u0026#39;: copy.deepcopy(job_group), \u0026#39;python\u0026#39;: copy.deepcopy(job_group)}   for val in info:  val = val.split(\u0026#39; \u0026#39;)  data = i_info[val[0]][val[1]][val[2]][val[3]]  t_val = int(val[4])  data.insert(binary_search(data=data, target=t_val), t_val)   for val in query:  val = val.split(\u0026#39; and \u0026#39;)  val[-1], score = val[-1].split(\u0026#39; \u0026#39;)  val.append(int(score))  answer.append(dict_count(q_val=val, i_val=i_info))   return answer 2021-05-18\n정확성 테스트\n min TaseCase : 0.24ms, 10.4MB\nmax TaseCase : 10.82ms, 10.7MB\n 효율성 테스트\n min TaseCase : 1146.27ms, 35.9MB\nmax TaseCase : 5534.78ms, 36.2MB\n 방법2 풀이방법 : Bit field 연산, 이진탐색 알고리즘 수정\nfield = {  \u0026#34;cpp\u0026#34;: 1, \u0026#34;java\u0026#34;: 2, \u0026#34;python\u0026#34;: 4,  \u0026#34;backend\u0026#34;: 1, \u0026#34;frontend\u0026#34;: 2,  \u0026#34;junior\u0026#34;: 1, \u0026#34;senior\u0026#34;: 2,  \u0026#34;chicken\u0026#34;: 1, \u0026#34;pizza\u0026#34;: 2,  \u0026#34;-\u0026#34;: 7, }  mask = {  \u0026#34;cpp\u0026#34;: 6, \u0026#34;java\u0026#34;: 5, \u0026#34;python\u0026#34;: 3,  \u0026#34;backend\u0026#34;: 6, \u0026#34;frontend\u0026#34;: 5,  \u0026#34;junior\u0026#34;: 6, \u0026#34;senior\u0026#34;: 5,  \u0026#34;chicken\u0026#34;: 6, \u0026#34;pizza\u0026#34;: 5,  \u0026#34;-\u0026#34;: 0, }  def binary_search(data, target):  low = 0  high = len(data)   while low \u0026lt; high:  mid = (high+low)//2  if target \u0026lt;= data[mid]:  high = mid  else:  low = mid + 1  return low  def solution(info, query):  answer = []   i_info = {}  for v in info:  v = v.split(\u0026#39; \u0026#39;)  i_bit = (field[v[0]] \u0026lt;\u0026lt; 9) + (field[v[1]] \u0026lt;\u0026lt; 6) + (field[v[2]] \u0026lt;\u0026lt; 3) + field[v[3]]   if i_bit in i_info:  data = i_info[i_bit]  else:  data = i_info[i_bit] = []   score = int(v[4])  data.insert(binary_search(data=data, target=score), score)   for v in query:  v = v.split(\u0026#39; and \u0026#39;)  v[-1], score = v[-1].split(\u0026#39; \u0026#39;)  score = int(score)  q_bit = (mask[v[0]] \u0026lt;\u0026lt; 9) + (mask[v[1]] \u0026lt;\u0026lt; 6) + (mask[v[2]] \u0026lt;\u0026lt; 3) + mask[v[3]]   cnt = 0  for i_bit in i_info:  if not (q_bit \u0026amp; i_bit):  i_data = i_info[i_bit]  cnt += len(i_data) - binary_search(data=i_data, target=score)  answer.append(cnt)   return answer 2021-05-18\n정확성 테스트\n min TaseCase : 0.11ms, 10.4MB\nmax TaseCase : 9.42ms, 11MB\n 효율성 테스트\n min TaseCase : 887.34ms, 35.8MB\nmax TaseCase : 3955.15ms, 35.9MB\n 방법3 풀이방법 : 이진탐색 부분을 내장함수 사용\n 배열 이진 분할 알고리즘 bisect 라이브러리 insort(a, x) : a에 x를 정렬된 순서로 추가 bisect_left(a, x) : 정렬된 순서를 유지하면서 a에 x를 추가할 위치 반환  from bisect import insort, bisect_left  field = {  \u0026#34;cpp\u0026#34;: 1, \u0026#34;java\u0026#34;: 2, \u0026#34;python\u0026#34;: 4,  \u0026#34;backend\u0026#34;: 1, \u0026#34;frontend\u0026#34;: 2,  \u0026#34;junior\u0026#34;: 1, \u0026#34;senior\u0026#34;: 2,  \u0026#34;chicken\u0026#34;: 1, \u0026#34;pizza\u0026#34;: 2,  \u0026#34;-\u0026#34;: 7, }  mask = {  \u0026#34;cpp\u0026#34;: 6, \u0026#34;java\u0026#34;: 5, \u0026#34;python\u0026#34;: 3,  \u0026#34;backend\u0026#34;: 6, \u0026#34;frontend\u0026#34;: 5,  \u0026#34;junior\u0026#34;: 6, \u0026#34;senior\u0026#34;: 5,  \u0026#34;chicken\u0026#34;: 6, \u0026#34;pizza\u0026#34;: 5,  \u0026#34;-\u0026#34;: 0, }  def solution(info, query):  answer = []   i_info = {}  for v in info:  v = v.split(\u0026#39; \u0026#39;)  i_bit = (field[v[0]] \u0026lt;\u0026lt; 9) + (field[v[1]] \u0026lt;\u0026lt; 6) + (field[v[2]] \u0026lt;\u0026lt; 3) + field[v[3]]   if i_bit in i_info:  data = i_info[i_bit]  else:  data = i_info[i_bit] = []   score = int(v[4])  insort(data, score)   for v in query:  v = v.split(\u0026#39; and \u0026#39;)  v[-1], score = v[-1].split(\u0026#39; \u0026#39;)  score = int(score)  q_bit = (mask[v[0]] \u0026lt;\u0026lt; 9) + (mask[v[1]] \u0026lt;\u0026lt; 6) + (mask[v[2]] \u0026lt;\u0026lt; 3) + mask[v[3]]   cnt = 0  for i_bit in i_info:  if not (q_bit \u0026amp; i_bit):  i_data = i_info[i_bit]  cnt += len(i_data) - bisect_left(i_data, score)  answer.append(cnt)   return answer 2021-05-18\n정확성 테스트\n min TaseCase : 0.09ms, 10.4MB\nmax TaseCase : 5.63ms, 10.7MB\n 효율성 테스트\n min TaseCase : 446.87ms, 35.7MB\nmax TaseCase : 1198.31ms, 35.9MB\n  행렬 테두리 회전하기 분류 : 2021 Dev-Matching: 웹 백엔드 개발자(상반기)\n문제 링크\n방법1  테두리에 해당되는 행과 열의 데이터를 모아 큐를 만든다.  예시: [1, 2, 3, 4, 5]   해당 큐에서 최소값을 구하여 answer에 추가한다. 마지막 값을 0번 인덱스로 이동시킨다.  예시: [5, 1, 2, 3, 4]   테두리 위치와 추출한 큐 인덱스가 동일한곳에 다시 대입시킨다.  테두리값이 한칸씩 이동된다. 예시: [1, 2, 3, 4, 5] -\u0026gt; [5, 1, 2, 3, 4]    def solution(rows, columns, queries):  answer = []   data = []  cnt = 0  for y in range(rows):  temp = []  for x in range(columns):  cnt += 1  temp.append(cnt)  data.append(temp)   for query in queries:  pos_temp = []  for x in range(query[1]-1, query[3]-1): pos_temp.append(data[query[0]-1][x])  for y in range(query[0]-1, query[2]-1): pos_temp.append(data[y][query[3]-1])  for x in range(query[3]-1, query[1]-1, -1): pos_temp.append(data[query[2]-1][x])  for y in range(query[2]-1, query[0]-1, -1): pos_temp.append(data[y][query[1]-1])   answer.append(min(pos_temp))   value = pos_temp.pop(-1)  pos_temp.insert(0, value)   for x in range(query[1]-1, query[3]-1): data[query[0]-1][x] = pos_temp.pop(0)  for y in range(query[0]-1, query[2]-1): data[y][query[3]-1] = pos_temp.pop(0)  for x in range(query[3]-1, query[1]-1, -1): data[query[2]-1][x] = pos_temp.pop(0)  for y in range(query[2]-1, query[0]-1, -1): data[y][query[1]-1] = pos_temp.pop(0)   return answer 2021-12-17\n min TaseCase : 0.03ms, 10.2MB\nmax TaseCase : 245.02ms, 11.7MB\n 방법2  방법1 for문 대신 list연산 가능한 부분은 list연산으로 대체한다.  def solution(rows, columns, queries):  answer = []   data = []  cnt = 0  for y in range(rows):  temp = []  for x in range(columns):  cnt += 1  temp.append(cnt)  data.append(temp)   for y1, x1, y2, x2 in queries:  pos_temp = []   pos_temp.extend(data[y1-1][x1-1:x2-1])  for y in range(y1-1, y2-1): pos_temp.append(data[y][x2-1])  pos_temp.extend(data[y2-1][x2-1:x1-1:-1])  for y in range(y2-1, y1-1, -1): pos_temp.append(data[y][x1-1])   answer.append(min(pos_temp))   value = pos_temp.pop(-1)  pos_temp.insert(0, value)   data[y1-1][x1-1:x2-1] = pos_temp[:x2-x1]  del pos_temp[:x2-x1]  for y in range(y1-1, y2-1): data[y][x2-1] = pos_temp.pop(0)  data[y2-1][x2-1:x1-1:-1] = pos_temp[:x2-x1]  del pos_temp[:x2-x1]  for y in range(y2-1, y1-1, -1): data[y][x1-1] = pos_temp.pop(0)   return answer 2021-12-17\n min TaseCase : 0.03ms, 10.3MB\nmax TaseCase : 134.78ms, 12MB\n  거리두기 확인하기 분류 : 2021 카카오 채용연계형 인턴십\n문제 링크\n 맨해튼 거리: 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, 맨해튼 거리는 |r1 - r2| + |c1 - c2| 이다.  추가 테스트 케이스\nplaces = [  [  \u0026#34;OOOXP\u0026#34;,  \u0026#34;OOOPO\u0026#34;,  \u0026#34;OOOOO\u0026#34;,  \u0026#34;OOOOO\u0026#34;,  \u0026#34;OOOOO\u0026#34;,  ],  [  \u0026#34;OOOOP\u0026#34;,  \u0026#34;OOOPX\u0026#34;,  \u0026#34;OOOOO\u0026#34;,  \u0026#34;OOOOO\u0026#34;,  \u0026#34;OOOOO\u0026#34;,  ] ]  result = [0, 0] 풀이방법 : 맨해튼 거리를 활용하여 대각선위치를 검증한다.\ndef find_point(place):  for h1 in range(5):  for w1 in range(5):  point = place[h1][w1]  if point != \u0026#39;P\u0026#39;:  continue   min_w = w1-2 if 0 \u0026lt; w1-2 else 0  max_w = w1+2 if w1+2 \u0026lt; 5 else 4  max_h = h1+2 if h1+2 \u0026lt; 5 else 4   for w2 in range(w1+1,max_w+1):  point2 = place[h1][w2]  if point2 == \u0026#39;X\u0026#39;:  break  elif point2 == \u0026#39;P\u0026#39;:  return 0  elif point2 == \u0026#39;O\u0026#39;:  h2 = h1+1 if h1+1 \u0026lt; max_h else max_h  distance = abs(h1-h2)+abs(w1-w2)  if (place[h2][w2] == \u0026#39;P\u0026#39;) and (distance \u0026lt;=2):  return 0   for w2 in range(w1-1,min_w-1,-1):  point2 = place[h1][w2]  if point2 == \u0026#39;X\u0026#39;:  break  elif point2 == \u0026#39;P\u0026#39;:  return 0  elif point2 == \u0026#39;O\u0026#39;:  h2 = h1+1 if h1+1 \u0026lt; max_h else max_h  distance = abs(h1-(h2))+abs(w1-w2)  if (place[h2][w2] == \u0026#39;P\u0026#39;) and (distance \u0026lt;=2):  return 0   for h2 in range(h1+1,max_h+1):  point2 = place[h2][w1]  if point2 == \u0026#39;X\u0026#39;:  break  elif point2 == \u0026#39;P\u0026#39;:  return 0  elif point2 == \u0026#39;O\u0026#39;:  w2 = w1-1 if 0 \u0026lt; w1-1 else min_w  distance = abs(h1-h2)+abs(w1-w2)  if (place[h2][w2] == \u0026#39;P\u0026#39;) and (distance \u0026lt;=2):  return 0  w2 = w1+1 if w1+1 \u0026lt; max_w else max_w  distance = abs(h1-h2)+abs(w1-w2)  if (place[h2][w2] == \u0026#39;P\u0026#39;) and (distance \u0026lt;=2):  return 0  return 1  def solution(places):  answer = []   for place in places:  answer.append(find_point(place))   return answer 2022-03-27\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.05ms, 10.3MB\n  구명보트 분류 : 탐욕법(Greedy)\n문제 링크\n people list를 작은 몸무게 순으로 정렬한다. 가장 작은 몸무게와 가장 큰 몸무게만 사용하므로 deque 자료형을 사용한다. 가장 작은 값과 큰 값을 합쳤을때 limit 이내이면 같이 탈출 아니면 가장 큰값만 탈출시킨다.  from collections import deque  def solution(people, limit):  answer = 0   # 몸무게 순으로 정렬  people.sort()  # 데크 자료형으로 변환  deq = deque(people)   light_weight, heavy_weight = 0, 0  while deq or light_weight or heavy_weight:  # 가장 작은 몸무게와 가장 큰 몸무게 선별  if deq and (not light_weight):  light_weight = deq.popleft()  if deq and (not heavy_weight):  heavy_weight = deq.pop()   if (light_weight + heavy_weight) \u0026lt;= limit:  light_weight = 0  heavy_weight = 0  answer += 1   return answer 2022-04-02\n 정확성\nmin TaseCase : 0.03ms, 10.4MB\nmax TaseCase : 1.24ms, 10.2MB\n효율성\nmin TaseCase : 9.15ms, 10.7MB\nmax TaseCase : 9.82ms, 10.7MB\n  전화번호 목록 분류 : 해시\n문제 링크\n 접두어가 될수 있는 짧은 번호가 뒤에 올수 있으므로 정렬하여 앞에 위치하도록 한다. 전화번호를 앞에서부터 저장된 번호와 일치하는지 확인한다. 일치한 번호가 없다면 book(key-value 자료형) 변수에 저장한다.  def solution(phone_book):  phone_book.sort()  book = {}  for phone in phone_book:  for i in range(len(phone)):  if phone[:i+1] in book:  return False  else:  book[phone] = True  return True 2022-04-09\n풀이시간 : 18분\n 정확성\nmin TaseCase : 0.01ms, 9.98MB\nmax TaseCase : 9.59ms, 10.4MB\n효율성\nmin TaseCase : 2.89ms, 10.8MB\nmax TaseCase : 622.27ms, 46.8MB\n  ","date":"December 22, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/algorithm/programmers/2020-12-22-algorithm-programmers-python-level2/","summary":"프린터 분류 : 스택/큐\n문제 링크\n 우선순위 priorities 리스트의 최댓값을 num_max변수에 대입 cursor변수에 priorities[0]값 추출하여 대입 cursor 값이 최댓값 일때 cnt 1증가 이때 location값이 0이면 break cursor 값이 최댓값 아닐때 리스트 맨뒤에 cursor 값 추가 이때 location값이 0이면 location변수에 priorities길이값 대입 location 1 감소 위의 순서를 location 0 이상일때 while문 반복실행  def solution(priorities, location):  cnt = 1  while True:  num_max = max(priorities)  cursor = priorities.","tags":["algorithm","programmers","python"],"title":"Programmers Python (level 2)"},{"categories":["Algorithm","Programmers"],"contents":" 모의고사 분류 : 완전탐색\n문제 링크\n 입력받은 answers 리스트와 수포자들의 답 리스트와 비교하여 같다면 answer_cnt변수에 정답 개수 추가 answer_cnt 리스트의 최댓값과 각 answer_cnt 원소와 비교하여 같다면 index+1 값을 answer리스트에 추가 최대 정답자 answer 리스트 return  def solution(answers):  answer = []   answer_cnt = [0, 0, 0]  answer_list = [  [1, 2, 3, 4, 5],  [2, 1, 2, 3, 2, 4, 2, 5],  [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]  ]   # 정답 매칭  for i in range(len(answers)):  ans = answers[i]  if ans == answer_list[0][i%5]: answer_cnt[0] += 1  if ans == answer_list[1][i%8]: answer_cnt[1] += 1  if ans == answer_list[2][i%10]: answer_cnt[2] += 1   # 최다 정답자 추출  max_cnt = max(answer_cnt)  for i, cnt in enumerate(answer_cnt):  if max_cnt == cnt:  answer.append(i+1)   return answer 2020-12-15\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 3.12ms, 10.3MB\n  K번째수 분류 : 정렬\n문제 링크\n 입력받은 commands 2차원 리스트에서 command 1차원 리스트 추출 array리스트 command[0]-1번째부터 command[1]번째까지 추출하여 array_ext변수에 저장 저장한 array_ext리스트 정렬 정렬한 array_ext리스트의 command[2]-1번째 원소를 answer리스트에 추가 추출한 원소 리스트 answer return  def solution(array, commands):  answer = []   for i, command in enumerate(commands):  array_ext = array[command[0]-1:command[1]]  array_ext.sort()  answer.append(array_ext[command[2]-1])   return answer 2020-12-15\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.01ms, 10.2MB\n  체육복 분류 - 탐욕법(Greedy)\n문제 링크\n reserve 리스트에서 lost 리스트와 같은 원소를 삭제  먼저 여분의 체육복을 가진 사람이 도난당한 경우를 고려   set함수로 정렬이 되지 않았으므로 sort() 정렬 lost[l_len] 원소 값 -1, +1 값이 reserve[r_len] 리스트에 있으면 두 원소를 삭제하고 l_len, r_len 값 -1  도난당한 사람에 맞는 여유분 체육복 있음   lost[l_len] 원소 값이 reserve[r_len]보다 클 경우 l_len값 -1  도난당한 사람에 맞는 여유분 체육복 없음   lost[l_len] 원소 값이 reserve[r_len]보다 작을 경우 r_len값 -1  여유분 체육복에 맞는 도난당한 사람이 없음   최종적으로 lost리스트의 길이 값을 반환  체육복을 빌리지 못한 사람    def solution(n, lost, reserve):  answer = 0   lost_2 = list(set(lost)-set(reserve))  reserve_2 = list(set(reserve)-set(lost))  lost, reserve = lost_2, reserve_2   l_len, r_len = len(lost) - 1, len(reserve) - 1  lost.sort()  reserve.sort()   while 0 \u0026lt;= l_len and 0 \u0026lt;= r_len:  if reserve[r_len] - 1 \u0026lt;= lost[l_len] \u0026lt;= reserve[r_len] + 1:  del lost[l_len], reserve[r_len]  l_len -= 1  r_len -= 1  elif lost[l_len] \u0026gt; reserve[r_len] + 1:  l_len -= 1  elif lost[l_len] \u0026lt; reserve[r_len] - 1:  r_len -= 1   answer = n - len(lost)   return answer 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.02ms, 10.3MB\n  2016년 분류 : 연습문제\n문제 링크\n 요일 day_list 와, 윤년에 해당되는 달의 일수 month_dict 선언 2016년 1월 1일 금요일에 해당하는 초기 days값 선언 입력받은 1월부터 a-1달까지 일수를 days변수에 덧셈하고 b일수를 days변수에 덧셈한다. days변수를 7로 나머지 연산한 값으로 day_list리스트 해당되는 요일 찾아서 반환  def solution(a, b):  day_list = [\u0026#39;SUN\u0026#39;, \u0026#39;MON\u0026#39;, \u0026#39;TUE\u0026#39;, \u0026#39;WED\u0026#39;, \u0026#39;THU\u0026#39;, \u0026#39;FRI\u0026#39;, \u0026#39;SAT\u0026#39;]  month_dict = {1:31, 2:29, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}  days = 4 # 2016년 1월 1일 금요일 시작  for month in range(1, a):  days += month_dict[month]  days += b  return day_list[days%7] 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.01ms, 10.3MB\n  가운데 글자 가져오기 분류 : 연습문제\n문제 링크\n 문자열 s 길이값 나누기 연산값을 index변수에 저장 s 길이값이 나머지 연산으로 홀수이면 s[index] 반환 s 길이값이 나머지 연산으로 짝수이면 s[index-1:index+1] 반환  def solution(s):  index = len(s)//2  return s[index] if (len(s)%2 == 1) else s[index-1:index+1] 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.MB\nmax TaseCase : 0.00ms, 10.3MB\n  나누어 떨어지는 숫자 배열 분류 : 연습문제\n문제 링크\n방법1  arr 리스트에 원소를 divisor나머지 연산하여 값이 없을 때 answer리스트에 추가  조건문에 == 사용할 경우 3.44ms 조건문에 not 사용할 경우 2.64ms   answer리스트에 값이 있으면 정렬하여 반환하고 없으면 [-1] 반환  def solution(arr, divisor):  answer = []   for e in arr:  if not e%divisor:  answer.append(e)   return sorted(answer) if answer else [-1] 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 2.64ms, 13.3MB\n 방법2 def solution(arr, divisor):  answer = [e for e in arr if not e % divisor]  return sorted(answer) if answer else [-1] 2021-02-02\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 2.92ms, 13.4MB\n  두 정수 사이의 합 분류 : 연습문제\n문제 링크\n 입력값 a, b 중 작은 값을 num_min변수에 큰 값을 num_max변수에 대입 값이 같으면 a 반환 가우스의 덧셈 공식을 이용하여 각 num_min-1, num_max 변수까지의 합을 구한다.  자연수 1부터 N까지의 합 = N(N+1)/2   (큰 값 - 작은 값) 값 반환  def solution(a, b):  if a \u0026lt; b:  num_min, num_max = a, b  elif b \u0026lt; a:  num_min, num_max = b, a  else:  return a  return (num_max*(num_max+1) // 2) - (num_min*(num_min-1) // 2) 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.00ms, 10.3MB\n (abs(a-b)+1)*(a+b)//2 위의 공식을 사용하면 한줄로 코드 작성 가능하다.\n 문자열 내 마음대로 정렬하기 분류 : 연습문제\n문제 링크\n strings문자열 리스트 정렬 후 n번째 글자를 기준으로 다시 정렬하여 반환  def solution(strings, n):  return sorted(sorted(strings), key=lambda x:(x[n])) 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.04ms, 10.2MB\n  문자열 내림차순으로 배치하기 분류 : 연습문제\n문제 링크\n 문자열을 역순으로 정렬한 다음 sorted함수로 인해 list 자료형으로 수정됨 list형 자료형을 하나의 문자열로 바꾸기 위해 join 함수 이용  def solution(s):  return \u0026#39;\u0026#39;.join(sorted(s, reverse=True)) 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.07ms, 10.1MB\n  문자열 다루기 기본 분류 : 연습문제\n문제 링크\n 조건문으로 문자열의 길이가 4 or 6 이면서 문자열이 int타입으로 변환이 가능한지 확인하는 isdecimal()함수를 이용하여 반환  def solution(s):  return (len(s) == 4 or len(s) == 6) and (s.isdecimal()) 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.01ms, 10.4MB\n  서울에서 김서방 찾기 분류 : 연습문제\n문제 링크\n index함수로 찾는 문자열의 위치값 반환  def solution(seoul):  return f\u0026#34;김서방은 {seoul.index(\u0026#39;Kim\u0026#39;)}에 있다\u0026#34; 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.01ms, 10.2MB\n  수박수박수박수박수박수? 분류 : 연습문제\n문제 링크\n n 나누기 2 만큼의 수박 문자열 선언 n값이 홀수이면 수문자 추가하여 answer 반환 n값이 짝수이면 answer 반환  def solution(n):  answer = \u0026#39;수박\u0026#39; * (n//2)  return answer+\u0026#39;수\u0026#39; if n%2 == 1 else answer 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.01ms, 10.3MB\n  문자열을 정수로 바꾸기 분류 : 연습문제\n문제 링크\n int형으로 변환하여 반환  def solution(s):  return int(s) 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.3MB\nmax TaseCase : 0.02ms, 10.4MB\n  내적 분류 : 월간 코드 챌린지 시즌1\n문제 링크\n a리스트의 길이만큼 for 문 반복 a, b리스트의 같은 위치끼리 곱셈한 값을 answer변수에 덧셈 반복문 종료 후 answer 반환  def solution(a, b):  answer = 0  for i in range(len(a)):  answer += a[i]*b[i]  return answer 2020-12-18\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.16ms, 10.2MB\n  시저 암호 분류 : 연습문제\n문제 링크\n 문자열 길이만큼 for문 반복 실행  일 경우 answer변수에 추가하고 다음 반복문 실행 str_ascii변수에 s[i]문자 아스키코드값 대입 str_ascii값이 90이하(대문자)일 경우 large변수에 True 대입 str_ascii값에 n만큼 덧셈 str_ascii값이 90(대문자 범위)을 초과면서 large변수가 True일 경우 str_ascii변수에 -26연산 str_ascii값이 122(소문자 범위)를 초과하면 str_ascii변수에 -26연산 연산된 결과를 문자열로 변환하여 answer변수에 추가  def solution(s, n):  answer = \u0026#39;\u0026#39;  for i in range(len(s)):  if s[i] == \u0026#39; \u0026#39;:  answer += \u0026#39; \u0026#39;  else:  str_ascii = ord(s[i])  large = True if str_ascii \u0026lt;= 90 else False  str_ascii += n  if (90 \u0026lt; str_ascii) and (large):  str_ascii -= 26  elif 122 \u0026lt; str_ascii:  str_ascii -= 26  answer += chr(str_ascii)  return answer 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 1.61ms, 10.2MB\n  약수의 합 분류 : 연습문제\n문제 링크\n i변수 초깃값 1 quot변수에 n/i몫을 대입 quot변수가 정수형 일 때 검증 시작 quot변수가 i보다 작을 경우 약수 집합의 중간지점을 지났기에 while 반복문 종료 quot변수가 i와 같지 않을 때 (quot + i) 값을 answer변수에 덧셈 quot변수가 i와 같을 때 i값을 answer변수에 덧셈 i변수에 1 덧셈 i값이 quot값보다 크면 while 반복문 종료  def solution(n):  answer = 0  i = 1  quot = n  while i \u0026lt;= quot:  quot = n/i  if int(quot) == quot:  if quot \u0026lt; i:  break  elif quot != i:  answer += quot  answer += i  i += 1  return answer 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.02ms, 10.2MB\n  이상한 문자 만들기 분류 : 연습문제\n문제 링크\n 문자열 길이만큼 for 반복문 실행 even변수 초깃값 True s[i]번째 문자가  이면  answer변수에  추가하고 even변수 True값으로 수정   s[i]번째 문자가  아니면서 even값이 True경우  answer변수에 s[i]대문자 추가하고 even변수 False값으로 수정   s[i]번째 문자가  아니면서 even값이 False경우  answer변수에 s[i]소문자 추가하고 even변수 True값으로 수정    def solution(s):  answer = \u0026#39;\u0026#39;  even = True  for i in range(len(s)):  if s[i] == \u0026#39; \u0026#39;:  answer += \u0026#39; \u0026#39;  even = True  elif even:  answer += s[i].upper()  even = False  else:  answer += s[i].lower()  even = True  return answer 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.04ms, 10.3MB\n  자릿수 더하기 분류 : 연습문제\n문제 링크\n n변수가 0 이상일 때 while 반복문 실행 n변수의 10 나머지 값을 answer변수에 덧셈 n변수에 n 나누기 10의 몫을 대입  def solution(n):  answer = 0  while 0 \u0026lt; n:  answer += n%10  n = n//10  return answer 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.00ms, 10.2MB\n  자연수 뒤집어 배열로 만들기 분류 : 연습문제\n문제 링크\n n값이 0 이상일 때 while 반복문 실행 n변수의 10 나머지 값을 answer리스트에 원소 추가 n변수에 n 나누기 10의 몫을 대입  def solution(n):  answer = []  while 0 \u0026lt; n:  answer.append(n%10)  n = n//10  return answer 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.01ms, 10.1MB\n  정수 내림차순으로 배치하기 분류 : 연습문제\n문제 링크\n 정수 n을 문자열 변환 후에 list로 내림차순 정렬한 값을 answer변수에 대입 answer리스트를 join으로 문자열 변환하고 int형 변환한 값을 반환  def solution(n):  answer = sorted(list(str(n)), reverse=True)  return int(\u0026#39;\u0026#39;.join(answer)) 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.1MB\nmax TaseCase : 0.03ms, 10.4MB\n  정수 제곱근 판별 분류 : 연습문제\n문제 링크\n 입력값 n 루트 값이 정수형이면 제곱근이므로 (n제곱근+1) 제곱 값 반환 n 제곱근이 없으면 -1 반환  def solution(n):  n = n**0.5  if int(n) == n:  return (n+1)**2  return -1 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.02ms, 10.3MB\n  제일 작은 수 제거하기 분류 : 연습문제\n문제 링크\n arr리스트의 최소값을 찾아 삭제 arr리스트의 값이 없으면 [-1] 반환 arr리스트의 값이 있으면 arr 반환  def solution(arr):  arr.remove(min(arr))  return arr if arr else [-1] 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.89ms, 16.7MB\n  짝수와 홀수 분류 : 연습문제\n문제 링크\n num 나머지 2 연산결과가 1일 경우 Odd 반환 그외의 경우 Even 반환  def solution(num):  return \u0026#34;Odd\u0026#34; if num%2==1 else \u0026#34;Even\u0026#34; 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.00ms, 10.3MB\n  최대공약수와 최소공배수 분류 : 연습문제\n문제 링크\n 각 입력값 n, m에 대해서 소인수를 구한다. 각 소인수의 집합에서 중복된 원소들의 곱이 최대공약수 n * m / 최대공약수값이 최대공배수  def solution(n, m):  answer = [1, 1]  dict1 = prime(n)  dict2 = prime(m)  # 최대공약수  for num in dict1:  if num in dict2:  answer[0] *= (num ** min(dict1[num], dict2[num]))  # 최소공배수  answer[1] = n * m / answer[0]  return answer  def prime(num):  num_dict = {}  i = 2  while i \u0026lt;= num:  if num%i == 0:  if i in num_dict:  num_dict[i] += 1  else:  num_dict[i] = 1  num //= i  else:  i += 1  return num_dict 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.04ms, 10.2MB\n 유클리드 호제법을 사용하면 간결하게 작성 가능하다.  콜라츠 추측 분류 : 연습문제\n문제 링크\n 500번 반복하여 조건만족하지 못하면 -1 반환 num값이 짝수면 num/2 연산을 홀수면 num*3+1연산 수행 num값이 1일경우 cnt 반환  def solution(num):  cnt = 0  while cnt \u0026lt; 500:  if num == 1:  return cnt  num = num/2 if num%2==0 else num*3+1  cnt += 1  return -1 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10MB\nmax TaseCase : 0.20ms, 10.2MB\n  평균 구하기 분류 : 연습문제\n문제 링크\n arr리스트 원소들의 합을 arr리스트 길이로 나눈값 반환  def solution(arr):  return sum(arr)/len(arr) 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.01ms, 10.3MB\n  하샤드 수 분류 : 연습문제\n문제 링크\n 각 자리수의 합으로 입력값 x를 나누었을때 0이 나오면 True 아니면 False 반환  def solution(x):  sum, n = 0, x  while 0 \u0026lt; n:  sum += n%10  n //= 10  return True if (x%sum==0) else False 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.00ms, 10.3MB\n  핸드폰 번호 가리기 분류 : 연습문제\n문제 링크\n 입력값 (phone_number길이-4)만큼 *문자를 추가하고 뒤에 phone_number 뒤에서 4번째부터 마지막까지의 문자열을 추가하여 반환  def solution(phone_number):  return (\u0026#39;*\u0026#39; * (len(phone_number)-4)) + phone_number[-4:] 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.00ms, 10.3MB\n  행렬의 덧셈 분류 : 연습문제\n문제 링크\n arr1리스트 길이만큼 2차원 answer 리스트 선언 이중 for 반복문을 사용하여 arr1[i][j] + arr2[i][j]연산값을 answer[i][j]리스트 원소에 저장  def solution(arr1, arr2):  answer = [[] for _ in range(len(arr1))]  for i in range(len(arr1)):  for j in range(len(arr1[i])):  answer[i].append(arr1[i][j] + arr2[i][j])  return answer 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 32.47ms, 22.9MB\n  x만큼 간격이 있는 n개의 숫자 분류 : 연습문제\n문제 링크\n i는 1부터 n까지 반복 실행 answer리스트에 x*i 원소를 추가하여 반환  def solution(x, n):  answer = []  for i in range(1, n+1):  answer.append(x*i)  return answer 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.15ms, 10.4MB\n  직사각형 별찍기 분류 : 연습문제\n문제 링크\n 입력값 n가로길이, m세로길이만큼 *출력  n, m = map(int, input().strip().split(\u0026#39; \u0026#39;)) print((\u0026#39;*\u0026#39; * n + \u0026#39;\\n\u0026#39;) * m) 2020-12-22\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 12.37ms, 7.54MB\nmax TaseCase : 15.18ms, 7.6MB\n  크레인 인형뽑기 게임 분류 :2019 카카오 개발자 겨울 인턴십\n문제 링크\ndef solution(board, moves):  answer = 0  queue = []   for i in moves:  i -= 1  for row in board:  if row[i]:  queue.append(row[i])  row[i] = 0  break  if (1 \u0026lt; len(queue)) and (queue[-2] == queue[-1]):  answer += 2  queue.pop()  queue.pop()   return answer 2021-01-26\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.3MB\nmax TaseCase : 1.02ms, 10.2MB\n  두 개 뽑아서 더하기 분류 : 월간 코드 챌린지 시즌1\n문제 링크\n방법1 def solution(numbers):  answer = []  for i, val1 in enumerate(numbers):  for val2 in numbers[i+1:]:  answer.append(val1+val2)  return sorted(set(answer)) 2021-01-27\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.58ms, 10.3MB\n 방법2  중복없는 조합 생성 함수 combinations 사용  from itertools import combinations  def solution(numbers):  answer = []  for val in set(combinations(numbers, 2)):  answer.append(sum(val))  return sorted(set(answer)) 2021-01-27\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 9.98MB\nmax TaseCase : 1.38ms, 10.3MB\n  완주하지 못한 선수 분류 : 해시\n문제 링크\n방법1  두개의 리스트 정렬 후 순서대로 비교하여 다른 문자열일때 해당 participant 리스트의 문자열 반환  def solution(participant, completion):  participant.sort()  completion.sort()  for i, v in enumerate(completion):  if v != participant[i]:  return participant[i]  return participant[-1] 2021-01-29\n 채점 결과\n합계: 100.0 / 100.0\n 정확성 테스트\n min TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 0.65ms, 10.3MB\n 효율성 테스트\n min TaseCase : 36.78ms, 18MB\nmax TaseCase : 86.29ms, 26.3MB\n 방법2 zip(*iterable) : 두개이상의 자료형을 묶어주는 함수\ndef solution(participant, completion):  participant.sort()  completion.sort()  for p, c in zip(participant, completion):  if p != c:  return p  return participant[-1] 2021-01-29\n 채점 결과\n합계: 100.0 / 100.0\n 정확성 테스트\n min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.63ms, 10.4MB\n 효율성 테스트\n min TaseCase : 36.12ms, 18.1MB\nmax TaseCase : 82.59ms, 26.3MB\n  신규 아이디 추천 분류 : 2021 KAKAO BLIND RECRUITMENT\n문제 링크\n 정규식 사용  방법1 import re p1 = re.compile(r\u0026#39;[^a-z0-9_.-]\u0026#39;) p2 = re.compile(r\u0026#39;[.]+\u0026#39;) p3 = re.compile(r\u0026#39;^[.]|[.]$\u0026#39;) def solution(new_id):  new_id = new_id.lower()  new_id = re.sub(p1, \u0026#39;\u0026#39;, new_id)  new_id = re.sub(p2, \u0026#39;.\u0026#39;, new_id)   while True:  new_id = re.sub(p3, \u0026#39;\u0026#39;, new_id)  if not new_id:  new_id = \u0026#39;a\u0026#39;  elif 15 \u0026lt; len(new_id):  new_id = new_id[:15]  elif len(new_id) \u0026lt; 3:  new_id += new_id[-1]  else:  break  return new_id 2021-01-30\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.2MB\nmax TaseCase : 0.21ms, 10.2MB\n 방법2 import re p1 = re.compile(r\u0026#39;[^a-z0-9_.-]\u0026#39;) p2 = re.compile(r\u0026#39;[.]+\u0026#39;) p3 = re.compile(r\u0026#39;^[.]|[.]$\u0026#39;) def solution(new_id):  new_id = new_id.lower()  new_id = re.sub(p1, \u0026#39;\u0026#39;, new_id)  new_id = re.sub(p2, \u0026#39;.\u0026#39;, new_id)  new_id = re.sub(p3, \u0026#39;\u0026#39;, new_id)  new_id = new_id if new_id else \u0026#39;a\u0026#39;  new_id = new_id[:15] if 15 \u0026lt; len(new_id) else new_id  new_id = re.sub(p3, \u0026#39;\u0026#39;, new_id)  new_id = new_id if 2 \u0026lt; len(new_id) else (new_id + new_id[-1] if 1 \u0026lt; len(new_id) else new_id*3)  return new_id 2021-01-30\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.1MB\nmax TaseCase : 0.23ms, 10.2MB\n  3진법 뒤집기 분류 : 월간 코드 챌린지 시즌1\n문제 링크\n방법1 def solution(n):  m = \u0026#39;\u0026#39;  while 2 \u0026lt; n:  n, m = n//3, m + str(n%3)  n, m = 0, int(m + str(n))  c = 0  while m:  n, m, c = n + (m%10 * 3**c), m//10, c+1  return n 2021-01-30\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.4MB\nmax TaseCase : 0.04ms, 10.4MB\n 방법2  int함수로 문자열을 10진법으로 변환할 수 있음  (문자열, 문자열의 x진법)    def solution(n):  m = \u0026#39;\u0026#39;  while 2 \u0026lt; n:  n, m = n//3, m + str(n%3)  return int(m + str(n), 3) 2021-01-30\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.3MB\nmax TaseCase : 0.04ms, 10.3MB\n  같은 숫자는 싫어 분류 : 연습문제\n문제 링크\ndef solution(arr):  answer = [arr[0]]  for n in arr[1:]:  if answer[-1] != n:  answer.append(n)  return answer 2021-01-30\n 채점 결과\n합계: 100.0 / 100.0\n 정확성 테스트\n min TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.02ms, 10.2MB\n 효율성 테스트\n min TaseCase : 60.33ms, 32.5MB\nmax TaseCase : 61.85ms, 32.4MB\n  문자열 내 p와 y의 개수 분류 : 연습문제\n문제 링크\ndef solution(s):  s = s.lower()  return True if s.count(\u0026#39;p\u0026#39;) == s.count(\u0026#39;y\u0026#39;) else False 2021-01-30\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.01ms, 10.3MB\n  소수 찾기 분류 : 연습문제\n문제 링크\n 에라토스테네스의 체 원리로 소수 리스트 작성 2를 제외한 다른 짝수는 변수 선언단계에서 False 처리  def solution(n):  p_lst = [False, False, True] + [True, False] * (n//2-1)  p_lst = p_lst if n%2 == 0 else p_lst + [True]  for i in range(3, int(n**0.5)+1, 2):  if not p_lst[i]:  continue  for j in range(i*2, n+1, i):  p_lst[j] = False  return p_lst.count(True) 2021-01-30\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.3MB\nmax TaseCase : 89.90ms, 24MB\n  키패드 누르기 분류 : 2020 카카오 인턴십\n문제 링크\ndef solution(numbers, hand):  answer = \u0026#39;\u0026#39;  l_pos, r_pos, n_pos = [0, 0], [0, 0], [0, 0]  for n in numbers:  if n == 1 or n == 4 or n == 7:  answer += \u0026#39;L\u0026#39;  l_pos = [3-n//3, 0]  elif n == 3 or n == 6 or n == 9:  answer += \u0026#39;R\u0026#39;  r_pos = [4-n//3, 0]  else:  n_pos = [3-n//3, 1] if n != 0 else [0, 1]   l_val = abs(n_pos[0] - l_pos[0]) + abs(n_pos[1] - l_pos[1])  r_val = abs(n_pos[0] - r_pos[0]) + abs(n_pos[1] - r_pos[1])   if l_val \u0026lt; r_val:  l_pos = n_pos  answer += \u0026#39;L\u0026#39;  elif r_val \u0026lt; l_val:  r_pos = n_pos  answer += \u0026#39;R\u0026#39;  elif hand == \u0026#39;left\u0026#39;:  l_pos = n_pos  answer += \u0026#39;L\u0026#39;  else:  r_pos = n_pos  answer += \u0026#39;R\u0026#39;  return answer 2021-01-31\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.81ms, 10.3MB\n  예산 분류 : Summer/Winter Coding(~2018)\n문제 링크\n방법1 def solution(d, budget):  d.sort()  cnt = 0  while d and 0 \u0026lt; budget:  d.pop(n)  budget -= n  if budget \u0026lt; 0:  break  cnt += 1  return cnt 2021-01-31\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.19ms, 10.2MB\n 방법2 def solution(d, budget):  d.sort()  cnt = 0  for n in d:  budget -= n  if budget \u0026lt; 0:  break  cnt += 1  return cnt 2021-02-02\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.00ms, 10.1MB\nmax TaseCase : 0.02ms, 10.2MB\n  1차 비밀지도 분류 : 2018 KAKAO BLIND RECRUITMENT\n문제 링크\n방법1 def solution(n, arr1, arr2):  answer = [[\u0026#39; \u0026#39; for _ in range(n)] for _ in range(n)]   for i in range(n):  val1 = str(bin(arr1[i]))[2:]  val2 = str(bin(arr2[i]))[2:]  while len(val1) \u0026lt; n:  val1 = \u0026#39;0\u0026#39; + val1  while len(val2) \u0026lt; n:  val2 = \u0026#39;0\u0026#39; + val2   for j in range(n):  if val1[j] == \u0026#39;1\u0026#39; or val2[j] == \u0026#39;1\u0026#39;:  answer[i][j] = \u0026#39;#\u0026#39;   return [\u0026#39;\u0026#39;.join(answer[i]) for i in range(n)] 2021-01-31\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.2MB\nmax TaseCase : 0.09ms, 10.2MB\n 방법2 zip : 동일한 개수로 이루어진 자료형을 묶어 주는 함수 bin : 비트연산 함수 rjust : 오른쪽 정렬 문자열에 공백을 두번째 인자로 패딩\n 첫번째 인자 길이가 문자열의 길이보다 작다면 원래의 문자열을 반환  def solution(n, arr1, arr2):  answer = []  for i,j in zip(arr1,arr2):  a12 = str(bin(i|j)[2:])  a12=a12.rjust(n,\u0026#39;0\u0026#39;)  a12=a12.replace(\u0026#39;1\u0026#39;,\u0026#39;#\u0026#39;)  a12=a12.replace(\u0026#39;0\u0026#39;,\u0026#39; \u0026#39;)  answer.append(a12)  return answer  min TaseCase : 0.01ms, 10.2MB\nmax TaseCase : 0.02ms, 10.2MB\n  1차 다트 게임 분류 : 2018 KAKAO BLIND RECRUITMENT\n문제 링크\n 정규식 사용하여 리스트 분할  import re p1 = re.compile(r\u0026#39;\\d{1,2}\u0026#39;) p2 = re.compile(r\u0026#39;[SDT][*|#]?\u0026#39;) def solution(dartResult):  answer = []  arr1, arr2 = re.findall(p1, dartResult), re.findall(p2, dartResult)  for i in range(len(arr1)):  squ = 2 if arr2[i][0] == \u0026#39;D\u0026#39; else 3 if arr2[i][0] == \u0026#39;T\u0026#39; else 1  mul = 2 if arr2[i][-1] == \u0026#39;*\u0026#39; else -1 if arr2[i][-1] == \u0026#39;#\u0026#39; else 1  answer.append((int(arr1[i]) ** squ) * mul)  if 1 \u0026lt; len(answer) and arr2[i][-1] == \u0026#39;*\u0026#39;:  answer[i-1] *= 2  return sum(answer) 2021-02-01\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.02ms, 10.3MB\nmax TaseCase : 0.05ms, 10.3MB\n  실패율 분류 : 2019 KAKAO BLIND RECRUITMENT\n문제 링크\ndef solution(N, stages):  a_lst, n_dict = [i for i in range(1, N+1)], {}  tot = len(stages)  for i in stages:  n_dict[i] = n_dict[i] + 1 if i in n_dict else 1   if N+1 in n_dict:  del n_dict[N+1]   for i, val in sorted(n_dict.items(), key=lambda x: x):  n_dict[i] = val / tot  tot -= val   b_lst = []  for n in sorted(n_dict.items(), key=lambda x: (x[1], -x[0]), reverse=True):  a_lst.remove(n[0])  b_lst.append(n[0])   return b_lst + a_lst 2021-02-02\n 채점 결과\n합계: 100.0 / 100.0\nmin TaseCase : 0.01ms, 10.1MB\nmax TaseCase : 27.56ms, 18.4MB\n  로또의 최고 순위와 최저 순위 분류 : 2021 Dev-Matching: 웹 백엔드 개발자(상반기)\n문제 링크\ndef solution(lottos, win_nums):  win_cnt, zero_cnt = 0, 0  for lotto in lottos:  if lotto in win_nums:  win_cnt += 1  elif not lotto:  zero_cnt += 1   max_rank = 7-(win_cnt+zero_cnt) if 1 \u0026lt; (win_cnt+zero_cnt) else 6  min_rank = 7-win_cnt if 1 \u0026lt; win_cnt else 6   answer = [max_rank, min_rank]  return answer 2021-12-20\n min TaseCase : 0.00ms, 10.2MB\nmax TaseCase : 0.01ms, 10.2MB\n ","date":"December 15, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/algorithm/programmers/2020-12-15-algorithm-programmers-python-level1/","summary":"모의고사 분류 : 완전탐색\n문제 링크\n 입력받은 answers 리스트와 수포자들의 답 리스트와 비교하여 같다면 answer_cnt변수에 정답 개수 추가 answer_cnt 리스트의 최댓값과 각 answer_cnt 원소와 비교하여 같다면 index+1 값을 answer리스트에 추가 최대 정답자 answer 리스트 return  def solution(answers):  answer = []   answer_cnt = [0, 0, 0]  answer_list = [  [1, 2, 3, 4, 5],  [2, 1, 2, 3, 2, 4, 2, 5],  [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]  ]   # 정답 매칭  for i in range(len(answers)):  ans = answers[i]  if ans == answer_list[0][i%5]: answer_cnt[0] += 1  if ans == answer_list[1][i%8]: answer_cnt[1] += 1  if ans == answer_list[2][i%10]: answer_cnt[2] += 1   # 최다 정답자 추출  max_cnt = max(answer_cnt)  for i, cnt in enumerate(answer_cnt):  if max_cnt == cnt:  answer.","tags":["algorithm","programmers","python"],"title":"Programmers Python (level 1)"},{"categories":["Algorithm","LeetCode"],"contents":" 1. Two Sum 문제 링크\n nums 리스트 속성값 중 두개의 값이 target 값과 동일할때 해당 속성 값의 index 반환  class Solution:  def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]:  for i, num in enumerate(nums):  for j, num2 in enumerate(nums[i+1:]):  if i != j+i+1:  if target == num+num2:  return [i, j+i+1] 2020-11-27\n Runtime: 40 ms, faster than 97.02% of Python3 online submissions for Two Sum. Memory Usage: 14.5 MB, less than 89.48% of Python3 online submisstions for Two Sum.   7. Reverse Integer 문제링크\n x값을 list형으로 변환하여 testCase 변수에 저장 testCase[0]값에 -부호가 있다면 sign 변수에 저장하고 testCase[0]에서 부호 삭제 for문을 사용하여 testCase 역순으로 result 변수에 저장 sign변수에 값이 있다면 sign + result값을 result에 저장 결과값이 int 32비트범위를 넘지 않으면 result을, 넘으면 0 반환  return : x 숫자를 역순으로 나열하여 반환    class Solution:  def reverse(self, x: int) -\u0026gt; int:  testCase = list(str(x))  sign = None  result = \u0026#39;\u0026#39;   if testCase[0] == \u0026#39;-\u0026#39;:  sign = testCase.pop(0)   testCaseLen = len(testCase)  for i in range(testCaseLen):  result += testCase[testCaseLen-1-i]   if sign:  result = sign + result   if -2147483648 \u0026lt;= int(result) \u0026lt;= 2147483647:  return int(result)  else:  return 0 2020-11-27\n Runtime: 28 ms, faster than 83.14% of Python3 online submissions for Reverse Integer. Memory Usage: 14.2 MB, less than 41.05% of Python3 online submisstions for Reverse Integer.   9. Palindrome Number 문제링크\n x값을 num변수에 대입 res변수에 나머지연산으로 num 1의 자리값을 더하고 num 나누기 연산하여 1의 자리 삭제 res변수를 10곱하여 자릿수 증가 위의 과정을 num변수가 0이 될때까지 반복 초기 x값과 res변수를 비교한 결과 반환  시간복잡성 : O(n) 공간복잡성 : O(1)\nclass Solution:  def isPalindrome(self, x: int) -\u0026gt; bool:  if x \u0026lt; 0: return False   num, res = x, 0  while num != 0:  res = res*10 + num%10  num //= 10  return x==res 2020-12-15\n Runtime: 52 ms, faster than 88.59% of Python3 online submissions for Palindrome Number. Memory Usage: 14.1 MB, less than 59.38% of Python3 online submissions for Palindrome Number.   14. Longest Common Prefix 문제링크\n 문자열 길이로 정렬된 strs 리스트에서 가장 짧은 strs[0]문자열로 각 문자열의 i번째 값과 비교 모든 문자열에서 동일한 문자가 있다면 compareText변수에 추가하고 마지막에 compareText 반환  return : strs 리스트의 모든 문자열에서 공통된 문자열 반환    class Solution:  def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str:  if not strs:  return \u0026#39;\u0026#39;  strs.sort(key=len)  compareText = \u0026#39;\u0026#39;  for i in range(len(strs[0])):  for text in strs[1:]:  if text[i] != strs[0][i]:  return compareText  compareText += strs[0][i]  return compareText 2020-12-01\n Runtime: 28 ms, faster than 90.77% of Python3 online submissions for Longest Common Prefix. Memory Usage: 14.3 MB, less than 47.57% of Python3 online submisstions for Longest Common Prefix.   20. Valid Parentheses 문제링크\n 열린 괄호 (, {, [ 는 list자료형에 스택에 쌓고 닫는 괄호 ), }, ] 는 스택의 마지막값과 비교해서 동일한 종류면 스택에서 값 제거 최종적으로 list 길이가 0일때 True 반환 아니면 False 반환   True : 모든 괄호가 쌍일 경우 False : 쌍을 이루지 못한 괄호가 있을 경우  class Solution:  def isValid(self, s: str) -\u0026gt; bool:  textLen = len(s)  if (not str) or ((textLen%2) == 1):  return False  stackList = []   for i in range(textLen):  if s[i] == \u0026#39;(\u0026#39; or s[i] == \u0026#39;{\u0026#39; or s[i] == \u0026#39;[\u0026#39;:  stackList.append(s[i])  elif not stackList:  return False  elif s[i] == \u0026#39;)\u0026#39; and stackList[-1] == \u0026#39;(\u0026#39;:  stackList.pop()  elif s[i] == \u0026#39;}\u0026#39; and stackList[-1] == \u0026#39;{\u0026#39;:  stackList.pop()  elif s[i] == \u0026#39;]\u0026#39; and stackList[-1] == \u0026#39;[\u0026#39;:  stackList.pop()  else:  return False  if stackList:  return False  else:  return True 2020-12-03\n Runtime: 16 ms, faster than 99.83% of Python3 online submissions for Valid Parentheses. Memory Usage: 14.3 MB, less than 24.08% of Python3 online submisstions for Valid Parentheses.   35. Search Insert Position 문제링크\n nums 리스트 첫 번째 index를 low변수에 저장 nums 리스트 마지막 index를 high변수에 저장 while문을 통해 low 값이 high 값보다 작을 때 실행  nums 리스트의 중간위치인 (low+high)//2 값을 index 변수에 저장 nums[index]값이 target보다 클 때 index+1값을 low변수에 저장 그 외에는 index값을 high변수에 저장   while문 종료 후 low 변수 반환  return : target값이 들어갈 index 반환    class Solution:  def searchInsert(self, nums: List[int], target: int) -\u0026gt; int:  if target \u0026lt;= nums[0]:  return 0   low, high = 0, len(nums)   while low \u0026lt; high:  index = (low+high)//2   if (nums[index] \u0026lt; target):  low = index+1  else:  high = index  return low 2020-12-02\n Runtime: 40 ms, faster than 96.18% of Python3 online submissions for Search Insert Position. Memory Usage: 15.1 MB, less than 9.31% of Python3 online submisstions for Search Insert Position.   38. Count and Say 문제링크\n 비교 문자열 1 선언 아래의 알고리즘을 입력 받은 n번 반복 실행  문자 하나씩 비교하여 같으면 count 1증가 문자가 다르면 resultText 문자열에 count값과 리스트 [i-1]번째 문자를 저장   안쪽 for문 종료 후 numText 마지막 [-1]문자열 값 대입하여 반환  return : 입력받은 각 숫자의 갯수와 숫자를 반환    class Solution:  def countAndSay(self, n: int) -\u0026gt; str:  numText = \u0026#39;1\u0026#39;  for _ in range(1, n):  count = 1  resultText = \u0026#39;\u0026#39;  for i in range(1,len(numText)):  if numText[i-1] != numText[i]:  resultText += (str(count) + numText[i-1])  count = 1  else:  count += 1  numText = resultText + str(count) + numText[-1]   return numText 2020-12-07\n Runtime: 40 ms, faster than 70.73% of Python3 online submissions for Count and Say. Memory Usage: 14.3 MB, less than 48.22% of Python3 online submisstions for Count and Say.   53. Maximum Subarray 문제링크\n 동적 계획법(Dynamic Programming, DP) 사용할 것 아래는 잘못푼 문제  class Solution:  def maxSubArray(self, nums: List[int]) -\u0026gt; int:  if len(nums) == 1:  return nums[0]   numMax = max(nums)  if numMax \u0026lt; 1:  return numMax   start, end = 0, 0  for i in range(len(nums)-1):  if 0 \u0026lt; nums[start]:  end = i+2  numSum = sum(nums[start:end])  if numSum \u0026lt; 0:  start = end  elif numMax \u0026lt;= numSum:  numMax = numSum  else:  start = i+1   return numMax 2020-12-08\n Runtime: 1580 ms,, faster than 5.26% of Python3 online submissions for Maximum Subarray. Memory Usage: 15.2 MB, less than 5.01% of Python3 online submisstions for Maximum Subarray.   58. Length of Last Word 문제링크\n 문자열 앞뒤 공백 제거 공백 으로 분할하고 리스트 마지막 문자열 반환  return : 마지막 문자열 반환    class Solution:  def lengthOfLastWord(self, s: str) -\u0026gt; int:  return len(s.strip().split(\u0026#39; \u0026#39;)[-1]) 2020-12-09\n Runtime: 16 ms, faster than 99.80% of Python3 online submissions for Length of Last Word. Memory Usage: 14.2 MB, less than 38.86% of Python3 online submissions for Length of Last Word.   66. Plus One 문제링크\n digits 리스트 마지막 값 1증가 반복문을 통해 리스트 역순으로 값 한자릿수 검증 모든요소가 단일숫자 구성시 digits 반환 digits[0] 값이 10으로 나눠질경우 digits[0]위치에 [1]값 속성 추가하여 반환  return : digits 리스트 반환    class Solution:  def plusOne(self, digits: List[int]) -\u0026gt; List[int]:  digits[-1] += 1  for i in range(len(digits)-1, -1, -1):  if digits[i]%10 != 0:  return digits  elif i != 0:  digits[i] = 0  digits[i-1] += 1  else:  digits[i] = 0  return [1] + digits 2020-12-04\n Runtime: 24 ms, faster than 95.84% of Python3 online submissions for Plus One. Memory Usage: 14.2 MB, less than 38.47% of Python3 online submisstions for Plus One.   136. Single Number 문제링크\n nums 리스트 정렬 index(0,2,4,\u0026hellip;) 2씩 증가하는 for문 실행 nums 리스트 index의 값과 index+1의 값을 비교하여 다를경우 list index 값 반환 리스트 마지막까지 도달할경우 nums[-1] 반환  return : nums 리스트에서 같은 수가 없는 값 반환    시간복잡성 O(n)\nclass Solution:  def singleNumber(self, nums: List[int]) -\u0026gt; int:  nums.sort()  numsLen = len(nums)  for i in range(0, len(nums), 2):  if numsLen \u0026lt;= i+1:  return nums[-1]  elif nums[i] != nums[i+1]:  return nums[i] 2020-12-04\n Runtime: 124 ms, faster than 85.60% of Python3 online submissions for Single Number. Memory Usage: 16.6 MB, less than 60.41% of Python3 online submisstions for Single Number.   167. Two Sum II - Input array is sorted 문제링크\n 리스트 첫번째 인덱스 = low, 마지막 인덱스 = high 선언 while문 low값이 high값보다 작을때 반복실행  리스트[low] + 리스트[high] 값이 target보다 작으면 low 1 증가 리스트[low] + 리스트[high] 값이 target보다 크면 high 1 감소 리스트[low] + 리스트[high] 값이 target 같은 값이면 low, high return     return : numbers리스트 두수의 합이 target값과 같을 때 두수의 index값 반환  class Solution:  def twoSum(self, numbers: List[int], target: int) -\u0026gt; List[int]:  low, high = 0, len(numbers)-1   while low \u0026lt; high:  val = numbers[high] + numbers[low]   if target \u0026lt; val:  high -= 1  elif val \u0026lt; target:  low += 1  else:  return [low+1, high+1] 2020-12-11\n Runtime: 56 ms, faster than 92.55% of Python3 online submissions for Two Sum II - Input array is sorted. Memory Usage: 14.8 MB, less than 11.31% of Python3 online submissions for Two Sum II - Input array is sorted.   169. Majority Element 문제링크\n방법1  nums리스트에서 중복제거 nums리스트 for문을 통해 반복  해당 속성 값의 cnt 값이 max값보다 클때 max변수에 cnt값 저장 textMax변수에 해당 속성값 저장   for문이 끝난 마지막에 textMax 반환  return : 입력받은 nums리스트의 문자 중 갯수가 많은 문자 반환    class Solution:  def majorityElement(self, nums: List[int]) -\u0026gt; int:  max, textMax = 0, None  for num in list(set(nums)):  cnt = nums.count(num)  if max \u0026lt; cnt:  max = cnt  textMax = num  return textMax 2020-12-09\n Runtime: 136 ms, faster than 99.99% of Python3 online submissions for Majority Element. Memory Usage: 15.4 MB, less than 35.47% of Python3 online submissions for Majority Element.  방법2  nums리스트 정렬하여 중간 위치값 반환  입력받는 문자는 두 종류    class Solution:  def majorityElement(self, nums: List[int]) -\u0026gt; int:  nums.sort()  return nums[len(nums)//2] 2020-12-09\n Runtime: 148 ms, faster than 98.15% of Python3 online submissions for Majority Element. Memory Usage: 15.4 MB, less than 35.47% of Python3 online submissions for Majority Element.   204. Count Primes 문제링크\n 아리스토텔레스의 체 이용하여 소수가 아닌값을 거르는 알고리즘  class Solution:  def countPrimes(self, n: int) -\u0026gt; int:  if n \u0026lt; 3: return 0   numList = [True] * n  sqrt = int(n**0.5)+1   for i in range(2, sqrt):  if numList[i]:  for j in range(i+i, n, i):  numList[j] = False  return numList.count(True)-2 2020-12-09\n Runtime: 392 ms, faster than 80.27% of Python3 online submissions for Count Primes. Memory Usage: 25.7 MB, less than 55.70% of Python3 online submissions for Count Primes.   217. Contains Duplicate 문제링크\n nums리스트 중복제거한 길이와 nums 리스트 길이와 비교 길이가 같다면 False 길이가 다르면 중복제거하여 True 반환  True : nums 리스트에 중복값이 포함 False : nums 리스트에 중복값이 없음    class Solution:  def containsDuplicate(self, nums: List[int]) -\u0026gt; bool:  return True if len(nums) != len(set(nums)) else False 2020-12-11\n Runtime: 108 ms, faster than 93.87% of Python3 online submissions for Count Primes. Memory Usage: 20.2 MB, less than 44.91% of Python3 online submissions for Count Primes.   리스트 값을 dict 키값으로 저장 리스트 반복문 실행 중에 해당 키값이 있다면 True 반환 모든 리스트가 if 조건에 걸리지 않으면 False 반환  True : 중복된 값이 존재할 경우 False : 중복된 값이 없을 경우    class Solution:  def containsDuplicate(self, nums: List[int]) -\u0026gt; bool:  dict = {}  for num in nums:  if dict.get(num):  return True  dict[num] = True  return False 2020-12-11\n Runtime: 116 ms, faster than 65.53% of Python3 online submissions for Contains Duplicate. Memory Usage: 21.5 MB, less than 8.09% of Python3 online submissions for Contains Duplicate.   231. Power of Two 문제링크\n방법1  n이 양수일때 이진수로 변환 이진수 리스트에서 앞의 두자리를 제외한 리스트를 저장 (b0~형식) 0번째 값을 제외하고 for 반복문 실행 리스트 0번째 값과 비교하여 같은 1이 나오면 False 반환 반복문 종료까지 if 조건문 안걸리면 True 반환  True : 입력받은 값이 2의 제곱수일 경우 False : 입력받은 값이 2의 제곱수가 아닐 경우    class Solution:  def isPowerOfTwo(self, n: int) -\u0026gt; bool:  if n \u0026lt; 1: return False  nums = list(bin(n))[2:]  for num in nums[1:]:  if nums[0] == num: return False  return True 2020-12-11\n Runtime: 24 ms, faster than 94.77% of Python3 online submissions for Power of Two. Memory Usage: 14.3 MB, less than 15.35% of Python3 online submissions for Power of Two.  방법2  입력값 n이 양수이고 2의 거듭제곱수 판별은 n값과 n-1값을 비트 AND연산하면 0으로 나옴 위의 2가지 조건이 만족하면 True 만족하지 않는다면 False 반환  class Solution:  def isPowerOfTwo(self, n: int) -\u0026gt; bool:  return (0\u0026lt;n) and ((n\u0026amp;(n-1)) == 0) 2020-12-11\n Runtime: 24 ms, faster than 94.77% of Python3 online submissions for Power of Two. Memory Usage: 14.1 MB, less than 80.64% of Python3 online submissions for Power of Two.   242. Valid Anagram 문제링크\n s, t 문자열을 sorted함수로 정렬된 리스트 반환받아 비교하여 결과값 반환  True : 입력받은 두 문자열이 동일할 경우 False : 입력받은 두 문자열이 다를 경우    class Solution:  def isAnagram(self, s: str, t: str) -\u0026gt; bool:  return sorted(s) == sorted(t) 2020-12-11\n Runtime: 40 ms, faster than 84.57% of Python3 online submissions for Valid Anagram. Memory Usage: 15 MB, less than 6.58% of Python3 online submissions for Valid Anagram.   258. Add Digits 문제링크\n방법1  num 값을 10으로 나눈 몫과 나머지를 합산하고 num 값이 10 이하 일때 반환  return : 자릿수근 반환    시간복잡성 : O(n)\nclass Solution:  def addDigits(self, num: int) -\u0026gt; int:  while 9 \u0026lt; num:  num = num//10 + num%10  return num 2020-12-14\n Runtime: 20 ms, faster than 98.98% of Python3 online submissions for Add Digits. Memory Usage: 14.3 MB, less than 20.30% of Python3 online submissions for Add Digits.  방법2  num 값을 (num-1) % 9 + 1자릿수근(digital root) 공식을 이용하여 결과값 반환  return : 자릿수근 반환    시간복잡성 : O(1)\nclass Solution:  def addDigits(self, num: int) -\u0026gt; int:  return 0 if num == 0 else (num-1)%9 + 1 2020-12-14\n Runtime: 24 ms, faster than 95.45% of Python3 online submissions for Add Digits. Memory Usage: 14.3 MB, less than 20.30% of Python3 online submissions for Add Digits.   263. Ugly Number 문제링크\n while 반복문으로 num값이 5로 나눈 나머지가 0일때 몫을 num값에 저장 동일한 방식으로 3, 2로 나눈다. 결과값이 1일때만 True, 그외의 결과는 False 반환  True : 입력받은 값이 2, 3, 5로 나누어질 경우 False : 그외의 경우    class Solution:  def isUgly(self, num: int) -\u0026gt; bool:  if num == 0: return False  while num % 5 == 0:  num //= 5  while num % 3 == 0:  num //= 3  while num % 2 == 0:  num //= 2  return num == 1 2020-12-14\n Runtime: 28 ms, faster than 82.19% of Python3 online submissions for Ugly Number. Memory Usage: 14.3 MB, less than 19.35% of Python3 online submissions for Ugly Number.   268. Missing Number 문제링크\n방법1  nums리스트 정렬 nums리스트 길이만큼 for문 실행 index 위치값에 해당되는 값이 없으면 index 반환 for문 마지막까지 if문 해당되지 않을경우 nums리스트 길이 반환  return : nums리스트에 없는 값 반환    공간복잡성 : O(1)\n시간복잡성 : O(n)\nclass Solution:  def missingNumber(self, nums: List[int]) -\u0026gt; int:  nums.sort()  numsLen = len(nums)  for i in range(numsLen):  if nums[i] != i:  return i  return numsLen 2020-12-14\n Runtime: 136 ms, faster than 38.61% of Python3 online submissions for Missing Number. Memory Usage: 15.5 MB, less than 27.11% of Python3 online submissions for Missing Number.  방법2  nums리스트의 길이를 n변수에 대입 1부터 n까지 수의 합(가우스 공식)을 계산하여 total변수에 대입  가우스 공식 : n*(n-1)/2 + n   total - (nums리스트 합)을 값을 반환  return : nums리스트에 없는 값 반환    공간복잡성 : O(1)\n시간복잡성 : O(n)\nclass Solution:  def missingNumber(self, nums: List[int]) -\u0026gt; int:  n = len(nums)  total = int(n*(n-1)/2)+n  return total - sum(nums) 2020-12-14\n Runtime: 120 ms, faster than 93.14% of Python3 online submissions for Missing Number. Memory Usage: 15.4 MB, less than 38.54% of Python3 online submissions for Missing Number.   278. First Bad Version 문제링크\n 이진탐색으로 풀이 low변수에 0, high변수에 n 대입 while문으로 low변수가 high보다 작을때 반복실행  low와 high의 중간값을 middle변수에 저장 isBadVersion(middle)의 반환값이 True이면 high변수에 middle 대입 isBadVersion(middle)의 반환값이 False이면 low변수에 middle + 1 대입   low변수 반환   return : isBadVersion(n) 반환값중 False결과가 나오는 가장 큰 n+1 반환  시간복잡성 : O(log n)\nclass Solution:  def firstBadVersion(self, n):  \u0026#34;\u0026#34;\u0026#34; :type n: int :rtype: int \u0026#34;\u0026#34;\u0026#34;  low, middle, high = 0, 1, n   while low \u0026lt; high:  middle = (low+high)//2   if isBadVersion(middle):  high = middle  else:  low = middle + 1  return low 2020-12-14\n Runtime: 24 ms, faster than 90.25% of Python3 online submissions for First Bad Version. Memory Usage: 14.1 MB, less than 45.50% of Python3 online submissions for First Bad Version.   283. Move Zeroes 문제링크\n nums리스트 요소값이 0이 아닐때 index인 i값 1증가시키고 nums리스트 요소값이 0일때 해당 요소삭제 및 리스트 마지막에 [0]추가 위의 과정들을 for문으로 nums리스트의 길이만큼 반복 실행   return : 앞에는 0을 제외한 nums리스트, 뒤에는 제외된 [0]이 리스트에 붙어서 반환  시간복잡성 : O(log n)\n공간복잡성 : O(1)\nclass Solution:  def moveZeroes(self, nums: List[int]) -\u0026gt; None:  zero_cnt = 0  for i in range(len(nums)-1, -1, -1):  if nums[i] == 0:  del nums[i]  zero_cnt += 1  nums += ([0] * zero_cnt) 2020-12-15\n Runtime: 44 ms, faster than 88.45% of Python3 online submissions for Move Zeroes. Memory Usage: 15.2 MB, less than 63.17% of Python3 online submissions for Move Zeroes.   292. Nim Game 문제링크\n n값을 4로 나누었을때 0일경우만 False, 그외에 True  시간복잡성 : O(1)\n공간복잡성 : O(1)\nclass Solution:  def canWinNim(self, n: int) -\u0026gt; bool:  return n%4 2020-12-15\n Runtime: 28 ms, faster than 68.93% of Python3 online submissions for Nim Game. Memory Usage: 14.2 MB, less than 38.05% of Python3 online submissions for Nim Game.   342. Power of Four 문제링크\n방법1  양수인 n을 이진수로 변환 각 이진수를 int형변환하고 num리스트에 저장 이진수가 짝수개이면 4의 제곱이 아니므로 return num리스트에서 0번째를 제외한 모든 값을 or연산  모든값이 0 일때만 4의 제곱수   연산한 결과 result not 연산하여 반환  시간복잡성 : O(log n)\n공간복잡성 : O(1)\nclass Solution:  def isPowerOfFour(self, n: int) -\u0026gt; bool:  if n \u0026lt; 1: return False   nums = list(map(int, bin(n)[2:]))  if len(nums)%2==0: return False   result = False  for num in nums[1:]:  result |= num  return not result 2020-12-15\n Runtime: 16 ms, faster than 99.80% of Python3 online submissions for Power of Four. Memory Usage: 14.3 MB, less than 17.90% of Python3 online submissions for Power of Four.  방법2  양수인 n을 2비트 우쉬프트 연산결과 곱하기 4일때 n과 동일하면서 n비트 갯수가 홀수 일때 res변수에 True 대입 그 외 경우 res 반환 n을 2비트 우쉬프트 연산 위의 과정을 n 1 이하일때 까지 반복하고 res 반환  시간복잡성 : O(log n)\n공간복잡성 : O(1)\nclass Solution:  def isPowerOfFour(self, n: int) -\u0026gt; bool:  if n == 1: return True  res = False  while 1 \u0026lt; n:  res = False  if (n\u0026gt;\u0026gt;2)*4 == n and len(bin(n))%2==1:  res = True  else:  return res  n \u0026gt;\u0026gt;= 2  return res 2020-12-15\n Runtime: 28 ms, faster than 82.04% of Python3 online submissions for Power of Four. Memory Usage: 14 MB, less than 82.10% of Python3 online submissions for Power of Four.   1678. Goal Parser Interpretation 문제링크\n command문자열에서 () -\u0026gt; o, (al) -\u0026gt; al 문자열 변환하여 반환  class Solution:  def interpret(self, command: str) -\u0026gt; str:  return command.replace(\u0026#39;()\u0026#39;, \u0026#39;o\u0026#39;).replace(\u0026#39;(al)\u0026#39;, \u0026#39;al\u0026#39;) 2020-12-11\n Runtime: 28 ms, faster than 89.89% of Python3 online submissions for Goal Parser Interpretation. Memory Usage: 13.9 MB, less than 100.00% of Python3 online submissions for Goal Parser Interpretation.  ","date":"December 1, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/algorithm/leetcode/2020-12-01-algorithm-leetcode-python-easy/","summary":"1. Two Sum 문제 링크\n nums 리스트 속성값 중 두개의 값이 target 값과 동일할때 해당 속성 값의 index 반환  class Solution:  def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]:  for i, num in enumerate(nums):  for j, num2 in enumerate(nums[i+1:]):  if i != j+i+1:  if target == num+num2:  return [i, j+i+1] 2020-11-27\n Runtime: 40 ms, faster than 97.02% of Python3 online submissions for Two Sum.","tags":["algorithm","leetcode","python"],"title":"LeetCode Python (Easy)"},{"categories":["Python","Guide"],"contents":" 1. 라이브러리 설치 pip install pyftpdlib 실습 버전 : pyftpdlib 1.5.6\n2. Server ftp server 실행 후 client 테스트 가능\nfrom pyftpdlib.authorizers import DummyAuthorizer # 사용자 인증을 생성하는 모듈 from pyftpdlib.handlers import FTPHandler # 사용자 인증, 파일 전송, 로깅 등 FTP서버를 조작하는 모듈 # from pyftpdlib.handlers import TLS_FTPHandler from pyftpdlib.servers import FTPServer # FTP서버를 실행하는 모듈 # from pyftpdlib.servers import ThreadedFTPServer  import os  class FileServer:  def __init__(self):  self.ftpServerIP = \u0026#34;127.0.0.1\u0026#34;  self.ftpServerPort = 21   self.userId = \u0026#34;ftpuser\u0026#34;  self.userPassword = \u0026#34;password\u0026#34;  self.userDir = \u0026#34;D:/ftp_share/\u0026#34;   def start(self):  # 계정별 디렉토리 생성  if not (os.path.exists(self.userDir)):  os.makedirs(self.userDir, exist_ok=True)  # FTP Server 계정 추가  authorizer = DummyAuthorizer()  authorizer.add_user(self.userId, self.userPassword, self.userDir, perm=\u0026#34;elradfmwMT\u0026#34;) # 모든 권한(elradfmw)을 부여  # authorizer.add_anonymous(self.userDir, perm=\u0026#39;elr\u0026#39;) # 탐색(읽기) 권한만 부여   handler = FTPHandler  handler.banner = \u0026#34;pyftpdlib based ftpd ready.\u0026#34; # 배너 설정   handler.authorizer = authorizer  handler.passive_ports = range(60000, 65535) # 패시브통신 포트지정   address = (self.ftpServerIP, self.ftpServerPort) # FTP 서버주소 및 포트설정  server = FTPServer(address, handler)  # server = ThreadedFTPServer(address, handler)   server.max_cons = 50 # 최대 연결 개수  server.max_cons_per_ip = 5 # IP당 최대 연결 개수  print(f\u0026#39;[FileServer] Share Dir = {self.userDir}\u0026#39;)  server.serve_forever()  file_server = FileServer() file_server.start() 3. Client 3.1. FTPClient FTPClient.py\nimport ftplib import os  class FTPClient:  def __init__(self):  self.ftp = ftplib.FTP()  self.ftp_server_ip = \u0026#34;127.0.0.1\u0026#34;  self.ftp_server_port = 21   self.user_id = \u0026#34;ftpuser\u0026#34;  self.user_password = \u0026#34;password\u0026#34;   def connect_setting(self):  try:  ftp = self.ftp  ftp.connect(host=self.ftp_server_ip, port=self.ftp_server_port, timeout=10)  ftp.login(user=self.user_id, passwd=self.user_password)  ftp.encoding = \u0026#39;utf-8\u0026#39;   # 디버그 모드 설정 (설정하면 FTP 서버와 통신하는 내용이 콘솔에 표시됨)  # ftp.set_debuglevel(1)   return ftp   except ftplib.all_errors as ex:  print(f\u0026#34;[connect_setting] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[connect_setting] Error = {ex}\u0026#34;)   # Welcome Test message  def get_msg(self):  try:  ftp = self.connect_setting()  print(ftp.getwelcome())  ftp.close()   except ftplib.all_errors as ex:  print(f\u0026#34;[get_msg] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[get_msg] Error = {ex}\u0026#34;)   # 파일 다운로드  def download(self, server_dir_path: str, client_dir_path: str, filename: str):  try:  # 다운받을 디렉토리 없으면 디렉토리 생성  os.makedirs(client_dir_path, exist_ok=True)   ftp = self.connect_setting()  ftp.cwd(dirname=server_dir_path)  filePath = f\u0026#34;{client_dir_path}/{filename}\u0026#34;  with open(filePath, \u0026#39;wb\u0026#39;) as fd:  res = ftp.retrbinary(\u0026#34;RETR \u0026#34; + filename, fd.write)   if not res.startswith(\u0026#39;226 Transfer complete\u0026#39;): # 다운로드 실패시 다운받은 파일 삭제  print(f\u0026#34;[download] FTP Failed FileName = {fd}\u0026#34;)  if os.path.isfile(filename):  os.remove(filename)   except ftplib.all_errors as ex:  print(f\u0026#34;[download] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[download] Error = {ex}\u0026#34;)   # 파일 업로드  def upload(self, server_dir_path: str, client_dir_path: str, filename: str):  try:  ftp = self.connect_setting()  ftp.cwd(dirname=server_dir_path)   with open(f\u0026#34;{client_dir_path}/{filename}\u0026#34;, \u0026#39;rb\u0026#39;) as fd:  res = ftp.storbinary(\u0026#39;STOR \u0026#39; + filename, fd)  if not res.startswith(\u0026#39;226 Transfer complete\u0026#39;):  print(f\u0026#34;[upload] FTP Failed FileName = {fd}\u0026#34;)  print(f\u0026#34;\\x1b[1;36m [upload] FTP Success FileName = {filename}\u0026#34;)   except ftplib.error_perm as ex:  print(f\u0026#34;[upload] FTP Error_perm = {ex}\u0026#34;)  # FTP Server 해당 디렉토리가 없을시 디렉토리 생성후 다시 업로드  if str(ex) == \u0026#39;550 No such file or directory.\u0026#39;:  self.create_dir(server_dir_path)  self.upload(server_dir_path, client_dir_path, filename)  except ftplib.all_errors as ex:  print(f\u0026#34;[upload] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[upload] Error = {ex}\u0026#34;)   # 파일 삭제  def delete_file(self, server_dir_path: str, filename: str):  try:  ftp = self.connect_setting()  ftp.cwd(dirname=server_dir_path)  ftp.delete(filename)  ftp.close()   except ftplib.all_errors as ex:  print(f\u0026#34;[delete_file] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[delete_file] Error = {ex}\u0026#34;)   # 디렉터리 삭제  def delete_dir(self, server_dir_path: str, dir_name: str):  try:  ftp = self.connect_setting()  ftp.cwd(dirname=server_dir_path)  ftp.rmd(dir_name)  ftp.close()   except ftplib.all_errors as ex:  print(f\u0026#34;[delete_dir] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[delete_dir] Error = {ex}\u0026#34;)   # 디렉토리 목록  def dir_list(self, dir_name=\u0026#39;/\u0026#39;):  try:  ftp = self.connect_setting()  ftp.cwd(dir_name)  files = []  ftp.dir(files.append) # LIST 명령으로 반환되는 디렉토리 목록 생성  ftp.close()  return files   except ftplib.all_errors as ex:  print(f\u0026#34;[dir_list] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[dir_list] Error = {ex}\u0026#34;)   # 디렉토리 생성  def create_dir(self, dir_name: str):  try:  # FTP 서버 디렉토리 목록 얻어오기  files_list = self.dir_list(f\u0026#34;{dir_name}/../\u0026#34;)  d_list = []  for file in files_list:  if file[0] == \u0026#39;d\u0026#39;:  d_list.append(file.split(\u0026#39; \u0026#39;)[-1])  print(f\u0026#34;\\x1b[1;36m [create_dir] d_list = {d_list}\u0026#34;)   if not (dir_name in d_list):  # 디렉토리 생성  ftp = self.connect_setting()  ftp.mkd(dir_name) # 새 디렉토리 생성  ftp.close()  print(f\u0026#34;\\x1b[1;36m [create_dir] Dir Name = {dir_name}\u0026#34;)   except ftplib.all_errors as ex:  print(f\u0026#34;[create_dir] FTP Error = {ex}\u0026#34;)  except Exception as ex:  print(f\u0026#34;[create_dir] Error = {ex}\u0026#34;)   # # FTP 명령어 전송  # def send_cmd(self, cmd: str):  # try:  # ftp = self.connect_setting()  # work_dir = ftp.sendcmd(\u0026#39;PWD\u0026#39;) # PWD 명령을 직접 전송 하고 pwd()메소드를 사용하여 현재 작업 디렉토리를 검색  # print(ftplib.parse257(work_dir)) # 상태 코드가 들어있는 반환 된 문자열에서 디렉토리를 검색  #  # work_dir2 = ftp.pwd() # 현재 작업 디렉토리를 검색  # print(work_dir2)  # except ftplib.all_errors as ex:  # print(f\u0026#34;[send_cmd] FTP Error = {ex}\u0026#34;) 3.2. client client.py\nfrom FTPClient import FTPClient  ftp_client = FTPClient() client_path = \u0026#34;D:/ftp_share/ftpclient\u0026#34;  # FTP 다운로드  # server_dir_path 경로 : D:/ftp_share/ftpserver/temp/ # client_dir_path 경로 : D:/ftp_share/ftpclient/temp/ ftp_client.download(server_dir_path=\u0026#39;/ftpserver/temp/\u0026#39;, client_dir_path=f\u0026#39;{client_path}/temp/\u0026#39;, filename=\u0026#39;test.txt\u0026#39;)  # FTP Server 테스트 파일 삭제 ftp_client.deleteFile(server_dir_path=\u0026#39;/ftpserver/temp/\u0026#39;, filename=\u0026#39;test.txt\u0026#39;)  # FTP Server temp 디렉토리 삭제 ftp_client.deleteDir(server_dir_path=\u0026#39;/ftpserver/\u0026#39;, dir_name=\u0026#39;temp\u0026#39;)  # FTP 업로드 self.ftpClient.upload(server_dir_path=\u0026#34;/ftpserver/temp2/\u0026#34;, client_dir_path=f\u0026#39;{client_path}/temp/\u0026#39;, filename=\u0026#39;test.txt\u0026#39;)  참고(Reference)  pyftpdlib Docs  ","date":"November 16, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2020-11-16-pyftpdlib-guide/","summary":"1. 라이브러리 설치 pip install pyftpdlib 실습 버전 : pyftpdlib 1.5.6\n2. Server ftp server 실행 후 client 테스트 가능\nfrom pyftpdlib.authorizers import DummyAuthorizer # 사용자 인증을 생성하는 모듈 from pyftpdlib.handlers import FTPHandler # 사용자 인증, 파일 전송, 로깅 등 FTP서버를 조작하는 모듈 # from pyftpdlib.handlers import TLS_FTPHandler from pyftpdlib.servers import FTPServer # FTP서버를 실행하는 모듈 # from pyftpdlib.servers import ThreadedFTPServer  import os  class FileServer:  def __init__(self):  self.","tags":["python","library"],"title":"pyftpdlib 라이브러리 사용법 (pyftpdlib Library Guide)"},{"categories":["Python","Guide"],"contents":" 미디어 타입(media type), MIME 타입(MIME type)\n1. 라이브러리 설치 실행환경 : windows 10\npip install libmagic pip install python-magic-bin 실행환경 : linux\npip install libmagic pip install python-magic  libmagic : 파일타입을 MIME 타입으로 확인해주는 라이브러리 python-magic-bin : 윈도우용 magic 라이브러리 python-magic : 리눅스용 magic 라이브러리   2. 예제 코드 import magic  r1 = magic.from_file(\u0026#34;test1.txt\u0026#34;) r2 = magic.from_file(\u0026#34;test1.txt\u0026#34;, mime=True) print(f\u0026#34;filetype = {r1}, \\nmime = {r2}\u0026#34;) # filetype = UTF-8 Unicode text, with CRLF line terminators, # mime = text/plain  file_data = open(\u0026#39;test1.txt\u0026#39;, \u0026#39;r\u0026#39;).read(1024) r3 = magic.from_buffer(file_data) r4 = magic.from_buffer(file_data, mime=True) print(f\u0026#34;filetype = {r3}, \\nmime = {r4}\u0026#34;) UnicodeDecodeError 에러 발생시 UnicodeDecodeError: \u0026#39;cp949\u0026#39; codec can\u0026#39;t decode byte 0xd3 in position 23: illegal multibyte sequence file open encoding 지정하여 디코딩 가능하도록 코드 수정\nfile_data = open(\u0026#39;test1.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;).read(1024) r3 = magic.from_buffer(file_data) r4 = magic.from_buffer(file_data, mime=True) print(f\u0026#34;filetype = {r3}, \\nmime = {r4}\u0026#34;) # filetype = data, # mime = application/octet-stream ","date":"November 5, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/programming/python/2020-11-05-python-magic-guide/","summary":"미디어 타입(media type), MIME 타입(MIME type)\n1. 라이브러리 설치 실행환경 : windows 10\npip install libmagic pip install python-magic-bin 실행환경 : linux\npip install libmagic pip install python-magic  libmagic : 파일타입을 MIME 타입으로 확인해주는 라이브러리 python-magic-bin : 윈도우용 magic 라이브러리 python-magic : 리눅스용 magic 라이브러리   2. 예제 코드 import magic  r1 = magic.from_file(\u0026#34;test1.txt\u0026#34;) r2 = magic.from_file(\u0026#34;test1.txt\u0026#34;, mime=True) print(f\u0026#34;filetype = {r1}, \\nmime = {r2}\u0026#34;) # filetype = UTF-8 Unicode text, with CRLF line terminators, # mime = text/plain  file_data = open(\u0026#39;test1.","tags":["python","library"],"title":"libmagic 라이브러리 사용법 (libmagic Library Guide)"},{"categories":["DB","PostgreDB"],"contents":" 1. DATABASE 생성   DATABASE 생성\n  PostgreDB의 경우 대문자인식은 \u0026ldquo;\u0026ldquo;으로 감싸야 사용가능하다.\nCREATE DATABASE \u0026#34;{database_name}\u0026#34;;    2. USER 생성   USER 생성\nCREATE USER {user_name} WITH PASSWORD \u0026#39;{user_password}\u0026#39;   SUPERUSER 권한부여(개발용 계정으로 사용 예정)\nALTER USER {user_name} WITH SUPERUSER;   유저에게 특정 권한 부여\nGRANT {permissions} ON DATABASE {db_name} TO {user_name}; 참고 URL : https://www.postgresql.org/docs/current/sql-grant.html\n  예시\nGRANT ALL ON DATABASE \u0026#34;ABCD_DB\u0026#34; TO abcd_user;     계정 부여권한 해제\nREVOKE ALL ON DATABASE {db_name} FROM {user_name};   계정 삭제\nDROP ROLE {user_name};    3. DB insert 3.1. 기본 insert INSERT INTO Table_Name VALUES (VALUE_LIST1, VALUE_LIST2, ...); INSERT INTO PLAYER VALUES (\u0026#39;1\u0026#39;, \u0026#39;player_name\u0026#39;, \u0026#39;code1\u0026#39;, 1, 21); 3.2. 리스트/배열 데이터 insert INSERT INTO Table_Name VALUES (\u0026#39;{LIST_VALUE}\u0026#39;); INSERT INTO \u0026#34;WeightsFile\u0026#34; VALUES (1, \u0026#39;test_Weights.npz\u0026#39;, \u0026#39;{test_catagory1, test_catagory2}\u0026#39;, 1, \u0026#39;color\u0026#39;) 3.3. 2차원 리스트 저장방법 사용환경 : django, postgreDB\n키를 index로 값을 data로 변환\n# models.py class modelName(models.Model):  columnName = models.JSONField()  # process.py (2차원 리스트 \u0026gt; json) from .models import modelName  Dict = {} for i in range(len(list1)):  Dict[i] = list2[\u0026#39;data\u0026#39;][i]  modelInstance = modelName(  columnName = Dict ) modelInstance.save()  # process.py (json \u0026gt; 2차원 리스트) exportList = list(modelName.objects.filter(id=id).values(\u0026#39;id\u0026#39;, \u0026#39;columnName\u0026#39;))  for i in range(len(exportList)):  exportList[i][\u0026#39;data\u0026#39;] = list(exportList[i][\u0026#39;data\u0026#39;].values())  4. 기본키 초기화 ALTER SEQUENCE \u0026#34;TableName_id_seq\u0026#34; RESTART WITH 1; 4.1. 테이블 데이터 삭제 및 ID값 초기화 예제 delete from \u0026#34;DatasheetUpload\u0026#34; where id \u0026gt; 0; ALTER SEQUENCE \u0026#34;DatasheetUpload_id_seq\u0026#34; RESTART WITH 1;  delete from \u0026#34;Annotations\u0026#34; where id \u0026gt; 0; ALTER SEQUENCE \u0026#34;Annotations_id_seq\u0026#34; RESTART WITH 1;  delete from \u0026#34;Categories\u0026#34; where id \u0026gt; 0; ALTER SEQUENCE \u0026#34;Categories_categories_id_seq\u0026#34; RESTART WITH 1;  delete from \u0026#34;Images\u0026#34; where id \u0026gt; 0; ALTER SEQUENCE \u0026#34;Images_id_seq\u0026#34; RESTART WITH 1; ","date":"October 20, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/db/2020-10-20-postgresql-command/","summary":"1. DATABASE 생성   DATABASE 생성\n  PostgreDB의 경우 대문자인식은 \u0026ldquo;\u0026ldquo;으로 감싸야 사용가능하다.\nCREATE DATABASE \u0026#34;{database_name}\u0026#34;;    2. USER 생성   USER 생성\nCREATE USER {user_name} WITH PASSWORD \u0026#39;{user_password}\u0026#39;   SUPERUSER 권한부여(개발용 계정으로 사용 예정)\nALTER USER {user_name} WITH SUPERUSER;   유저에게 특정 권한 부여\nGRANT {permissions} ON DATABASE {db_name} TO {user_name}; 참고 URL : https://www.postgresql.org/docs/current/sql-grant.html\n  예시\nGRANT ALL ON DATABASE \u0026#34;ABCD_DB\u0026#34; TO abcd_user;     계정 부여권한 해제","tags":["db","postgredb","sql"],"title":"PostgreDB SQL 명령어 (PostgreDB SQL Command)"},{"categories":["DB","MSSQL"],"contents":" 1. 테이블 생성 (Create Table) CREATE TABLE 테이블명(  컬럼명 타입(크기) NOT NULL, --NULL 값이 들어갈 수 없음  컬럼명 타입 NULL DEFAULT(값), --초기값 지정  CONSTRAIN PK이름 PRIMARY KEY(컬럼명) --PK설정 ) 컬럼 타입 : INT / NVARCHAR / VARCHAR / DATETIME\nCREATE TABLE MY_TABLE(  NO_EMP NVARCHAR(10)NOT NULL, -- NULL 값이 들어갈 수 없음  NM_KOR NVARCHAR(40)NOT NULL, -- NULL 값이 들어갈 수 없음  AGE INT NULL DEFAULT (0), --초기값 = 0  TODAY DATETIME DEFAULT(GETDATE()), --초기값 현재날짜 ) --CONSTRAINT PK_MY_TABLE PRIMARY KEY(NO_EMP)--PK : NO_EMP ) CREATE TABLE MY_TABLE2(  ID int PRIMARY KEY,  DATA_JSON nvarchar NULL,  CODE nvarchar(20) NOT NULL,  IMAGE_PATH nvarchar(300) NOT NULL,  IMAGE_NAME nvarchar(100) NOT NULL,  IMAGE_TYPE nvarchar(5) NOT NULL,  IN_DATE datetime default(GETDATE()) NOT NULL )  2. 테이블 수정 (Alter Table) 2.1. 테이블 컬럼 확인 SP_COLUMNS {테이블명}  SP_HELP {테이블명} SP_COLUMNS MY_TABLE  SP_HELP MY_TABLE 2.2. 테이블 변경 (컬럼 추가) ALTER TABLE 테이블명 ADD 컬럼명 컬럼 속성 ALTER TABLE MY_TABLE ADD NM_ENG NVARCHAR NOT NULL 2.3. 테이블 변경 (컬럼 수정) ALTER TABLE 테이블명 ALTER 컬럼명 컬럼 속성 ALTER TABLE MY_TABLE ALTER COLUMN NM_ENG INT 2.4. 테이블 변경 (컬럼 삭제) ALTER TABLE 테이블명 DROP COLUMN 컬럼명 ALTER TABLE MY_TABLE DROP COLUMN NM_ENG  3. 테이블 삭제 (Drop Table) 3.1. 테이블 삭제 DROP TABLE 테이블명 DROP TABLE MY_TABLE  4. json 데이터 4.1. json 데이터 삽입 (insert) INSERT INTO {table_name} VALUES (ID, N\u0026#39;{}\u0026#39;) INSERT INTO MY_TABLE VALUES (1, N\u0026#39;{\u0026#34;EmployeeInfo\u0026#34;: { \u0026#34;FirstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;LastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;Dob\u0026#34;: \u0026#34;12-Jan-1970\u0026#34;, \u0026#34;AnnualSalary\u0026#34;: 85000 }}\u0026#39;) 4.2. json 특정 데이터 호출 (JSON_VALUE) 같은 속성이 여러개 있다면 인덱스로 접근 가능. 인덱스는 0부터 시작\nSELECT JSON_VALUE(json_data, \u0026#39;$.EmployeeInfo.FirstName\u0026#39;) FROM jsontest 4.3. JSON 형식으로 내보내기 (FOR JSON) for json은 테이블에 있는 데이터들을 JSON 형식으로 내보내기 위한 함수\nSELECT * FROM jsontest FOR JSON AUTO 4.4. json 필드 생성 예제   테이블 생성\nCREATE TABLE TB_JSONTEST(  ID int PRIMARY KEY,  DATA_JSON nvarchar(max) NULL,  SEQ nvarchar(11) NOT NULL,  IMAGE_PATH nvarchar(300) NOT NULL,  IMAGE_NAME nvarchar(100) NOT NULL,  DIRECT_CODE nvarchar(2) NOT NULL,  IN_DATE datetime default(GETDATE()) NOT NULL )   테이블내 데이터 추가\nINSERT INTO dbo.TB_JSONTEST (ID, DATA_JSON, SEQ, IMAGE_PATH, IMAGE_NAME, DIRECT_CODE) VALUES (2, N\u0026#39;{\u0026#34;EmployeeInfo\u0026#34;: {\u0026#34;FirstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;LastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;Dob\u0026#34;: \u0026#34;12-Jan-1970\u0026#34;, \u0026#34;AnnualSalary\u0026#34;: 85000}}\u0026#39;, \u0026#39;A12345\u0026#39;, \u0026#39;D:\\image\\\u0026#39;, \u0026#39;D:\\image\\image001.jpg\u0026#39;, \u0026#39;V\u0026#39;)   테이블 데이터 조회\nselect * from TB_JSONTEST   테이블 삭제\nDROP TABLE TB_JSONTEST   ","date":"October 13, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/db/2020-10-13-mssql-command/","summary":"1. 테이블 생성 (Create Table) CREATE TABLE 테이블명(  컬럼명 타입(크기) NOT NULL, --NULL 값이 들어갈 수 없음  컬럼명 타입 NULL DEFAULT(값), --초기값 지정  CONSTRAIN PK이름 PRIMARY KEY(컬럼명) --PK설정 ) 컬럼 타입 : INT / NVARCHAR / VARCHAR / DATETIME\nCREATE TABLE MY_TABLE(  NO_EMP NVARCHAR(10)NOT NULL, -- NULL 값이 들어갈 수 없음  NM_KOR NVARCHAR(40)NOT NULL, -- NULL 값이 들어갈 수 없음  AGE INT NULL DEFAULT (0), --초기값 = 0  TODAY DATETIME DEFAULT(GETDATE()), --초기값 현재날짜 ) --CONSTRAINT PK_MY_TABLE PRIMARY KEY(NO_EMP)--PK : NO_EMP ) CREATE TABLE MY_TABLE2(  ID int PRIMARY KEY,  DATA_JSON nvarchar NULL,  CODE nvarchar(20) NOT NULL,  IMAGE_PATH nvarchar(300) NOT NULL,  IMAGE_NAME nvarchar(100) NOT NULL,  IMAGE_TYPE nvarchar(5) NOT NULL,  IN_DATE datetime default(GETDATE()) NOT NULL )  2.","tags":["db","mssql","sql"],"title":"MSSQL SQL 명령어 (MSSQL SQL Command)"},{"categories":["DB","sqlcmd"],"contents":" sqlcmd 대용량 sql 파일실행은 sqlcmd로만 실행가능하다.\n다른 sql 실행방법은 메모리에 해당 sql 파일을 로딩한 상태로 실행하여 크기제한이 있지만 sqlcmd는 해당 sql문 하나하나 별도로 실행하기 때문이다.\n사용 예시 sqlcmd \\ -S 127.0.0.1,1433 \\ -i input_file[ , input_file2...] \\ -o output_file \\ -U login_id \\ -P password \\ -d db_name  -S : 접속할 IP,접속포트\n-i : 실행할 sql 파일 지정\n-i C:\u0026lt;filename\u0026gt;\n-i \\\u0026lt;Share$\u0026gt;\u0026lt;filename\u0026gt;\n-i \u0026ldquo;C:\\Some Folder\u0026lt;file name\u0026gt;\u0026rdquo;\n-o : 실행결과 저장할 파일 지정\n-U : 계정\n-P : 패스워드\n-d : Database 이름\n windows 환경\n 계정과 패스워드는 설정해주지 않으면 윈도우 기본계정으로 접속  linux 환경에서 대용량 파일 줄단위 분할\n split -l 10000 \u0026ldquo;aaa.sql\u0026rdquo; \u0026ldquo;aaa.sql.\u0026rdquo;  sqlcmd 옵션 sqlcmd  -a packet_size  -A (dedicated administrator connection)  -b (terminate batch job if there is an error)  -c batch_terminator  -C (trust the server certificate)  -d db_name  -e (echo input)  -E (use trusted connection)  -f codepage | i:codepage[,o:codepage] | o:codepage[,i:codepage]  -g (enable column encryption)  -G (use Azure Active Directory for authentication)  -h rows_per_header  -H workstation_name  -i input_file  -I (enable quoted identifiers)  -j (Print raw error messages)  -k[1 | 2] (remove or replace control characters)  -K application_intent  -l login_timeout  -L[c] (list servers, optional clean output)  -m error_level  -M multisubnet_failover  -N (encrypt connection)  -o output_file  -p[1] (print statistics, optional colon format)  -P password  -q \u0026#34;cmdline query\u0026#34;  -Q \u0026#34;cmdline query\u0026#34; (and exit)  -r[0 | 1] (msgs to stderr)  -R (use client regional settings)  -s col_separator  -S [protocol:]server[instance_name][,port]  -t query_timeout  -u (unicode output file)  -U login_id  -v var = \u0026#34;value\u0026#34;  -V error_severity_level  -w column_width  -W (remove trailing spaces)  -x (disable variable substitution)  -X[1] (disable commands, startup script, environment variables, optional exit)  -y variable_length_type_display_width  -Y fixed_length_type_display_width  -z new_password  -Z new_password (and exit)  -? (usage) ","date":"September 30, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/db/2020-09-30-sqlcmd-guide/","summary":"sqlcmd 대용량 sql 파일실행은 sqlcmd로만 실행가능하다.\n다른 sql 실행방법은 메모리에 해당 sql 파일을 로딩한 상태로 실행하여 크기제한이 있지만 sqlcmd는 해당 sql문 하나하나 별도로 실행하기 때문이다.\n사용 예시 sqlcmd \\ -S 127.0.0.1,1433 \\ -i input_file[ , input_file2...] \\ -o output_file \\ -U login_id \\ -P password \\ -d db_name  -S : 접속할 IP,접속포트\n-i : 실행할 sql 파일 지정\n-i C:\u0026lt;filename\u0026gt;\n-i \\\u0026lt;Share$\u0026gt;\u0026lt;filename\u0026gt;\n-i \u0026ldquo;C:\\Some Folder\u0026lt;file name\u0026gt;\u0026rdquo;\n-o : 실행결과 저장할 파일 지정","tags":["db","sqlcmd"],"title":"sqlcmd 사용법 (sqlcmd-guide)"},{"categories":["DB","PostgreDB"],"contents":" 설치환경 : Windows 10\n1. PostgreDB 설치 1.1. 설치파일 다운로드 윈도우즈용 설치 파일은 현재 EnterpriseDB사가 배포\n Download URL\nhttps://www.enterprisedb.com/downloads/postgres-postgresql-downloads\n 1.2. PostgreSQL 설치  postgresql-[버전]-windows-x64.exe 파일을 실행 Next 클릭 설치할 소프트웨어를 선택하는 대화창(Select Components)에서 아래 2개만 설치  [ ] PostgreSQL Server\n[ ] Command Line Tools \n  Next 클릭 후, PostgreSQL 서버를 사용하면서 자료저장 위치 지정(default) 기본 데이터베이스 관리자 postgres계정 비밀번호 지정 포트 지정 \u0026gt; 15432(기본포트가 아닌 다른포트번호) 으로 수정후 [Next] 클릭   2. PostgreDB 서버 사용하기 2.1. PGADMIN 설치파일 다운로드 클라이언트 - 데이터베이스 조작 GUI 도구\n Download URL\nhttps://www.pgadmin.org/download/\n 2.2. PGADMIN 설치 pgadmin4-[버전]-x64.exe 실행\n기본 설정대로 [Next] 클릭하여 설치\n2.3. PGADMIN 실행 특징\n 자체 웹서버 실행 웹 브라우저로 접속하여 데이터베이스 조작가능 pgAdmin 응용프로그램을 실행시 OS의 기본 웹브라우저가 실행되면서 pgAdmin 웹프로그램을 실행하는 url을 호출 첫 접속시 최상위 관리용 비밀번호 지정 왼쪽에 있는 Servers 글자 클릭시 기본 PostgreSQL 서버 접속됨  2.4. PGADMIN 사용   화면 왼쪽 서버 트리 영역(객체 트리 영역)에서 데이터베이스 - 스키마까지 선택\n  상단의 (Tools)도구들 -\u0026gt; (Query Tools)쿼리 도구 선택하면, SQL명령 입력 및 실행 가능\nselect version()   2.5. Windows PostgreSQL 외부접속 허용설정   pg_hba.conf 접속 허용 IP 설정\nC:\\Program Files\\PostgreSQL\\{Version}\\data\\**pg_hba.conf** C:\\Program Files\\PostgreSQL\\13\\data\\**pg_hba.conf** pg_hba.conf\n# TYPE DATABASE USER ADDRESS METHOD # 특정 IP 허용 host all\tall\t192.168.0.X/32\tscram-sha-256 # 특정 IP대역 허용 host all\tall\t192.168.0.X/24\tscram-sha-256   ","date":"September 29, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/db/2020-09-29-postgredb-setup/","summary":"설치환경 : Windows 10\n1. PostgreDB 설치 1.1. 설치파일 다운로드 윈도우즈용 설치 파일은 현재 EnterpriseDB사가 배포\n Download URL\nhttps://www.enterprisedb.com/downloads/postgres-postgresql-downloads\n 1.2. PostgreSQL 설치  postgresql-[버전]-windows-x64.exe 파일을 실행 Next 클릭 설치할 소프트웨어를 선택하는 대화창(Select Components)에서 아래 2개만 설치  [ ] PostgreSQL Server\n[ ] Command Line Tools \n  Next 클릭 후, PostgreSQL 서버를 사용하면서 자료저장 위치 지정(default) 기본 데이터베이스 관리자 postgres계정 비밀번호 지정 포트 지정 \u0026gt; 15432(기본포트가 아닌 다른포트번호) 으로 수정후 [Next] 클릭   2.","tags":["db","postgredb"],"title":"PostgreDB 설치 (PostgreDB Setup)"},{"categories":["DB","mariaDB"],"contents":" 1. database 확인 SHOW DATABASES; 2. database 생성 CREATE DATABASE database_name; 3. 특정 database 접속 USE database_name; 3-1. mysql database 접속 USE mysql; 4. 사용자 확인  MariaDB[mysql]  SELECT HOST, USER, PASSWORD FROM USER; 5. 사용자 계정 생성  \u0026lsquo;id\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; 이면 로컬에서만 접속 가능  CREATE USER \u0026#39;user_id\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;user_password\u0026#39;; CREATE USER \u0026#39;user_id\u0026#39; IDENTIFIED BY \u0026#39;user_password\u0026#39;; 6. 사용자 권한 부여 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;user_id\u0026#39;@\u0026#39;%\u0026#39;; GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;user_id\u0026#39;; 7. 새로고침 FLUSH PRIVILEGES; 8. 사용자 계정 삭제  \u0026lsquo;사용자\u0026rsquo;@\u0026lsquo;접속위치\u0026rsquo;  DROP USER [\u0026#34;사용자\u0026#34;]@[\u0026#34;서버\u0026#34;]; ","date":"September 28, 2020","hero":"/images/default-hero.jpg","permalink":"https://sangjuncha-dev.github.io/posts/db/2020-09-28-mariadb-command/","summary":"1. database 확인 SHOW DATABASES; 2. database 생성 CREATE DATABASE database_name; 3. 특정 database 접속 USE database_name; 3-1. mysql database 접속 USE mysql; 4. 사용자 확인  MariaDB[mysql]  SELECT HOST, USER, PASSWORD FROM USER; 5. 사용자 계정 생성  \u0026lsquo;id\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; 이면 로컬에서만 접속 가능  CREATE USER \u0026#39;user_id\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;user_password\u0026#39;; CREATE USER \u0026#39;user_id\u0026#39; IDENTIFIED BY \u0026#39;user_password\u0026#39;; 6. 사용자 권한 부여 GRANT ALL PRIVILEGES ON database_name.* TO \u0026#39;user_id\u0026#39;@\u0026#39;%\u0026#39;; GRANT ALL PRIVILEGES ON database_name.","tags":["db","mariadb","sql"],"title":"MariaDB SQL 명령어 (MariaDB SQL Command)"}]