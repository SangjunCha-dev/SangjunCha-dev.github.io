<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Models on Sangjun 개발 블로그</title><link>https://sangjuncha-dev.github.io/categories/models/</link><description>Recent content in Models on Sangjun 개발 블로그</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 20 Apr 2021 09:30:40 +0900</lastBuildDate><atom:link href="https://sangjuncha-dev.github.io/categories/models/index.xml" rel="self" type="application/rss+xml"/><item><title>Django json 데이터 반환하기</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-20-django-model-to-json-response/</link><pubDate>Tue, 20 Apr 2021 09:30:40 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-20-django-model-to-json-response/</guid><description>api 서버 등 json 데이터로 통신하는 서버에서 사용할 수 있는 예제이다.
사전 설정 프로젝트 생성 후 user 앱의 User 모델을 생성한다.
임의의 user 데이터를 2개 등록한다.
models.py
class User(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=20, unique=True) 사용 예시 QuerySet(Model Instance)을 json형태로 변환할 경우 .all() serializers.serialize(&amp;lsquo;json&amp;rsquo;, value_name) 함수를 사용하여 json 형태로 변환시킨다.
views.py
from django.core import serializers res_data = User.objects.all() # &amp;lt;QuerySet [&amp;lt;User: User object (1)&amp;gt;, &amp;lt;User: User object (2)&amp;gt;]&amp;gt; res_data = serializers.</description></item><item><title>Django model 참조 객체 호출하기</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-models-relations-object-call/</link><pubDate>Wed, 07 Apr 2021 17:34:37 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-models-relations-object-call/</guid><description>title: author: Sangjun Cha date: 2021-04-07 +0900 categories: [Django, Models] tags: [django, models] pin: false 정참조와 역참조 객체 호출 데이터베이스의 임의의 테이블로 User, Occupation 생성한다.
두 테이블은 User 모델의 객체가 Occupation 모델의 객체를 N:1 참조관계를 가진다.
models.py 설정
class User(models.Model): name = models.CharField(max_length=50) age = models.IntegerField() job = models.ForeignKey(&amp;#39;Occupation&amp;#39;, on_delete=models.CASCADE) class Occupation(models.Model): name = models.CharField(max_length=50) 정참조 객체 호출하기 user1 객체가 Occupation 모델을 참조키(ForeignKey)로 정참조하여, Occupation 모델의 속성을 사용할 수 있다.</description></item><item><title>Django 동적 모델 및 테이블 생성</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-dynamic-model-and-table-create/</link><pubDate>Wed, 07 Apr 2021 10:51:18 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-dynamic-model-and-table-create/</guid><description>Django 동적 모델 및 테이블 생성 django는 makemigrations, migrate 명령어를 통하여 테이블 생성한다.
이때 웹서버는 실행중일 경우 중단하고 다시 재시작한다.
운영환경에 따라서 웹서버가 중단되지 않고 운영이 필요한경우에는 위의 방법이 아닌 동적 모델 및 테이블 생성방법이 필요하다.
사용 방법 상속받을 추상모델 작성 models.py
from django.db import models class Board(models.Model): title = models.CharField(max_length=100) contents = models.CharField(max_length=500) class Meta: abstract = True 동적 모델 생성 및 삭제 from .models import Board TABLE_MAP = {} def create_model(name: str): &amp;#39;&amp;#39;&amp;#39; 동적 모델 생성 &amp;#39;&amp;#39;&amp;#39; baseclass = Board tablename = board2 # attrs 를 dict 형태로 지정한다.</description></item><item><title>Django QuerySet 객체 접근방식 및 조회</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-06-django-queryset-object-access/</link><pubDate>Tue, 06 Apr 2021 15:58:51 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-06-django-queryset-object-access/</guid><description>queryset 단일객체와 다중객체 접근방법 QuerySet 이란? Database에서 응답받은 결과 목록(list)
Python 코드가 SQL 구문으로 맵핑(mapping)되고 DB로 전달하여 받은 응답값을 QuerySet 자료형으로 반환한다.
사전설정 django version : 3.2
models.py
from django.db import models class User(): name = models.CharField(max_length=20) age = models.models.PositiveSmallIntegerField() &amp;gt;&amp;gt;&amp;gt; python manage.py shell #shell 실행 &amp;gt;&amp;gt;&amp;gt; from user.models import User #모델클래스 임포트 &amp;gt;&amp;gt;&amp;gt; user1 = User(name=&amp;#39;Foo&amp;#39;, age=15) # 데이터추가 &amp;gt;&amp;gt;&amp;gt; user1.save() # 데이터 저장 &amp;gt;&amp;gt;&amp;gt; user2 = User(name=&amp;#39;Bar&amp;#39;, age=20) # 데이터추가 &amp;gt;&amp;gt;&amp;gt; user2.</description></item><item><title>Django models.AutoOneToOneField 사용법</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-03-31-django-models-autoonetoonefield/</link><pubDate>Wed, 31 Mar 2021 12:55:35 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-03-31-django-models-autoonetoonefield/</guid><description>model 상속할때 테이블 컬럼 데이터 자동 생성방법
라이브러리 설치 pip install django-annoying models 설정 django의 models.OneToOneField는 데이터 변경없이(default 설정) 저장하면 해당 데이터(row)가 생성되지않음
models.AutoOneToOneField는 데이터가 default값이어도 데이터(row) 생성됨
from annoying.fields import AutoOneToOneField # User모델 Save에서 제어 class User(models.Model): name = models.CharField(max_length=30) def save(self): is_new = False if self.pk is None: is_new = True if is_new: Profile.objects.create(user=self) class Profile(models.Model): user = AutoOneToOneField(User, primary_key=True) home_page = models.URLField(max_length=255, blank=True) icq = models.IntegerField(blank=True, null=True) 참고사항 문제점 : TypeError: __init__() missing 1 required positional argument: 'on_delete' 에러 발생</description></item></channel></rss>