<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Django on Sangjun 개발 블로그</title><link>https://sangjuncha-dev.github.io/categories/django/</link><description>Recent content in Django on Sangjun 개발 블로그</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 28 Dec 2021 19:37:11 +0900</lastBuildDate><atom:link href="https://sangjuncha-dev.github.io/categories/django/index.xml" rel="self" type="application/rss+xml"/><item><title>Django oauth apple login</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-12-28-django-oauth2-apple/</link><pubDate>Tue, 28 Dec 2021 19:37:11 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-12-28-django-oauth2-apple/</guid><description>django restframework 기반의 애플 인증 로그인 백엔드서버 구현 설명이다.
라이브러리 설치 $ pip install django # restframework $ pip install djangorestframework $ pip install djangorestframework-simplejwt # pyjwt[crypto] $ pip install pyjwt[crypto] Apple 로그인 변수 설정 import os APPLE_CONFIG = { &amp;#34;APPLE_TEAM_ID&amp;#34;: TEAM_ID, &amp;#34;APPLE_CLIENT_ID&amp;#34;: 모바일 로그인시 Bundle ID or 웹 로그인시 Service ID, &amp;#34;APPLE_REDIRECT_URI&amp;#34;: &amp;#34;https://domain/REDIRECT_URI&amp;#34;, &amp;#34;APPLE_KEY_ID&amp;#34;: KEY_ID, &amp;#34;APPLE_KEY_PATH&amp;#34;: &amp;#34;./AuthKey_KEY_ID.p8&amp;#34;, &amp;#34;APPLE_PRIVATE_KEY&amp;#34;: &amp;#34;&amp;#34;, } apple_key_path = os.path.join(CONFIG_BASE_DIR, f&amp;#34;./{APPLE_CONFIG[&amp;#39;APPLE_KEY_PATH&amp;#39;]}&amp;#34;) with open(apple_key_path, &amp;#39;r&amp;#39;) as apple_key_file: APPLE_CONFIG[&amp;#39;APPLE_PRIVATE_KEY&amp;#39;] = apple_key_file.</description></item><item><title>Django crontab 라이브러리 사용법</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-12-09-django-corntab-guide/</link><pubDate>Thu, 09 Dec 2021 15:44:54 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-12-09-django-corntab-guide/</guid><description>django-crontab 라이브러리는 OS의 cron/crontab 서비스를 사용하는것으로 해당 서비스 설치가 되지 않았다면 별도로 설치를 해야함.
windows 환경에서는 docker를 설치하여 진행 1. 라이브러리 설치 $ pip install django-crontab 2. django 설정 임의의 app 디렉터리내 cron.py 생성 아래의 함수를 작성한다.
반복 실행할 임의의 함수 선언 def hello_every_minute(): print(&amp;#34;hello world&amp;#34;) settings.py
django_crontab 앱 추가
INSTALLED_APPS = [ &amp;#39;django_crontab&amp;#39;, ... ] CRONJOBS 변수 선언</description></item><item><title>Django socketio 라이브러리 활용한 통신</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-06-11-django-websocket-using-channels-library-guide/</link><pubDate>Fri, 11 Jun 2021 10:59:51 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-06-11-django-websocket-using-channels-library-guide/</guid><description>라이브러리 설치 server 라이브러리 설치 pip install python-socketio client 라이브러리 설치 pip install &amp;#34;python-socketio[client]&amp;#34; Server django settings django server
wsgi.py
... import socketio from appname.views import sio # sio code path ... # application = get_wsgi_application() sio.register_namespace(TransferNamespace(&amp;#39;/transfer&amp;#39;)) django_app = get_wsgi_application() application = socketio.WSGIApp(sio, django_app) appname.views.py
import socketio sio = socketio.Server(async_mode=&amp;#39;threading&amp;#39;, async_handlers=True, ping_interval=60) class TransferNamespace(socketio.Namespace): def on_connect(self, sid: str, environ: dict): &amp;#39;&amp;#39;&amp;#39; 클라이언트 접속 &amp;#39;&amp;#39;&amp;#39; print(f&amp;#34;connect address = {environ[&amp;#39;REMOTE_ADDR&amp;#39;]}, sid = {sid}&amp;#34;) def on_disconnect(self, sid: str): &amp;#39;&amp;#39;&amp;#39; 클라이언트 접속 종료 &amp;#39;&amp;#39;&amp;#39; print(f&amp;#34;disconnect Client disconnected = {sid}&amp;#34;) def send_event(self, sid: str): &amp;#39;&amp;#39;&amp;#39; 특정 sid 클라이언트에 이벤트 전송 &amp;#39;&amp;#39;&amp;#39; print(&amp;#34;send_event&amp;#34;) self.</description></item><item><title>Django 파일 업로드</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-22-django-file-upload/</link><pubDate>Thu, 22 Apr 2021 13:18:18 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-22-django-file-upload/</guid><description>django 파일 업로드
청크단위 파일 업로드 대용량 업로드 가능 실시간 업로드 프로그래스바에 응용가능 from django.conf import settings def upload(request): if request.method == &amp;#39;POST&amp;#39;: path = settings.MEDIA_ROOT files = request.FILES[&amp;#39;file&amp;#39;] for file in files: file_path = f&amp;#39;{path}/{file.name}&amp;#39; with open(file_path,&amp;#39;wb+&amp;#39;) as dst_file: for chunk in file.chunks(): dst_file.write(chunk)</description></item><item><title>Django json 데이터 반환하기</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-20-django-model-to-json-response/</link><pubDate>Tue, 20 Apr 2021 09:30:40 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-20-django-model-to-json-response/</guid><description>api 서버 등 json 데이터로 통신하는 서버에서 사용할 수 있는 예제이다.
사전 설정 프로젝트 생성 후 user 앱의 User 모델을 생성한다.
임의의 user 데이터를 2개 등록한다.
models.py
class User(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=20, unique=True) 사용 예시 QuerySet(Model Instance)을 json형태로 변환할 경우 .all() serializers.serialize(&amp;lsquo;json&amp;rsquo;, value_name) 함수를 사용하여 json 형태로 변환시킨다.
views.py
from django.core import serializers res_data = User.objects.all() # &amp;lt;QuerySet [&amp;lt;User: User object (1)&amp;gt;, &amp;lt;User: User object (2)&amp;gt;]&amp;gt; res_data = serializers.</description></item><item><title>Django model 참조 객체 호출하기</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-models-relations-object-call/</link><pubDate>Wed, 07 Apr 2021 17:34:37 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-models-relations-object-call/</guid><description>정참조와 역참조 객체 호출 데이터베이스의 임의의 테이블로 User, Occupation 생성한다.
두 테이블은 User 모델의 객체가 Occupation 모델의 객체를 N:1 참조관계를 가진다.
models.py 설정
class User(models.Model): name = models.CharField(max_length=50) age = models.IntegerField() job = models.ForeignKey(&amp;#39;Occupation&amp;#39;, on_delete=models.CASCADE) class Occupation(models.Model): name = models.CharField(max_length=50) 정참조 객체 호출하기 user1 객체가 Occupation 모델을 참조키(ForeignKey)로 정참조하여, Occupation 모델의 속성을 사용할 수 있다.
user1 = User.objects.get(id = 1) user1.job.name &amp;gt;&amp;gt;&amp;gt; &amp;#39;Developer&amp;#39; 역참조 객체 호출하기 역참조 관계에서는 정참조와 같이 바로 참조한 모델의 속성을 사용할 수 없다.</description></item><item><title>Django 동적 모델 및 테이블 생성</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-dynamic-model-and-table-create/</link><pubDate>Wed, 07 Apr 2021 10:51:18 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-07-django-dynamic-model-and-table-create/</guid><description>Django 동적 모델 및 테이블 생성 django는 makemigrations, migrate 명령어를 통하여 테이블 생성한다.
이때 웹서버는 실행중일 경우 중단하고 다시 재시작한다.
운영환경에 따라서 웹서버가 중단되지 않고 운영이 필요한경우에는 위의 방법이 아닌 동적 모델 및 테이블 생성방법이 필요하다.
사용 방법 상속받을 추상모델 작성 models.py
from django.db import models class Board(models.Model): title = models.CharField(max_length=100) contents = models.CharField(max_length=500) class Meta: abstract = True 동적 모델 생성 및 삭제 from .models import Board TABLE_MAP = {} def create_model(name: str): &amp;#39;&amp;#39;&amp;#39; 동적 모델 생성 &amp;#39;&amp;#39;&amp;#39; baseclass = Board tablename = board2 # attrs 를 dict 형태로 지정한다.</description></item><item><title>Django QuerySet 객체 접근방식 및 조회</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-06-django-queryset-object-access/</link><pubDate>Tue, 06 Apr 2021 15:58:51 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-04-06-django-queryset-object-access/</guid><description>queryset 단일객체와 다중객체 접근방법 QuerySet 이란? Database에서 응답받은 결과 목록(list)
Python 코드가 SQL 구문으로 맵핑(mapping)되고 DB로 전달하여 받은 응답값을 QuerySet 자료형으로 반환한다.
사전설정 django version : 3.2
models.py
from django.db import models class User(): name = models.CharField(max_length=20) age = models.models.PositiveSmallIntegerField() &amp;gt;&amp;gt;&amp;gt; python manage.py shell #shell 실행 &amp;gt;&amp;gt;&amp;gt; from user.models import User #모델클래스 임포트 &amp;gt;&amp;gt;&amp;gt; user1 = User(name=&amp;#39;Foo&amp;#39;, age=15) # 데이터추가 &amp;gt;&amp;gt;&amp;gt; user1.save() # 데이터 저장 &amp;gt;&amp;gt;&amp;gt; user2 = User(name=&amp;#39;Bar&amp;#39;, age=20) # 데이터추가 &amp;gt;&amp;gt;&amp;gt; user2.</description></item><item><title>Django models.AutoOneToOneField 사용법</title><link>https://sangjuncha-dev.github.io/posts/framework/django/2021-03-31-django-models-autoonetoonefield/</link><pubDate>Wed, 31 Mar 2021 12:55:35 +0900</pubDate><guid>https://sangjuncha-dev.github.io/posts/framework/django/2021-03-31-django-models-autoonetoonefield/</guid><description>model 상속할때 테이블 컬럼 데이터 자동 생성방법
라이브러리 설치 pip install django-annoying models 설정 django의 models.OneToOneField는 데이터 변경없이(default 설정) 저장하면 해당 데이터(row)가 생성되지않음
models.AutoOneToOneField는 데이터가 default값이어도 데이터(row) 생성됨
from annoying.fields import AutoOneToOneField # User모델 Save에서 제어 class User(models.Model): name = models.CharField(max_length=30) def save(self): is_new = False if self.pk is None: is_new = True if is_new: Profile.objects.create(user=self) class Profile(models.Model): user = AutoOneToOneField(User, primary_key=True) home_page = models.URLField(max_length=255, blank=True) icq = models.IntegerField(blank=True, null=True) 참고사항 문제점 : TypeError: __init__() missing 1 required positional argument: 'on_delete' 에러 발생</description></item></channel></rss>