<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Sangjun 개발 블로그</title><link>https://hugo-toha.github.io/tags/algorithm/</link><description>Recent content in algorithm on Sangjun 개발 블로그</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 22 Dec 2020 22:38:31 +0900</lastBuildDate><atom:link href="https://hugo-toha.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Programmers Python (level 2)</title><link>https://hugo-toha.github.io/posts/algorithm/programmers/2020-12-22-algorithm-programmers-python-level2/</link><pubDate>Tue, 22 Dec 2020 22:38:31 +0900</pubDate><guid>https://hugo-toha.github.io/posts/algorithm/programmers/2020-12-22-algorithm-programmers-python-level2/</guid><description>프린터 분류 : 스택/큐
우선순위 priorities 리스트의 최댓값을 num_max변수에 대입 cursor변수에 priorities[0]값 추출하여 대입 cursor 값이 최댓값 일때 cnt 1증가 이때 location값이 0이면 break cursor 값이 최댓값 아닐때 리스트 맨뒤에 cursor 값 추가 이때 location값이 0이면 location변수에 priorities길이값 대입 location 1 감소 위의 순서를 location 0 이상일때 while문 반복실행 def solution(priorities, location): cnt = 1 while True: num_max = max(priorities) cursor = priorities.pop(0) if cursor == num_max: if location == 0: return cnt cnt += 1 else: priorities.</description></item><item><title>Programmers Python (level 1)</title><link>https://hugo-toha.github.io/posts/algorithm/programmers/2020-12-15-algorithm-programmers-python-level1/</link><pubDate>Tue, 15 Dec 2020 15:05:35 +0900</pubDate><guid>https://hugo-toha.github.io/posts/algorithm/programmers/2020-12-15-algorithm-programmers-python-level1/</guid><description>모의고사 분류 : 완전탐색
입력받은 answers 리스트와 수포자들의 답 리스트와 비교하여 같다면 answer_cnt변수에 정답 개수 추가 answer_cnt 리스트의 최댓값과 각 answer_cnt 원소와 비교하여 같다면 index+1 값을 answer리스트에 추가 최대 정답자 answer 리스트 return def solution(answers): answer = [] answer_cnt = [0, 0, 0] answer_list = [ [1, 2, 3, 4, 5], [2, 1, 2, 3, 2, 4, 2, 5], [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] ] # 정답 매칭 for i in range(len(answers)): ans = answers[i] if ans == answer_list[0][i%5]: answer_cnt[0] += 1 if ans == answer_list[1][i%8]: answer_cnt[1] += 1 if ans == answer_list[2][i%10]: answer_cnt[2] += 1 # 최다 정답자 추출 max_cnt = max(answer_cnt) for i, cnt in enumerate(answer_cnt): if max_cnt == cnt: answer.</description></item><item><title>LeetCode Python (Easy)</title><link>https://hugo-toha.github.io/posts/algorithm/leetcode/2020-12-01-algorithm-leetcode-python-easy/</link><pubDate>Tue, 01 Dec 2020 17:30:00 +0900</pubDate><guid>https://hugo-toha.github.io/posts/algorithm/leetcode/2020-12-01-algorithm-leetcode-python-easy/</guid><description>1. Two Sum nums 리스트 속성값 중 두개의 값이 target 값과 동일할때 해당 속성 값의 index 반환 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: for i, num in enumerate(nums): for j, num2 in enumerate(nums[i+1:]): if i != j+i+1: if target == num+num2: return [i, j+i+1] 2020-11-27
Runtime: 40 ms, faster than 97.02% of Python3 online submissions for Two Sum. Memory Usage: 14.5 MB, less than 89.</description></item></channel></rss>